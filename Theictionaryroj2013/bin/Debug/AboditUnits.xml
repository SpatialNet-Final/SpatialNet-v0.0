<?xml version="1.0"?>
<doc>
    <assembly>
        <name>AboditUnits</name>
    </assembly>
    <members>
        <member name="T:Abodit.Units.CalendarDate">
            <summary>
            A Date without a time or timezone
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDate.Year">
            <summary>
            Year
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDate.Month">
            <summary>
            Month number (1-12)
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDate.Day">
            <summary>
            Day of month (1-31)
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDate.DayOfYear">
            <summary>
            DayOfYear
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDate.Week">
            <summary>
            Week in Year - may be wrong as may want a week starting on Sunday??
            </summary>
        </member>
        <member name="F:Abodit.Units.CalendarDate.MinValue">
            <summary>
            The minimum value possible for a CalendarDate
            </summary>
        </member>
        <member name="F:Abodit.Units.CalendarDate.MaxValue">
            <summary>
            The maximum value possible for a CalendarDate
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDate"/> class
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDate.DateTime">
            <summary>
            A utc DateTime having this year, month, day
            Not really Utc, but using Utc ensures no local time conversions happen
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDate.Ticks">
            <summary>
            The number of Ticks for the DateTime this represents
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDate.DayOfWeek">
            <summary>
            The <see cref="P:Abodit.Units.CalendarDate.DayOfWeek"/> for this date
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.#ctor(System.DateTime)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDate"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.#ctor(System.DateTimeOffset)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDate"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.#ctor(System.String)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDate"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.ToString">
            <summary>
            A textual description of this CalendarDate
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.Describe(System.Boolean)">
            <summary>
            A textual description of this CalendarDate
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.Serialize">
            <summary>
            A textual description of this CalendarDate suitable for serialization
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.Equals(Abodit.Units.CalendarDate)">
            <summary>
            Compares with another <see cref="T:Abodit.Units.CalendarDate"/> for equality
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.Equals(System.Object)">
            <summary>
            CalendarDates are equal if year, month, day is the same
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.GetHashCode">
            <summary>
            Get a Hashcode for this object
            </summary>
            <returns></returns>
        </member>
        <member name="M:Abodit.Units.CalendarDate.ExtendBy(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new CalendarDateTimeRange representing the period from this date forward by a given amount
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDate.Morning">
            <summary>
            Creates a new CalendarDateTimeRange representing morning on this date
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDate.Afternoon">
            <summary>
            Creates a new CalendarDateTimeRange representing afternoon on this date
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDate.Evening">
            <summary>
            Creates a new CalendarDateTimeRange representing evening on this date
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDate.Night">
            <summary>
            Creates a new CalendarDateTimeRange representing night on this date
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.AddYears(System.Int32)">
            <summary>
            Adds a number of years to form a new CalendarDate
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.AddMonths(System.Int32)">
            <summary>
            Adds a number of months to form a new CalendarDate
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.AddWeeks(System.Int32)">
            <summary>
            Adds a number of weeks to form a new CalendarDate
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.AddDays(System.Int32)">
            <summary>
            Adds a number of days to form a new CalendarDateTime
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.AddHours(System.Int32)">
            <summary>
            Adds a number of hours to form a new CalendarDateTime
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.AddMinutes(System.Int32)">
            <summary>
            Adds a number of minutes to form a new CalendarDateTime
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.AddSeconds(System.Int32)">
            <summary>
            Adds a number of seconds to form a new CalendarDateTime
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.op_Addition(Abodit.Units.CalendarDate,Abodit.Units.TimePeriod)">
            <summary>
            Forms a <see cref="T:Abodit.Units.CalendarDateTime"/> from a <see cref="T:Abodit.Units.CalendarDate"/> and a <see cref="T:Abodit.Units.TimePeriod"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.op_Addition(Abodit.Units.CalendarDate,Abodit.Units.Time)">
            <summary>
            Forms a <see cref="T:Abodit.Units.CalendarDateTime"/> from a <see cref="T:Abodit.Units.CalendarDate"/> and a <see cref="T:Abodit.Units.Time"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.op_Addition(Abodit.Units.CalendarDate,Abodit.Units.TimeRange)">
            <summary>
            Adds a <see cref="T:Abodit.Units.TimeRange"/> to a <see cref="T:Abodit.Units.CalendarDate"/> to form a <see cref="T:Abodit.Units.CalendarDateTimeRange"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.op_Subtraction(Abodit.Units.CalendarDate,Abodit.Units.CalendarDate)">
            <summary>
            Subtracts two CalendarDates
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.CompareTo(Abodit.Units.CalendarDate)">
            <summary>
            Compares two calendar dates
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.CompareTo(Abodit.Units.CalendarDateTime)">
            <summary>
            Compares this calendar date with a CalendarDateTime
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.op_GreaterThan(Abodit.Units.CalendarDate,Abodit.Units.CalendarDate)">
            <summary>
            Compares two calendar dates
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.op_LessThan(Abodit.Units.CalendarDate,Abodit.Units.CalendarDate)">
            <summary>
            Compares two calendar dates
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.op_LessThanOrEqual(Abodit.Units.CalendarDate,Abodit.Units.CalendarDate)">
            <summary>
            Compares two calendar dates
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.op_Equality(Abodit.Units.CalendarDate,Abodit.Units.CalendarDate)">
            <summary>
            Compares two calendar dates
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.op_Inequality(Abodit.Units.CalendarDate,Abodit.Units.CalendarDate)">
            <summary>
            Compares two calendar dates
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.op_GreaterThanOrEqual(Abodit.Units.CalendarDate,Abodit.Units.CalendarDate)">
            <summary>
            Compares two calendar dates
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.EasterSunday(System.Int32)">
            <summary>
            Get Easter Sunday for a given year
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.AscensionDate(System.Int32)">
            <summary>
            Get Acension date
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.WhitSunday(System.Int32)">
            <summary>
            Get the date for Whit Sunday
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDate.FirstSundayOfAdvent(System.Int32)">
            <summary>
            The first sunday of advent is the fourth sunday before christmas
            </summary>
        </member>
        <member name="T:Abodit.Units.CalendarDateTime">
            <summary>
            A CalendarDateTime with no specific time zone and no specific offset from GMT
            Would need to convert to a specific DateTimeOffset to do any comparisons with database date time values
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTime.Date">
            <summary>
            Gets the date component
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTime.TimeOfDay">
            <summary>
            Gets the time component
            </summary>
        </member>
        <member name="F:Abodit.Units.CalendarDateTime.MinValue">
            <summary>
            Gets the minimum possible CalendarDateTime (DateTime.MinValue)
            </summary>
        </member>
        <member name="F:Abodit.Units.CalendarDateTime.MaxValue">
            <summary>
            Gets the minimum possible CalendarDateTime (DateTime.MaxValue)
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTime.IsMidnight">
            <summary>
            Is midnight?
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTime.DayOfWeek">
            <summary>
            The day of the week
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTime.Year">
            <summary>
            Gets the year
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTime.Month">
            <summary>
            Gets the month (1-12)
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTime.Day">
            <summary>
            Gets the day of month (1-31)
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTime.Hour">
            <summary>
            Gets the hour
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTime.Minute">
            <summary>
            Gets the minute
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTime.Second">
            <summary>
            Gets the second
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.#ctor(System.DateTime)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDateTime"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.#ctor(System.Int64)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDateTime"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.#ctor(System.DateTimeOffset)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDateTime"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.#ctor(Abodit.Units.CalendarDate)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDateTime"/> class at midnight
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.#ctor(Abodit.Units.CalendarDate,Abodit.Units.Time)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDateTime"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDateTime"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.#ctor(System.String)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDateTime"/> class
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTime.DateTime">
            <summary>
            Gets the equivalent .NET DateTime
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTime.UtcDateTime">
            <summary>
            Gets the equivalent .NET DateTime in UTC assuming this CalendarDateTime is in the local timezone
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTime.Ticks">
            <summary>
            Gets ticks
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.Equals(Abodit.Units.CalendarDateTime)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.CompareTo(Abodit.Units.CalendarDateTime)">
            <summary>
            Compares to another CalendarDateTime
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.CompareTo(Abodit.Units.CalendarDate)">
            <summary>
            Compares to another CalendarDateTime
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.Add(Abodit.Units.TimePeriod)">
            <summary>
            Create a CalendarDateTime by adding a timeperiod
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.AddHours(System.Double)">
            <summary>
            Create a CalendarDateTime by adding a number of hours
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.AddYears(System.Double)">
            <summary>
            Create a CalendarDateTime by adding a number of years
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.AddDays(System.Int32)">
            <summary>
            Create a CalendarDateTime by adding a number of days
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.AddWeeks(System.Double)">
            <summary>
            Create a CalendarDateTime by adding a number of weeks
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.AddMonths(System.Double)">
            <summary>
            Create a CalendarDateTime by adding a number of months
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.AddMinutes(System.Double)">
            <summary>
            Create a CalendarDateTime by adding a number of minutes
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.AddSeconds(System.Double)">
            <summary>
            Create a CalendarDateTime by adding a number of seconds
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.AtMidnight">
            <summary>
            Create a CalendarDateTime at midnight
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.ExtendBy(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a range by extension
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.ExtendBy(Abodit.Units.TimePeriod)">
            <summary>
            Create a range by extension
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.op_Addition(Abodit.Units.CalendarDateTime,Abodit.Units.TimePeriod)">
            <summary>
            Adds a TimePeriod to a CalendarDateTime
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.op_Subtraction(Abodit.Units.CalendarDateTime,Abodit.Units.TimePeriod)">
            <summary>
            Subtracts a TimePeriod from a CalendarDateTime
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.op_Addition(Abodit.Units.CalendarDateTime,Abodit.Units.Time)">
            <summary>
            Adds a Time to a CalendarDateTime
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.op_Subtraction(Abodit.Units.CalendarDateTime,Abodit.Units.CalendarDateTime)">
            <summary>
            Subtracts
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.op_Subtraction(Abodit.Units.CalendarDateTime,Abodit.Units.CalendarDate)">
            <summary>
            Subtracts
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.op_GreaterThan(Abodit.Units.CalendarDateTime,Abodit.Units.CalendarDateTime)">
            <summary>
            Compares
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.op_LessThan(Abodit.Units.CalendarDateTime,Abodit.Units.CalendarDateTime)">
            <summary>
            Compares
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.op_LessThanOrEqual(Abodit.Units.CalendarDateTime,Abodit.Units.CalendarDateTime)">
            <summary>
            Compares
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.op_Equality(Abodit.Units.CalendarDateTime,Abodit.Units.CalendarDateTime)">
            <summary>
            Compares
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.op_Inequality(Abodit.Units.CalendarDateTime,Abodit.Units.CalendarDateTime)">
            <summary>
            Compares
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.op_GreaterThanOrEqual(Abodit.Units.CalendarDateTime,Abodit.Units.CalendarDateTime)">
            <summary>
            Compares
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.op_GreaterThan(Abodit.Units.CalendarDate,Abodit.Units.CalendarDateTime)">
            <summary>
            Compares
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.op_LessThan(Abodit.Units.CalendarDate,Abodit.Units.CalendarDateTime)">
            <summary>
            Compares
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.op_LessThanOrEqual(Abodit.Units.CalendarDate,Abodit.Units.CalendarDateTime)">
            <summary>
            Compares
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.op_Equality(Abodit.Units.CalendarDate,Abodit.Units.CalendarDateTime)">
            <summary>
            Compares
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.op_Inequality(Abodit.Units.CalendarDate,Abodit.Units.CalendarDateTime)">
            <summary>
            Compares
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.op_GreaterThanOrEqual(Abodit.Units.CalendarDate,Abodit.Units.CalendarDateTime)">
            <summary>
            Compares
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.op_GreaterThan(Abodit.Units.CalendarDateTime,Abodit.Units.CalendarDate)">
            <summary>
            Compares
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.op_LessThan(Abodit.Units.CalendarDateTime,Abodit.Units.CalendarDate)">
            <summary>
            Compares
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.op_LessThanOrEqual(Abodit.Units.CalendarDateTime,Abodit.Units.CalendarDate)">
            <summary>
            Compares
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.op_GreaterThanOrEqual(Abodit.Units.CalendarDateTime,Abodit.Units.CalendarDate)">
            <summary>
            Compares
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.op_Equality(Abodit.Units.CalendarDateTime,Abodit.Units.CalendarDate)">
            <summary>
            Compares
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.op_Inequality(Abodit.Units.CalendarDateTime,Abodit.Units.CalendarDate)">
            <summary>
            Compares
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.Min(Abodit.Units.CalendarDateTime,Abodit.Units.CalendarDateTime)">
            <summary>
            Returns the minimum of two CalendarDateTime values
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.Max(Abodit.Units.CalendarDateTime,Abodit.Units.CalendarDateTime)">
            <summary>
            Returns the minimum of two CalendarDateTime values
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.Describe(System.Boolean)">
            <summary>
            Returns an text version of this CalendarDateTime in ISO order
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.Serialize">
            <summary>
            Returns an text version of this CalendarDateTime in ISO order
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.ToString">
            <summary>
            Returns an text version of this CalendarDateTime in ISO order
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.GetTypeCode">
            <summary>
            IConvertible implementation
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.ToBoolean(System.IFormatProvider)">
            <summary>
            IConvertible implementation
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.ToChar(System.IFormatProvider)">
            <summary>
            IConvertible implementation
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.ToSByte(System.IFormatProvider)">
            <summary>
            IConvertible implementation
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.ToByte(System.IFormatProvider)">
            <summary>
            IConvertible implementation
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.ToInt16(System.IFormatProvider)">
            <summary>
            IConvertible implementation
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.ToUInt16(System.IFormatProvider)">
            <summary>
            IConvertible implementation
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.ToInt32(System.IFormatProvider)">
            <summary>
            IConvertible implementation
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.ToUInt32(System.IFormatProvider)">
            <summary>
            IConvertible implementation
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.ToInt64(System.IFormatProvider)">
            <summary>
            IConvertible implementation
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.ToUInt64(System.IFormatProvider)">
            <summary>
            IConvertible implementation
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.ToSingle(System.IFormatProvider)">
            <summary>
            IConvertible implementation
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.ToDouble(System.IFormatProvider)">
            <summary>
            IConvertible implementation
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.ToDecimal(System.IFormatProvider)">
            <summary>
            IConvertible implementation
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.ToDateTime(System.IFormatProvider)">
            <summary>
            IConvertible implementation
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.ToString(System.IFormatProvider)">
            <summary>
            IConvertible implementation
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTime.ToType(System.Type,System.IFormatProvider)">
            <summary>
            IConvertible implementation
            </summary>
        </member>
        <member name="T:Abodit.Units.CalendarDateTimeRange">
            <summary>
            A date time range
            </summary>
        </member>
        <member name="F:Abodit.Units.CalendarDateTimeRange.Start">
            <summary>
            Gets the start of range
            </summary>
        </member>
        <member name="F:Abodit.Units.CalendarDateTimeRange.End">
            <summary>
            Gets the end of range
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.#ctor(Abodit.Units.CalendarDateTime,Abodit.Units.CalendarDateTime)">
            <summary>
            Initializes a new CalendarDateTimeRange based on a given start point and end point
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.#ctor(Abodit.Units.CalendarDate,Abodit.Units.CalendarDate)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDateTimeRange"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.#ctor(Abodit.Units.CalendarDate,Abodit.Units.CalendarDateTime)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDateTimeRange"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.#ctor(Abodit.Units.CalendarDateTime,Abodit.Units.CalendarDate)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDateTimeRange"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.#ctor(System.Int64,System.Int64)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDateTimeRange"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.#ctor(Abodit.Units.CalendarDateTime,Abodit.Units.TimePeriod)">
            <summary>
            Initializes a new CalendarDateTimeRange based on a given start point for a given duration
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.#ctor(Abodit.Units.DateTimeRange)">
            <summary>
            Construct a CalendarDateTimeRange from a regular DateTime range - by taking the local times off it
            </summary>
            <param name="other"></param>
        </member>
        <member name="P:Abodit.Units.CalendarDateTimeRange.Duration">
            <summary>
            Gets the duration
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.Contains(Abodit.Units.CalendarDateTime)">
            <summary>
            Checks for strict containment (equal to or greater than start and less than end)
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTimeRange.ContainsExpressionCalendarDateTime">
            <summary>
            Get a CalendarDateTime Expression that represents this CalendarDateTimeRange
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTimeRange.ContainsExpressionDateTime">
            <summary>
            Get a DateTime Expression that represents this CalendarDateTimeRange
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.ToString">
            <summary>
            Returns a text version
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.Describe">
            <summary>
            Returns a text version
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.Add(Abodit.Units.TimePeriod)">
            <summary>
            Move forward a given period
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.Add(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Move forward a given period
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.Shift(Abodit.Units.TimePeriod)">
            <summary>
            Move by a given time period
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.ShiftDays(System.Int32)">
            <summary>
            Move forward a given number of days.
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.ShiftWeeks(System.Int32)">
            <summary>
            Move forward a given number of weeks.
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.ShiftMonths(System.Int32)">
            <summary>
            Shift the range along by a number of months
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.ShiftYears(System.Int32)">
            <summary>
            Shift the range along by a number of years
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTimeRange.Morning">
            <summary>
            Get the morning only - 5AM to noon
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTimeRange.Afternoon">
            <summary>
            Get the afternoon only - noon to 6pm
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTimeRange.Evening">
            <summary>
            Get the evening only - 6PM to midnight
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTimeRange.Night">
            <summary>
            Get the night only - 9pm to 6am
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.WithDuration(System.Int32)">
            <summary>
            Change the duration to a number of hours
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.OneDay(Abodit.Units.CalendarDate)">
            <summary>
            A whole day range
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.OneWeek(Abodit.Units.CalendarDate)">
            <summary>
            The week containing the date specified
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.OneWeekend(Abodit.Units.CalendarDate)">
            <summary>
            The weekend including or after the date specified
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.OneMonth(Abodit.Units.CalendarDate)">
            <summary>
            The month containing the date specified
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.SpecificMonth(Abodit.Units.CalendarDate,System.Int32)">
            <summary>
            A specific month
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.OneQuarter(Abodit.Units.CalendarDate)">
            <summary>
            The quarter containing the date specified
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.OneHalf(Abodit.Units.CalendarDate)">
            <summary>
            The half containing the date specified
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.OneYear(Abodit.Units.CalendarDate)">
            <summary>
            The year containing the date specified
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTimeRange.IsBefore">
            <summary>
            Is this datetime before the range?
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTimeRange.IsAfter">
            <summary>
            Is this datetime after the range?
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.Overlaps(Abodit.Units.CalendarDateTimeRange)">
            <summary>
            Does this range overlap?
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.OverlapsOrTouches(Abodit.Units.CalendarDateTimeRange)">
            <summary>
            Does this range overlap OR touch?
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.Merge(Abodit.Units.CalendarDateTimeRange)">
            <summary>
            Merge two OVERLAPPING or ADJACENT ranges (if non-overlapping it will add the bit in between)
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTimeRange.AsCalendarDateTimeRangeCollection">
            <summary>
            Make a single item into a collection
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.Union(Abodit.Units.CalendarDateTimeRange)">
            <summary>
            Union of two time ranges
            </summary>
            <remarks>
            This could be two time ranges or it could be just one if they overlap
            </remarks>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.IntersectWith(Abodit.Units.CalendarDateTimeRange)">
            <summary>
            Intersection or null
            </summary>
        </member>
        <member name="F:Abodit.Units.CalendarDateTimeRange.NullRange">
            <summary>
            A special null range CalendarDateTimeRange
            </summary>
            <remarks>
            Rather than returning a null we return one of these when there is nothing in range
            </remarks>
        </member>
        <member name="F:Abodit.Units.CalendarDateTimeRange.UnknownRange">
            <summary>
            A special unknown range CalendarDateTimeRange
            </summary>
            <remarks>
            Rather than returning a null we return one of these when there is nothing in range
            </remarks>
        </member>
        <member name="F:Abodit.Units.CalendarDateTimeRange.LargestPlausible">
            <summary>
            A special range covering all plausible times, may result in a huge expansion!!
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.Equals(Abodit.Units.CalendarDateTimeRange)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.GetHashCode">
            <summary>
            Get Hashcode
            </summary>
            <returns></returns>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.EnumerateUnionForward(Abodit.Units.CalendarDateTime,System.Collections.Generic.IEnumerable{Abodit.Units.CalendarDateTimeRange},System.Collections.Generic.IEnumerable{Abodit.Units.CalendarDateTimeRange})">
            <summary>
            Enumerate the intersection of two sorted CalendarDateTimeRange sequences
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRange.EnumerateUnionBackward(Abodit.Units.CalendarDateTime,System.Collections.Generic.IEnumerable{Abodit.Units.CalendarDateTimeRange},System.Collections.Generic.IEnumerable{Abodit.Units.CalendarDateTimeRange})">
            <summary>
            Enumerate a union of two CalendarDateTimeRange sequences
            </summary>
        </member>
        <member name="T:Abodit.Units.CalendarDateTimeRangeOneHour">
            <summary>
            A subclass of CalendarDateTimeRange that provides syntactic sugar on a range being a specific hour
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeOneHour.#ctor(Abodit.Units.CalendarDateTime)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDateTimeRangeOneHour"/> class
            </summary>
        </member>
        <member name="T:Abodit.Units.CalendarDateTimeRangeOneDay">
            <summary>
            A subclass of CalendarDateTimeRange that provides syntactic sugar on a range being a specific day
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeOneDay.#ctor(Abodit.Units.CalendarDate)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDateTimeRangeOneDay"/> class
            </summary>
        </member>
        <member name="T:Abodit.Units.CalendarDateTimeRangeOneWeek">
            <summary>
            A subclass of CalendarDateTimeRange that provides syntactic sugar on a range being a specific week
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeOneWeek.#ctor(Abodit.Units.CalendarDate)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDateTimeRangeOneWeek"/> class
            </summary>
        </member>
        <member name="T:Abodit.Units.CalendarDateTimeRangeOneWeekend">
            <summary>
            A subclass of CalendarDateTimeRange that provides syntactic sugar on a range being a specific weekend
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeOneWeekend.#ctor(Abodit.Units.CalendarDate)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDateTimeRangeOneWeekend"/> class
            </summary>
        </member>
        <member name="T:Abodit.Units.CalendarDateTimeRangeOneMonth">
            <summary>
            A subclass of CalendarDateTimeRange that provides syntactic sugar on a range being a specific month
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeOneMonth.#ctor(Abodit.Units.CalendarDate)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDateTimeRangeOneMonth"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeOneMonth.Describe">
            <summary>
            Returns a text version
            </summary>
        </member>
        <member name="T:Abodit.Units.CalendarDateTimeRangeOneQuarter">
            <summary>
            A subclass of CalendarDateTimeRange that provides syntactic sugar on a range being a specific month
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTimeRangeOneQuarter.Quarter">
            <summary>
            Gets the quarter
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeOneQuarter.#ctor(Abodit.Units.CalendarDate)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDateTimeRangeOneQuarter"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeOneQuarter.Describe">
            <summary>
            Returns a text version
            </summary>
        </member>
        <member name="T:Abodit.Units.CalendarDateTimeRangeOneHalf">
            <summary>
            A subclass of CalendarDateTimeRange that provides syntactic sugar on a range being a specific month
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTimeRangeOneHalf.Half">
            <summary>
            Gets the Half (1 or 2)
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeOneHalf.#ctor(Abodit.Units.CalendarDate)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDateTimeRangeOneHalf"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeOneHalf.Describe">
            <summary>
            Returns a text version
            </summary>
        </member>
        <member name="T:Abodit.Units.CalendarDateTimeRangeOneYear">
            <summary>
            A subclass of CalendarDateTimeRange that provides syntactic sugar on a range being a specific year
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeOneYear.#ctor(Abodit.Units.CalendarDate)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDateTimeRangeOneYear"/> class
            </summary>
        </member>
        <member name="T:Abodit.Units.CalendarDateTimeRangeOneDecade">
            <summary>
            A subclass of CalendarDateTimeRange that provides syntactic sugar on a range being a specific decade
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeOneDecade.#ctor(System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDateTimeRangeOneDecade"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeOneDecade.Describe">
            <summary>
            Describe this object
            </summary>
        </member>
        <member name="T:Abodit.Units.CalendarDateTimeRangeOneCentury">
            <summary>
            A subclass of CalendarDateTimeRange that provides syntactic sugar on a range being a specific century
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeOneCentury.#ctor(System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDateTimeRangeOneCentury"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeOneCentury.Describe">
            <summary>
            Describe this object
            </summary>
        </member>
        <member name="T:Abodit.Units.CalendarDateTimeRangeOneMillennium">
            <summary>
            A subclass of CalendarDateTimeRange that provides syntactic sugar on a range being a specific millennium
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeOneMillennium.#ctor(System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDateTimeRangeOneCentury"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeOneMillennium.Describe">
            <summary>
            Describe this object
            </summary>
        </member>
        <member name="T:Abodit.Units.CalendarDateTimeRangeCollection">
            <summary>
            A collection of DateTimeRanges (must be finite!)
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTimeRangeCollection.IsEmpty">
            <summary>
            Is this an empty collection?
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTimeRangeCollection.IsUnknown">
            <summary>
            Is this the special Unknown collection?
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTimeRangeCollection.EarliestStart">
            <summary>
            Earliest start of any range in collection
            </summary>
        </member>
        <member name="P:Abodit.Units.CalendarDateTimeRangeCollection.LatestEnd">
            <summary>
            Latest end of any range in collection
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeCollection.#ctor(System.Collections.Generic.IEnumerable{Abodit.Units.CalendarDateTimeRange})">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDateTimeRangeCollection"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeCollection.#ctor(Abodit.Units.CalendarDateTimeRange[])">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CalendarDateTimeRangeCollection"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeCollection.Union(Abodit.Units.CalendarDateTimeRangeCollection)">
            <summary>
            Union of two calendar date time range collections (no deduplication or merging, use Simplify())
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeCollection.Intersect(Abodit.Units.CalendarDateTimeRangeCollection)">
            <summary>
            Intersect two finite sequences to find all the overlapping pieces
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeCollection.Simplify">
            <summary>
            An OPTIMIZATION - to simplify into the minimal set of ranges
            </summary>
            <remarks>
            TODO: Make this lazy also
            </remarks>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeCollection.ToString">
            <summary>
            Returns a string representation of this object
            </summary>
        </member>
        <member name="F:Abodit.Units.CalendarDateTimeRangeCollection.Unknown">
            <summary>
            An Unknown collection
            </summary>
        </member>
        <member name="F:Abodit.Units.CalendarDateTimeRangeCollection.Empty">
            <summary>
            An Empty collection
            </summary>
        </member>
        <member name="T:Abodit.Units.CalendarDateTimeRangeCollection.CalendarDateTimeRangeCollectionUnknown">
            <summary>
            The unknown collection
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeCollection.GetEnumerator">
            <summary>
            IEnumerable
            </summary>
        </member>
        <member name="T:Abodit.Units.CalendarDateTimeRangeNull">
            <summary>
            A special null range date time value - empty
            </summary>
            <remarks>
            When you operate against a null range you normally get back another null or maybe just yourself
            </remarks>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeNull.Overlaps(Abodit.Units.CalendarDateTimeRange)">
            <summary>
            Overlaps
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeNull.IntersectWith(Abodit.Units.CalendarDateTimeRange)">
            <summary>
            Intersect with another
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeNull.Union(Abodit.Units.CalendarDateTimeRange)">
            <summary>
            Union with another
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeNull.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Units.CalendarDateTimeRangeUnknown">
            <summary>
            A special unknown range
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeUnknown.Overlaps(Abodit.Units.CalendarDateTimeRange)">
            <summary>
            Overlaps
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeUnknown.IntersectWith(Abodit.Units.CalendarDateTimeRange)">
            <summary>
            Intersect with another
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeUnknown.Union(Abodit.Units.CalendarDateTimeRange)">
            <summary>
            Union with another
            </summary>
        </member>
        <member name="M:Abodit.Units.CalendarDateTimeRangeUnknown.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Units.DateTimeExtension">
            <summary>
            Extension methods for DateTime values
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeExtension.Next(System.DateTime,System.DayOfWeek)">
            <summary>
            Next occurrence of dayofweek after today
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeExtension.Previous(System.DateTime,System.DayOfWeek)">
            <summary>
            Previous occurrence of dayofweek before today
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeExtension.Spoken(System.DateTimeOffset)">
            <summary>
            Turn a datetime into something speakable like "half past two"
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeExtension.Spoken(System.DateTime)">
            <summary>
            Turn a datetime into something speakable like "half past two"
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeExtension.Greeting(System.DateTimeOffset)">
            <summary>
            Good afternoon, morning etc.
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeExtension.Greeting(System.DateTime)">
            <summary>
            Good afternoon, goor morning, good evening
            </summary>
            <param name="now"></param>
            <returns></returns>
        </member>
        <member name="M:Abodit.Units.DateTimeExtension.English(System.TimeSpan)">
            <summary>
            Format a timespan the way a human would say it
            </summary>
            <param name="ts"></param>
            <returns></returns>
        </member>
        <member name="M:Abodit.Units.DateTimeExtension.EnglishAgo(System.TimeSpan)">
            <summary>
            Convert a TimeSpan to an "ago" string
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeExtension.EnglishAgo(System.DateTimeOffset)">
            <summary>
            Convert a DateTimeOffset to an "ago" string using the current TimeProvider
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeExtension.SpeakableTime(System.DateTimeOffset)">
            <summary>
            Format a time the way a human would say it, e.g. "10 minutes to 4"
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeExtension.SpeakableTime(System.DateTime)">
            <summary>
            Format a time the way a human would say it, e.g. "10 minutes to 4"
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeExtension.ToShortest(System.Nullable{System.DateTime})">
            <summary>
            Shortest for nullable date times
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Abodit.Units.DateTimeExtension.ToShortestLocal(System.Nullable{System.DateTime})">
            <summary>
            Shortest Localtime for nullable date times
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Abodit.Units.DateTimeExtension.ToShortest(System.DateTime)">
            <summary>
            Shortest possible version of a datetime,e.g. 10:17, 4:45PM yesterday, ...
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeExtension.ToShortest(System.DateTimeOffset)">
            <summary>
            Shortest possible version of a datetime,e.g. 10:17, 4:45PM yesterday, ...
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeExtension.AtShortest(System.DateTime)">
            <summary>
            Shortest possible version of a datetime with an AT in front if appropriate,e.g. at 10:17, at 4:45PM tomorrow, ...
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeExtension.AtShortest(System.DateTimeOffset)">
            <summary>
            Shortest possible version of a datetime with an AT in front if appropriate,e.g. at 10:17, at 4:45PM tomorrow, ...
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeExtension.EnglishDateTime(System.DateTimeOffset)">
            <summary>
            Turn a datetime into "Yesterday, Today, Tuesday plus short time 2:45PM"
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeExtension.EnglishDateTime(System.DateTime)">
            <summary>
            Turn a datetime into "Yesterday, Today, Tuesday plus short time 2:45PM"
            </summary>
            <returns></returns>
        </member>
        <member name="M:Abodit.Units.DateTimeExtension.IsOlderThanSeconds(System.DateTime,System.Int32)">
            <summary>
            Useful for tracking time after a given start point
            </summary>
        </member>
        <member name="T:Abodit.Units.TimeProvider">
            <summary>
            TimeProvider allows for replacement of DateTime.UtcNow for testing and other situations
            </summary>
            <remarks>
            The <see cref="T:Abodit.Units.DefaultTimeProvider"/> calls through to DateTimeOffset.UtcNow.
            A <see cref="T:Abodit.Units.ManualTimeProvider"/> makes testing easy.
            A time provider must NEVER go backwards in time.
            </remarks>
        </member>
        <member name="P:Abodit.Units.TimeProvider.Current">
            <summary>
            Set the current time provider
            </summary>
        </member>
        <member name="F:Abodit.Units.TimeProvider.EarliestFeasible">
            <summary>
            Earliest feasible date (1970,1,1)
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.UtcNow">
            <summary>
            UtcNow
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.UtcNowUniqueTicks">
            <summary>
            Get the current Utc tick value but increment it to make it unique for each call to this function
            so it can serve as a time stamp
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.Now">
            <summary>
            DateTimeOffset now
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.CalendarNow">
            <summary>
            CalendarDateTime for now
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.TodayPartial">
            <summary>
            The period from midnight to now
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.Today">
            <summary>
            All of today
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.CalendarToday">
            <summary>
            All of today
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.Yesterday">
            <summary>
            Yesterday
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.CalendarYesterday">
            <summary>
            Yesterday
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.CalendarLastNight">
            <summary>
            Last night
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.CalendarTonight">
            <summary>
            Tonight
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.CalendarTomorrowNight">
            <summary>
            Tomorrow night
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.Tomorrow">
            <summary>
            Tomorrow
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.CalendarTomorrow">
            <summary>
            Tomorrow
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.CalendarNext10Days">
            <summary>
            The next 10 days
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.LastHour">
            <summary>
            Last hour
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.LastTwoHours">
            <summary>
            Last two hours
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.LastFourHours">
            <summary>
            Last four hours
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.Last12Hours">
            <summary>
            Last twelve hours 
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.Last24HoursNotAligned">
            <summary>
            Last 24 hours not aligned to a day
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.Last7DaysNotAligned">
            <summary>
            Last 24 x 7 hours not aligned to a day
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.Last365DaysNotAligned">
            <summary>
            Last 365 x 24 hours not aligned to a day
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.ThisCalendarHalf">
            <summary>
            This half year
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.LastCalendarHalf">
            <summary>
            Previous calendar half year
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.NextCalendarHalf">
            <summary>
            Next calendar half year
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.ThisCalendarQuarter">
            <summary>
            The quarter
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.LastCalendarQuarter">
            <summary>
            Last quarter
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.NextCalendarQuarter">
            <summary>
            Next quarter
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.ThisCalendarMonth">
            <summary>
            This month
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.LastCalendarMonth">
            <summary>
            Last month
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.NextCalendarMonth">
            <summary>
            Next month
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.ThisCalendarWeek">
            <summary>
            This week
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.LastCalendarWeek">
            <summary>
            The previous week
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.NextCalendarWeek">
            <summary>
            Next week
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.ThisCalendarWeekend">
            <summary>
            This weekend
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.LastCalendarWeekend">
            <summary>
            The previous weekend
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.NextCalendarWeekend">
            <summary>
            The next weekend
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeProvider.MonthThisCalendarYear(System.Int32)">
            <summary>
            A specific month this year
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeProvider.MonthLastCalendarYear(System.Int32)">
            <summary>
            A specific month last year
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeProvider.MonthNextCalendarYear(System.Int32)">
            <summary>
            A specific month next year
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.ThisCalendarYear">
            <summary>
            This year
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.LastCalendarYear">
            <summary>
            Last year
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.NextCalendarYear">
            <summary>
            Next year
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.ThisOrNextCalendarYear">
            <summary>
            This year or next year
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.Last365CalendarDays">
            <summary>
            The last 365 days
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeProvider.This(Abodit.Temporal.TemporalSetInfiniteMonthSpecific)">
            <summary>
            A specific month of this year
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeProvider.This(System.DayOfWeek)">
            <summary>
            A specific day of the week in this week
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeProvider.This(System.Int32)">
            <summary>
            A specfic day of this month
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeProvider.This(System.Int32,System.Int32)">
            <summary>
            The specific day and month of this year
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeProvider.Last(Abodit.Temporal.TemporalSetInfiniteMonthSpecific)">
            <summary>
            The previous specific month
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeProvider.Last(System.DayOfWeek)">
            <summary>
            The previous specific day of the week
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeProvider.Last(System.Int32,System.Int32)">
            <summary>
            The previous specific day and month
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeProvider.Last(System.Int32)">
            <summary>
            e.g. the previous 5th day of the month
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeProvider.Next(Abodit.Temporal.TemporalSetInfiniteMonthSpecific)">
            <summary>
            The next specific month
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeProvider.Next(System.DayOfWeek)">
            <summary>
            The next specific day of the week
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeProvider.Next(System.Int32,System.Int32)">
            <summary>
            The next specific day of the year
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeProvider.Next(System.Int32)">
            <summary>
            The next specific day of a month
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.IsNight">
            <summary>
            Is it night time
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.IsMorning">
            <summary>
            Is is morning 
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.IsAfternoon">
            <summary>
            Is is afternoon 
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeProvider.IsEvening">
            <summary>
            Is is evening 
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeProvider.ResetToDefault">
            <summary>
            Puts the TimeProvider back to the default
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeProvider.ToString">
            <summary>
            Returns a string representation of the current time provider's state
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeProvider.StartUsing(Abodit.Units.TimeProvider)">
            <summary>
            Start using a new time provider in a using block
            </summary>
            <param name="newTimeProvider">The new time provider to use</param>
            <returns>An IDisposable that will revert to the old time provider when disposed</returns>
        </member>
        <member name="T:Abodit.Units.DefaultTimeProvider">
            <summary>
            The default time provider uses DateTime.UtcNow
            </summary>
        </member>
        <member name="F:Abodit.Units.DefaultTimeProvider.Instance">
            <summary>
            A singleton instance of the default time provider
            </summary>
        </member>
        <member name="P:Abodit.Units.DefaultTimeProvider.Now">
            <summary>
            Now
            </summary>
        </member>
        <member name="T:Abodit.Units.ManualTimeProvider">
            <summary>
            The ManualTimeProvider is good for testing - you can manually advance time as you wish to simulate real time
            </summary>
        </member>
        <member name="P:Abodit.Units.ManualTimeProvider.Now">
            <summary>
            Get the Now time
            </summary>
        </member>
        <member name="M:Abodit.Units.ManualTimeProvider.#ctor">
            <summary>
            Create a new ManualTimeProvider for testing (starting at curent UtcNow time)
            </summary>
        </member>
        <member name="M:Abodit.Units.ManualTimeProvider.#ctor(System.DateTimeOffset)">
            <summary>
            Create a new ManualTimeProvider for testing starting at a specific time
            </summary>
        </member>
        <member name="M:Abodit.Units.ManualTimeProvider.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a new ManualTimeProvider for testing starting at a specific year month day at 12:30:36
            </summary>
        </member>
        <member name="M:Abodit.Units.ManualTimeProvider.AddMinutes(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Do not use this, it's obsolete
            </summary>
        </member>
        <member name="M:Abodit.Units.ManualTimeProvider.Add(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Add a given interval to the current time
            </summary>
        </member>
        <member name="T:Abodit.Units.DateTimeRange">
            <summary>
            A date time range between two DateTimeOffset objects
            </summary>
            <remarks>
            Use CalendarDateTimeRange instead when you do not have a TimeZone offset
            </remarks>
        </member>
        <member name="P:Abodit.Units.DateTimeRange.Start">
            <summary>
            Gets the start of the range
            </summary>
        </member>
        <member name="P:Abodit.Units.DateTimeRange.End">
            <summary>
            Gets the end of the range
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRange.#ctor(System.DateTimeOffset,System.DateTimeOffset)">
            <summary>
            Initializes a new DateTimeRange based on a given start point and end point
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRange.#ctor(System.DateTimeOffset,Abodit.Units.TimePeriod)">
            <summary>
            Initializes a new DateTimeRange based on a given start point for a given duration
            </summary>
        </member>
        <member name="P:Abodit.Units.DateTimeRange.Duration">
            <summary>
            Gets the duration as a TimeSpan
            </summary>
        </member>
        <member name="P:Abodit.Units.DateTimeRange.TotalSeconds">
            <summary>
            Gets the total number of seconds in the range
            </summary>
        </member>
        <member name="P:Abodit.Units.DateTimeRange.ContainsExpression">
            <summary>
            Get a DateTime Expression that represents this DateTimeRange
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRange.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRange.AddDays(System.Int32)">
            <summary>
            Move forward a given number of days.
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRange.AddWeeks(System.Int32)">
            <summary>
            Move forward a given number of weeks.
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRange.AddMonths(System.Int32)">
            <summary>
            Not really a simple add months, it's a new range one month long starting one month from the former start date
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRange.AddYears(System.Int32)">
            <summary>
            Not really a simple add years, it's ONE year from the new start date
            </summary>
        </member>
        <member name="P:Abodit.Units.DateTimeRange.Morning">
            <summary>
            Get the morning only - no matter how long this one was - midnight from start for 12 hours
            </summary>
        </member>
        <member name="P:Abodit.Units.DateTimeRange.Afternoon">
            <summary>
            Get the afternoon only - noon to 6pm
            </summary>
        </member>
        <member name="P:Abodit.Units.DateTimeRange.Evening">
            <summary>
            Get the evening only - 6PM to midnight
            </summary>
        </member>
        <member name="P:Abodit.Units.DateTimeRange.Night">
            <summary>
            Get the night only - 9pm to 9am
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRange.WithDuration(System.Int32)">
            <summary>
            Change the duration to a number of hours
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRange.OneDay(System.DateTimeOffset)">
            <summary>
            A single day
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRange.OneWeek(System.DateTimeOffset)">
            <summary>
            The week containing the date specified
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRange.OneMonth(System.DateTimeOffset)">
            <summary>
            The month containing the date specified
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRange.SpecificMonth(System.DateTimeOffset,System.Int32)">
            <summary>
            A specific month
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRange.OneYear(System.DateTimeOffset)">
            <summary>
            The year containing the date specified
            </summary>
        </member>
        <member name="P:Abodit.Units.DateTimeRange.IsBefore">
            <summary>
            Is this datetime before the range?
            </summary>
        </member>
        <member name="P:Abodit.Units.DateTimeRange.IsAfter">
            <summary>
            Is this datetime after the range?
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRange.Distinct(Abodit.Units.DateTimeRange)">
            <summary>
            No overlap at all
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRange.Overlaps(Abodit.Units.DateTimeRange)">
            <summary>
            Overlaps another time range
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Abodit.Units.DateTimeRange.Merge(Abodit.Units.DateTimeRange)">
            <summary>
            Merge two OVERLAPPING or ADJACENT ranges (if non-overlapping it will add the bit in between)
            </summary>
        </member>
        <member name="P:Abodit.Units.DateTimeRange.AsDateTimeRangeCollection">
            <summary>
            Make a single item into a collection
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRange.Union(Abodit.Units.DateTimeRange)">
            <summary>
            Union of two time ranges
            </summary>
            <remarks>
            This could be two time ranges or it could be just one if they overlap
            </remarks>
        </member>
        <member name="M:Abodit.Units.DateTimeRange.Intersect(Abodit.Units.DateTimeRange)">
            <summary>
            Intersection or null
            </summary>
        </member>
        <member name="P:Abodit.Units.DateTimeRange.NullRange">
            <summary>
            A special null range datetimerange
            </summary>
            <remarks>
            Rather than returning a null we return one of these when there is nothing in range
            </remarks>
        </member>
        <member name="M:Abodit.Units.DateTimeRange.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRange.Equals(Abodit.Units.DateTimeRange)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRange.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Units.DateTimeRangeNull">
            <summary>
            A special null range date time value - empty
            </summary>
            <remarks>
            When you operate against a null range you normally get back another null or maybe just yourself
            </remarks>
        </member>
        <member name="M:Abodit.Units.DateTimeRangeNull.Overlaps(Abodit.Units.DateTimeRange)">
            <summary>
            Overlaps another DateTimeRange
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRangeNull.Intersect(Abodit.Units.DateTimeRange)">
            <summary>
            Intersect with another
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRangeNull.Union(Abodit.Units.DateTimeRange)">
            <summary>
            Union a range collection with another range
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRangeNull.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Units.DateTimeRangeOneHour">
            <summary>
            A subclass of DateTimeRange that provides syntactic sugar on a range being a specific hour
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRangeOneHour.#ctor(System.DateTimeOffset)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.DateTimeRangeOneHour"/> class
            </summary>
        </member>
        <member name="T:Abodit.Units.DateTimeRangeOneDay">
            <summary>
            A subclass of DateTimeRange that provides syntactic sugar on a range being a specific day
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRangeOneDay.#ctor(System.DateTimeOffset)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.DateTimeRangeOneDay"/> class
            </summary>
        </member>
        <member name="T:Abodit.Units.DateTimeRangeOneWeek">
            <summary>
            A subclass of DateTimeRange that provides syntactic sugar on a range being a specific week
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRangeOneWeek.#ctor(System.DateTimeOffset)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.DateTimeRangeOneWeek"/> class
            </summary>
        </member>
        <member name="T:Abodit.Units.DateTimeRangeOneMonth">
            <summary>
            A subclass of DateTimeRange that provides syntactic sugar on a range being a specific month
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRangeOneMonth.#ctor(System.DateTimeOffset)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.DateTimeRangeOneMonth"/> class
            </summary>
        </member>
        <member name="T:Abodit.Units.DateTimeRangeOneYear">
            <summary>
            A subclass of DateTimeRange that provides syntactic sugar on a range being a specific year
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRangeOneYear.#ctor(System.DateTimeOffset)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.DateTimeRangeOneYear"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.DateTimeRangeCollection">
            <summary>
            A collection of DateTimeRanges
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRangeCollection.#ctor(System.Collections.Generic.IEnumerable{Abodit.Units.DateTimeRange})">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.DateTimeRangeCollection"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRangeCollection.#ctor(Abodit.Units.DateTimeRange[])">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.DateTimeRangeCollection"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRangeCollection.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.DateTimeRangeCollection"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRangeCollection.Union(Abodit.Units.DateTimeRangeCollection)">
            <summary>
            Union two collections
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRangeCollection.Intersect(Abodit.Units.DateTimeRangeCollection)">
            <summary>
            Intersect two finite sequences to find all the overlapping pieces
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRangeCollection.Simplify">
            <summary>
            An OPTIMIZATION - to simplify into the minimal set of ranges
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeRangeCollection.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Units.MoonPhase">
            <summary>
            The phase of the moon
            </summary>
        </member>
        <member name="M:Abodit.Units.MoonPhase.GetMoonPhase(System.DateTime)">
            <summary>
            Get the phase of the moon
            </summary>
        </member>
        <member name="M:Abodit.Units.MoonPhase.GetMoonPhaseString(System.DateTime)">
            <summary>
            Moon phase as a description
            </summary>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="T:Abodit.Units.Time">
            <summary>
            A Time of day, e.g. 09:30.
            </summary>
        </member>
        <member name="P:Abodit.Units.Time.Hour">
            <summary>
            The hour
            </summary>
        </member>
        <member name="P:Abodit.Units.Time.Minute">
            <summary>
            The minute
            </summary>
        </member>
        <member name="P:Abodit.Units.Time.Second">
            <summary>
            The second
            </summary>
        </member>
        <member name="F:Abodit.Units.Time.Midnight">
            <summary>
            Midnight (a constant time value)
            </summary>
        </member>
        <member name="F:Abodit.Units.Time.Noon">
            <summary>
            Noon (a constant time value)
            </summary>
        </member>
        <member name="P:Abodit.Units.Time.IsMidnight">
            <summary>
            Returns true if this time represents midnight
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.Time"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.Time"/> class
            </summary>
        </member>
        <member name="P:Abodit.Units.Time.TimeSpanMidnightAsStart">
            <summary>
            Convert to a TimeSpan value assuming midnight is the start
            </summary>
        </member>
        <member name="P:Abodit.Units.Time.TimeSpanMidnightAsEnd">
            <summary>
            Convert to a TimeSpan value assuming midnight is the end
            </summary>
        </member>
        <member name="P:Abodit.Units.Time.Ticks">
            <summary>
            Get the number of ticks this Time represents in the day assuming midnight is the start
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.#ctor(System.String)">
            <summary>
            A time like 9:30 in 24 hour notation using a string representation
            optional with seconds: 00:00:00
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.#ctor(System.TimeSpan)">
            <summary>
            Create a Time from a TimeSpan
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.Equals(System.Object)">
            <summary>
            Times are equal if hours, minutes and seconds are the same
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.GetHashCode">
            <summary>
            Get a hashcode
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.ToString">
            <summary>
            Get a string representation
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.ToShortest">
            <summary>
            Get a short english representation of this time
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.op_Addition(Abodit.Units.Time,Abodit.Units.Time)">
            <summary>
            Slightly meaningless to add two times but sometimes we use time from midnight
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.op_Addition(Abodit.Units.Time,Abodit.Units.TimePeriod)">
            <summary>
            Add a TimePeriod to a Time
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.op_Subtraction(Abodit.Units.Time,Abodit.Units.TimePeriod)">
            <summary>
            Subtract a TimePeriod from a Time
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.op_Subtraction(Abodit.Units.Time,Abodit.Units.Time)">
            <summary>
            Difference between two times, assumes they are in order (one then two)
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.SubtractHours(System.Int32)">
            <summary>
            Subtract a number of hours
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.AddHours(System.Int32)">
            <summary>
            Add a number of hours
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.SubtractMinutes(System.Int32)">
            <summary>
            Subtract a number of minutes
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.AddMinutes(System.Int32)">
            <summary>
            Add a number of minutes
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.SubtractSeconds(System.Int32)">
            <summary>
            Subtract a number of seconds
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.AddSeconds(System.Int32)">
            <summary>
            Add a number of seconds
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.Normalize(System.Double,System.Double,System.Double)">
            <summary>
            Create a new time from hours and minutes, either of which may be negative or over range
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.ForceMorning">
            <summary>
            Create a new Time with this hour in the morning
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.ForceAfternoon">
            <summary>
            Create a new Time with this hour in the afternoon
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.Equals(Abodit.Units.Time)">
            <summary>
            Compare two times
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.CompareTo(Abodit.Units.Time)">
            <summary>
            Compare two times
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.op_GreaterThan(Abodit.Units.Time,Abodit.Units.Time)">
            <summary>
            Compare two times
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.op_LessThan(Abodit.Units.Time,Abodit.Units.Time)">
            <summary>
            Compare two times
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.op_LessThanOrEqual(Abodit.Units.Time,Abodit.Units.Time)">
            <summary>
            Compare two times
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.op_Equality(Abodit.Units.Time,Abodit.Units.Time)">
            <summary>
            Compare two times
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.op_Inequality(Abodit.Units.Time,Abodit.Units.Time)">
            <summary>
            Compare two times
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.op_GreaterThanOrEqual(Abodit.Units.Time,Abodit.Units.Time)">
            <summary>
            Compare two times
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.Extend(System.Int32,System.Int32)">
            <summary>
            Create a range starting from this time
            </summary>
        </member>
        <member name="P:Abodit.Units.Time.IsLateAtNight">
            <summary>
            23:00 to 3:00
            </summary>
        </member>
        <member name="P:Abodit.Units.Time.IsEarlyMorning">
            <summary>
            03:00 to 07:00
            </summary>
        </member>
        <member name="P:Abodit.Units.Time.IsQuietTime">
            <summary>
            19:00 to 09:00
            </summary>
        </member>
        <member name="P:Abodit.Units.Time.IsMorning">
            <summary>
            06:00 to 12:00
            </summary>
        </member>
        <member name="P:Abodit.Units.Time.IsAfternoon">
            <summary>
            12:00 to 18L00
            </summary>
        </member>
        <member name="P:Abodit.Units.Time.IsEarlyEvening">
            <summary>
            17:00 to 20:00
            </summary>
        </member>
        <member name="P:Abodit.Units.Time.IsEvening">
            <summary>
            17:00 to 23:00
            </summary>
        </member>
        <member name="P:Abodit.Units.Time.IsNight">
            <summary>
            22:00 to 06:00
            </summary>
        </member>
        <member name="P:Abodit.Units.Time.IsEveningTo2AM">
            <summary>
            17:00 to 03:00
            </summary>
        </member>
        <member name="P:Abodit.Units.Time.Is6PMTo6AM">
            <summary>
            17:00 to 06:00
            </summary>
        </member>
        <member name="P:Abodit.Units.Time.IsBedtime">
            <summary>
            21:00 to 03:00
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.GetTypeCode">
            <summary>
            Get a TypeCode for this IConvertible object
            </summary>
            <returns></returns>
        </member>
        <member name="M:Abodit.Units.Time.ToBoolean(System.IFormatProvider)">
            <summary>
            Convert this IConvertible object
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.ToChar(System.IFormatProvider)">
            <summary>
            Convert this IConvertible object
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.ToSByte(System.IFormatProvider)">
            <summary>
            Convert this IConvertible object
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.ToByte(System.IFormatProvider)">
            <summary>
            Convert this IConvertible object
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.ToInt16(System.IFormatProvider)">
            <summary>
            Convert this IConvertible object
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.ToUInt16(System.IFormatProvider)">
            <summary>
            Convert this IConvertible object
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.ToInt32(System.IFormatProvider)">
            <summary>
            Convert this IConvertible object
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.ToUInt32(System.IFormatProvider)">
            <summary>
            Convert this IConvertible object
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.ToInt64(System.IFormatProvider)">
            <summary>
            Convert this IConvertible object
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.ToUInt64(System.IFormatProvider)">
            <summary>
            Convert this IConvertible object
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.ToSingle(System.IFormatProvider)">
            <summary>
            Convert this IConvertible object
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.ToDouble(System.IFormatProvider)">
            <summary>
            Convert this IConvertible object
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.ToDecimal(System.IFormatProvider)">
            <summary>
            Convert this IConvertible object
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.ToDateTime(System.IFormatProvider)">
            <summary>
            Convert this IConvertible object
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.ToString(System.IFormatProvider)">
            <summary>
            Convert this IConvertible object
            </summary>
        </member>
        <member name="M:Abodit.Units.Time.ToType(System.Type,System.IFormatProvider)">
            <summary>
            Convert this IConvertible object
            </summary>
        </member>
        <member name="T:Abodit.Units.TimeRange">
            <summary>
            A time range is an interval of time between two times of day
            </summary>
            <remarks>
            The interval of time must be less than 24 hours but it can wrap over midnight, e.g. 10pm to 2am
            </remarks>
        </member>
        <member name="P:Abodit.Units.TimeRange.Time1">
            <summary>
            Get the start time
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeRange.Time2">
            <summary>
            Get the end time (may be before the start time if over midnight)
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeRange.IsAllDay">
            <summary>
            Does this represent all day (even though Time1 == Time2)?
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeRange.IsPointInTime">
            <summary>
            Is this a point in time?
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeRange.CrossesMidnight">
            <summary>
            Crosses midnight, e.g. 11PM to 5AM, but not 11PM to midnight and not midnight to 5AM
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeRange.#ctor(Abodit.Units.Time,Abodit.Units.Time)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Units.TimeRange"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeRange.ToString">
            <summary>
            Gets a string representation of this object
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeRange.Describe">
            <summary>
            Gets an english representation of this object
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeRange.Contains(Abodit.Units.Time)">
            <summary>
            Does this time range contain a given time?
            </summary>
            <remarks>
            This includes allowances for TimeRanges that wrap over midnight
            </remarks>
        </member>
        <member name="M:Abodit.Units.TimeRange.Contains(System.TimeSpan)">
            <summary>
            Does this time range contain a given time expressed as a TimeSpan?
            </summary>
            <remarks>
            This includes allowances for TimeRanges that wrap over midnight
            </remarks>
        </member>
        <member name="M:Abodit.Units.TimeRange.Expand(System.Int32)">
            <summary>
            Grow a time range by n hours in each direction
            </summary>
            <param name="hours"></param>
            <returns></returns>
        </member>
        <member name="P:Abodit.Units.TimeRange.TimePeriod">
            <summary>
            The duration of this time range
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeRange.TimeSpan">
            <summary>
            Gets the duration of this TimeRange as a TimeSpan
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeRange.Intersect(Abodit.Units.TimeRange)">
            <summary>
            Intersect time ranges (may produce none, one or two)
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeRange.Overlaps(Abodit.Units.TimeRange)">
            <summary>
            Does this TimeRange overlap another?
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeRange.Touches(Abodit.Units.TimeRange)">
            <summary>
            Does this TimeRange touch another without overlap?
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeRange.Bits">
            <summary>
            Get TimeRanges that don't cross midnight
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeRange.Union(Abodit.Units.TimeRange)">
            <summary>
            Union one time range with another
            </summary>
        </member>
        <member name="F:Abodit.Units.TimeRange.Empty">
            <summary>
            The Empty TimeRange
            </summary>
        </member>
        <member name="F:Abodit.Units.TimeRange.Morning">
            <summary>
            A Timerange representing morning
            </summary>
        </member>
        <member name="F:Abodit.Units.TimeRange.Afternoon">
            <summary>
            A TimeRange representing afternoon
            </summary>
        </member>
        <member name="F:Abodit.Units.TimeRange.Evening">
            <summary>
            A TimeRange representing evening (18:00-23:00)
            </summary>
        </member>
        <member name="F:Abodit.Units.TimeRange.Night">
            <summary>
            A TimeRange representing night (20:00-07:00)
            </summary>
        </member>
        <member name="F:Abodit.Units.TimeRange.AllDay">
            <summary>
            All day
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeRange.Point(Abodit.Units.Time)">
            <summary>
            A point in time
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeRange.Create(Abodit.Units.Time,Abodit.Units.Time)">
            <summary>
            Create a time range with canonicalization to Morning, Afternoon, Evening, Night, ...
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeRange.Equals(Abodit.Units.TimeRange)">
            <summary>
            Does this TimeRange equal another?
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeRange.Equals(System.Object)">
            <summary>
            Times are equal if hours, minutes and seconds are the same
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeRange.GetHashCode">
            <summary>
            GetHashCode
            </summary>
            <returns></returns>
        </member>
        <member name="T:Abodit.Units.TimeRange.TimeRangeMorning">
            <summary>
            A special TimeRange for morning
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeRange.TimeRangeMorning.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeRange.TimeRangeMorning.Describe">
            <summary>
            Describe
            </summary>
        </member>
        <member name="T:Abodit.Units.TimeRange.TimeRangeAfternoon">
            <summary>
            A special TimeRange for afternoon
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeRange.TimeRangeAfternoon.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeRange.TimeRangeAfternoon.Describe">
            <summary>
            Describe
            </summary>
        </member>
        <member name="T:Abodit.Units.TimeRange.TimeRangeEvening">
            <summary>
            A special TimeRange for evening
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeRange.TimeRangeEvening.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeRange.TimeRangeEvening.Describe">
            <summary>
            Describe
            </summary>
        </member>
        <member name="T:Abodit.Units.TimeRange.TimeRangeNight">
            <summary>
            A special TimeRange for night
            </summary>
        </member>
        <member name="T:Abodit.Units.TimeRange.TimeRangeAllDay">
            <summary>
            A special TimeRange for all day
            </summary>
        </member>
        <member name="T:Abodit.Units.TimeRange.TimeRangePointInTime">
            <summary>
            A point in time with no duration
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeRange.TimeRangePointInTime.#ctor(Abodit.Units.Time)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.TimeRange.TimeRangePointInTime"/> class
            </summary>
            <param name="start"></param>
        </member>
        <member name="M:Abodit.Units.TimeRange.TimeRangePointInTime.ToString">
            <summary>
            Returns a string representation of this object
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeRange.TimeRangePointInTime.Describe">
            <summary>
            Returns an english representation of this object
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeRange.TimeRangePointInTime.TimePeriod">
            <summary>
            Returns the TimePeriod occupied by this TimeRange
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeRange.TimeRangePointInTime.TimeSpan">
            <summary>
            Returns the TimeSpan occupied by this TimeRange
            </summary>
        </member>
        <member name="T:Abodit.Units.TokenExpressionUnitConversion">
            <summary>
            Unit conversion wraps an inner expression and handles converting it
            to a given unit, e.g. Centimeters(5 + 4)
            
            The inner expression SHOULD be dimensionless, e.g. TokenDouble
            </summary>
        </member>
        <member name="P:Abodit.Units.TokenExpressionUnitConversion.Dimension">
            <summary>
            Get the dimension for this expression if known
            </summary>
        </member>
        <member name="M:Abodit.Units.TokenExpressionUnitConversion.#ctor(Abodit.Expressions.TokenExpression,Abodit.Units.IUnit)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TokenExpressionUnitConversion"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.TokenExpressionUnitConversion.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.TokenExpressionUnitConversion.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="T:Abodit.Units.Expressions.Visitor.GetUnboundVariablesVisitor">
            <summary>
            A visitor for getting all the unbound variables in a TokenExpression
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.GetUnboundVariablesVisitor.DoVisit(Abodit.Expressions.TokenExpressionVariableAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.GetUnboundVariablesVisitor.DoVisit(Abodit.Expressions.TokenExpressionFieldAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.GetUnboundVariablesVisitor.DoVisit(Abodit.Expressions.TokenExpressionFunctionCall)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="T:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1">
            <summary>
            A visitor for visiting just the bits that might be variable in an expression (no matter how deep)
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.Visit(Abodit.Expressions.TokenExpression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.Visit(Abodit.Temporal.TemporalSet)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.VisitTemporal(Abodit.Temporal.TemporalSet)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionIdentity)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionPropertyAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionVariableAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionFieldAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionFunctionCall)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionUnits)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Units.TimePeriod)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantNull)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantDateTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantString)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantColor)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionArray)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstant)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantBool)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenDouble)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConvertToLocalDateTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Units.TokenExpressionUnitConversion)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAdd)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionMatches)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionDivide)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionUnaryMinus)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionMultiply)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionPower)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionSubtract)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionNot)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAnd)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionOr)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionRange)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionTernary)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionIntersection)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionUnion)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionEquals)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionGreater)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionGreaterOrEqual)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionLess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionLessOrEqual)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionNotEquals)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionTuple)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteSingleInterval)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetUnknown)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetEvery)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteRepeatYearly)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteMonthYearList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteQuarterSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheNth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekend)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekday)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteAlways)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteQuantityOf)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetNever)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetIntersectionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetIntersectionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetUnionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteAnyPeriod)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteMonthList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteShift)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteMonthSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheLast)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetHalfInfiniteAfter)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfWeekList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteHalfSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheXAfterY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfWeek)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfMonth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayInMonth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheXAfterY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteYear)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteYearList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheXBeforeY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteWellKnown)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteShift)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheLast)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheNth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetHalfInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetUnionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteAfter)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionSum)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionCount)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAverage)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAny)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAll)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionDataSource)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionWhere)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Units.Expressions.Visitor.VariableBitsVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionSelect)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="T:Abodit.Units.IntervalInYear">
            <summary>
            An infinite, repeating interval once per year, could be a day, a week, a month, a quarter or the whole year.
            </summary>
        </member>
        <member name="F:Abodit.Units.IntervalInYear.Null">
            <summary>
            An empty interval
            </summary>
        </member>
        <member name="F:Abodit.Units.IntervalInYear.All">
            <summary>
            The entire year
            </summary>
        </member>
        <member name="F:Abodit.Units.IntervalInYear.Jan">
            <summary>
            A month
            </summary>
        </member>
        <member name="F:Abodit.Units.IntervalInYear.Feb">
            <summary>
            A month
            </summary>
        </member>
        <member name="F:Abodit.Units.IntervalInYear.Mar">
            <summary>
            A month
            </summary>
        </member>
        <member name="F:Abodit.Units.IntervalInYear.Apr">
            <summary>
            A month
            </summary>
        </member>
        <member name="F:Abodit.Units.IntervalInYear.May">
            <summary>
            A month
            </summary>
        </member>
        <member name="F:Abodit.Units.IntervalInYear.Jun">
            <summary>
            A month
            </summary>
        </member>
        <member name="F:Abodit.Units.IntervalInYear.Jul">
            <summary>
            A month
            </summary>
        </member>
        <member name="F:Abodit.Units.IntervalInYear.Aug">
            <summary>
            A month
            </summary>
        </member>
        <member name="F:Abodit.Units.IntervalInYear.Sep">
            <summary>
            A month
            </summary>
        </member>
        <member name="F:Abodit.Units.IntervalInYear.Oct">
            <summary>
            A month
            </summary>
        </member>
        <member name="F:Abodit.Units.IntervalInYear.Nov">
            <summary>
            A month
            </summary>
        </member>
        <member name="F:Abodit.Units.IntervalInYear.Dec">
            <summary>
            A month
            </summary>
        </member>
        <member name="F:Abodit.Units.IntervalInYear.Q1">
            <summary>
            A quarter
            </summary>
        </member>
        <member name="F:Abodit.Units.IntervalInYear.Q2">
            <summary>
            A quarter
            </summary>
        </member>
        <member name="F:Abodit.Units.IntervalInYear.Q3">
            <summary>
            A quarter
            </summary>
        </member>
        <member name="F:Abodit.Units.IntervalInYear.Q4">
            <summary>
            A quarter
            </summary>
        </member>
        <member name="F:Abodit.Units.IntervalInYear.H1">
            <summary>
            A half
            </summary>
        </member>
        <member name="F:Abodit.Units.IntervalInYear.H2">
            <summary>
            A half
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYear.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.IntervalInYear"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYear.Range(System.Int32)">
            <summary>
            Gets the <see cref="T:Abodit.Units.CalendarDateTimeRange"/> for a given year
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYear.Intersect(Abodit.Units.IntervalInYear)">
            <summary>
            Intersects two intervals in a year
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYear.Union(Abodit.Units.IntervalInYear)">
            <summary>
            Unions two intervals in a year
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYear.ToString">
            <summary>
            Returns a string for this object
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYear.Describe(System.Boolean)">
            <summary>
            Returns an English description
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYear.Simplify">
            <summary>
            Simplify an interval in year
            </summary>
        </member>
        <member name="T:Abodit.Units.IntervalInYearAll">
            <summary>
            An <see cref="T:Abodit.Units.IntervalInYear"/> covering the whole year
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearAll.Range(System.Int32)">
            <summary>
            Gets a <see cref="T:Abodit.Units.CalendarDateTimeRange"/> for a given year
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearAll.Describe(System.Boolean)">
            <summary>
            Describe this <see cref="T:Abodit.Units.IntervalInYear"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.IntervalInYearDayMonth">
            <summary>
            An interval in a year representing a single day in a single month
            </summary>
        </member>
        <member name="P:Abodit.Units.IntervalInYearDayMonth.Day">
            <summary>
            The day of the month
            </summary>
        </member>
        <member name="P:Abodit.Units.IntervalInYearDayMonth.Month">
            <summary>
            The month
            </summary>
        </member>
        <member name="P:Abodit.Units.IntervalInYearDayMonth.InQuarter">
            <summary>
            The Quarter this Day is in
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearDayMonth.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Units.IntervalInYearDayMonth"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearDayMonth.Range(System.Int32)">
            <summary>
            Gets a <see cref="T:Abodit.Units.CalendarDateTimeRange"/> for a given year
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearDayMonth.Describe(System.Boolean)">
            <summary>
            Returns an english description
            </summary>
        </member>
        <member name="T:Abodit.Units.IntervalInYearHalf">
            <summary>
            An interval in a year representing a half year (H1 or H2)
            </summary>
        </member>
        <member name="P:Abodit.Units.IntervalInYearHalf.HalfNumber">
            <summary>
            Which half of the year (1 or 2)
            </summary>
        </member>
        <member name="P:Abodit.Units.IntervalInYearHalf.FirstMonth">
            <summary>
            The first month of this half year
            </summary>
        </member>
        <member name="P:Abodit.Units.IntervalInYearHalf.Quarters">
            <summary>
            The quarters in this half year
            </summary>
        </member>
        <member name="P:Abodit.Units.IntervalInYearHalf.Months">
            <summary>
            The months in this half year
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearHalf.#ctor(System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.IntervalInYearHalf"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearHalf.Range(System.Int32)">
            <summary>
            Gets a <see cref="T:Abodit.Units.CalendarDateTimeRange"/> for a given year
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearHalf.Describe(System.Boolean)">
            <summary>
            Returns an English description of this object
            </summary>
        </member>
        <member name="T:Abodit.Units.IntervalInYearIntersection">
            <summary>
            An intersection between two intervals in a year
            </summary>
        </member>
        <member name="P:Abodit.Units.IntervalInYearIntersection.Left">
            <summary>
            The left interval
            </summary>
        </member>
        <member name="P:Abodit.Units.IntervalInYearIntersection.Right">
            <summary>
            The right interval
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearIntersection.#ctor(Abodit.Units.IntervalInYear,Abodit.Units.IntervalInYear)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.IntervalInYearIntersection"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearIntersection.Range(System.Int32)">
            <summary>
            Gets a <see cref="T:Abodit.Units.CalendarDateTimeRange"/> for a given year
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearIntersection.Describe(System.Boolean)">
            <summary>
            Returns an English description
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearIntersection.Simplify">
            <summary>
            Simplifies the intersection
            </summary>
            <returns></returns>
        </member>
        <member name="T:Abodit.Units.IntervalInYearMonth">
            <summary>
            An month interval in a year
            </summary>
        </member>
        <member name="P:Abodit.Units.IntervalInYearMonth.MonthNumber">
            <summary>
            The month number
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearMonth.#ctor(System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.IntervalInYearMonth"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearMonth.Range(System.Int32)">
            <summary>
            Gets a <see cref="T:Abodit.Units.CalendarDateTimeRange"/> for a given year
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearMonth.Describe(System.Boolean)">
            <summary>
            Gets an English description
            </summary>
        </member>
        <member name="T:Abodit.Units.IntervalInYearMonthList">
            <summary>
            Represents a list of months in a year
            </summary>
        </member>
        <member name="P:Abodit.Units.IntervalInYearMonthList.Months">
            <summary>
            The months represented
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearMonthList.#ctor(System.Int32[])">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Units.IntervalInYearMonthList"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearMonthList.Range(System.Int32)">
            <summary>
            Gets a <see cref="T:Abodit.Units.CalendarDateTimeRange"/> for a given year
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearMonthList.Describe(System.Boolean)">
            <summary>
            Gets an English description
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearMonthList.Create(System.Collections.Generic.IEnumerable{System.Int32},System.Int32)">
            <summary>
            Create a month list (or simpler IntervalInYear) from a list of months and an additional month
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearMonthList.Create(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Create a month list (or simpler IntervalInYear) from a list of months
            </summary>
        </member>
        <member name="T:Abodit.Units.IntervalInYearNull">
            <summary>
            An empty interval in a year
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearNull.Range(System.Int32)">
            <summary>
            Gets a <see cref="T:Abodit.Units.CalendarDateTimeRange"/> for a given year
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearNull.Describe(System.Boolean)">
            <summary>
            Gets an English description
            </summary>
        </member>
        <member name="T:Abodit.Units.IntervalInYearQuarter">
            <summary>
            An interval in a year representing a quarter
            </summary>
        </member>
        <member name="P:Abodit.Units.IntervalInYearQuarter.QuarterNumber">
            <summary>
            The quarter number
            </summary>
        </member>
        <member name="P:Abodit.Units.IntervalInYearQuarter.FirstMonth">
            <summary>
            Get the first month of the quarter
            </summary>
        </member>
        <member name="P:Abodit.Units.IntervalInYearQuarter.Months">
            <summary>
            Get the months in the quarter
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearQuarter.#ctor(System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.IntervalInYearQuarter"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearQuarter.Range(System.Int32)">
            <summary>
            Gets a <see cref="T:Abodit.Units.CalendarDateTimeRange"/> for a given year
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearQuarter.Describe(System.Boolean)">
            <summary>
            Gets an English description
            </summary>
        </member>
        <member name="T:Abodit.Units.IntervalInYearSimplifier`2">
            <summary>
            Simplifes the intersection or union of two IntervalInYear objects
            </summary>
        </member>
        <member name="T:Abodit.Units.IntervalInYearUnion">
            <summary>
            The union of two intervals in a year (unsimplified)
            </summary>
        </member>
        <member name="P:Abodit.Units.IntervalInYearUnion.Left">
            <summary>
            The left interval
            </summary>
        </member>
        <member name="P:Abodit.Units.IntervalInYearUnion.Right">
            <summary>
            The right interval
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearUnion.#ctor(Abodit.Units.IntervalInYear,Abodit.Units.IntervalInYear)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.IntervalInYearUnion"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearUnion.Range(System.Int32)">
            <summary>
            Gets a <see cref="T:Abodit.Units.CalendarDateTimeRange"/> for a given year
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearUnion.Describe(System.Boolean)">
            <summary>
            Gets an English description
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearUnion.Simplify">
            <summary>
            Simplify the interval if possible
            </summary>
        </member>
        <member name="T:Abodit.Units.IntervalInYearWeek">
            <summary>
            A specific week with a year
            </summary>
        </member>
        <member name="P:Abodit.Units.IntervalInYearWeek.WeekNumber">
            <summary>
            The week number
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearWeek.#ctor(System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.IntervalInYearWeek"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearWeek.Range(System.Int32)">
            <summary>
            Gets a <see cref="T:Abodit.Units.CalendarDateTimeRange"/> for a given year
            </summary>
        </member>
        <member name="M:Abodit.Units.IntervalInYearWeek.Describe(System.Boolean)">
            <summary>
            Gets an English description
            </summary>
        </member>
        <member name="T:Abodit.Units.Interpolation">
            <summary>
            Extension methods for interpolation on a TimedValue collection
            </summary>
        </member>
        <member name="M:Abodit.Units.Interpolation.SpLine(System.Collections.Generic.IList{Abodit.Units.TimedValue{System.Double}},System.DateTimeOffset)">
            <summary>
            Interpolate the value at time z
            </summary>
        </member>
        <member name="M:Abodit.Units.Interpolation.SpLine(System.Collections.Generic.IList{System.Collections.Generic.KeyValuePair{System.Double,System.Double}},System.Double)">
            <summary>
            Interpolate the value at position z using a spline
            </summary>
        </member>
        <member name="M:Abodit.Units.Interpolation.solveTridiag(System.Double[],System.Double[],System.Double[],System.Double[]@,System.Int32)">
            <summary>
            http://www.codeproject.com/KB/cs/SplineInterpolation.aspx
            </summary>
        </member>
        <member name="T:Abodit.Units.TimeddoubleCollection">
            <summary>
            A collection of timed range values kept in order with some additional logic around it
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeddoubleCollection.HasFutureValues">
            <summary>
            Has future values affects how interpolation happens
            </summary>
        </member>
        <member name="F:Abodit.Units.TimeddoubleCollection.maxHistory">
            <summary>
            How much history to keep
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeddoubleCollection.Earliest">
            <summary>
            Get the earliest value
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeddoubleCollection.Latest">
            <summary>
            get the latest value
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeddoubleCollection.Range">
            <summary>
            Gets the range covered by this collection as a TimeSpan
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeddoubleCollection.#ctor">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TimeddoubleCollection"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeddoubleCollection.#ctor(System.Int32)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TimeddoubleCollection"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeddoubleCollection.#ctor(System.Collections.Generic.IEnumerable{Abodit.Units.TimedValue{System.Double}},System.Int32)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TimeddoubleCollection"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeddoubleCollection.#ctor(System.String,System.Int32,System.Boolean)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TimeddoubleCollection"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeddoubleCollection.Add(System.DateTimeOffset,System.Double)">
            <summary>
            Add a value at a specific time, either historical data, or future data.  Replaces a value already there if any
            </summary>
        </member>
        <member name="P:Abodit.Units.TimeddoubleCollection.Current">
            <summary>
            Get the most recent item in the history, same value as current
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeddoubleCollection.Prune">
            <summary>
            Prune the list to keep it the right length
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeddoubleCollection.ValueAtTimeWithLinearInterpolation(System.DateTimeOffset)">
            <summary>
            ValueAtTime t with interpolation
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeddoubleCollection.ValuesCoveringRange(System.DateTimeOffset,System.DateTimeOffset)">
            <summary>
            Get the segments in the range, empty list if none, uses interpolation at start and end
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeddoubleCollection.Average(System.DateTimeOffset,System.DateTimeOffset)">
            <summary>
            Get the average within the range specified, returns double.NaN if out of range
            </summary>
            <remarks>
            We really need to understand the underlying value better - is it a stepped one or a linear or a smooth one?
            That would lead to three different average values.  This one assumes we have lots of values in the range
            </remarks>
        </member>
        <member name="M:Abodit.Units.TimeddoubleCollection.Average">
            <summary>
            Average for entire range
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeddoubleCollection.Shift(System.Int32)">
            <summary>
            Rebase a collection by a certain distance
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeddoubleCollection.CompareWithAfterRebasing(Abodit.Units.TimeddoubleCollection)">
            <summary>
            Compare after shifting this to align with other
            </summary>
        </member>
        <member name="M:Abodit.Units.TimeddoubleCollection.CompareWith(Abodit.Units.TimeddoubleCollection)">
            <summary>
            How does this value collection compare with the other
            </summary>
            <remarks>
            Other must lie within this to get a good comparison back
            </remarks>
        </member>
        <member name="M:Abodit.Units.TimeddoubleCollection.SplitBasedOnSplitPoints``1(System.String,``0[])">
            <summary>
            Segment into values within certain ranges, e.g. 0.1-0.2, 0.2-0.4, 0.4-22.0
            </summary>
        </member>
        <member name="T:Abodit.Units.ComparisonResult">
            <summary>
            The result of a comparison
            </summary>
        </member>
        <member name="T:Abodit.Units.ComparisonResultNotMeaningful">
            <summary>
            A non-meaningful comparison
            </summary>
        </member>
        <member name="T:Abodit.Units.ComparisonResultMeaningful">
            <summary>
            A meaningful comparison
            </summary>
        </member>
        <member name="P:Abodit.Units.ComparisonResultMeaningful.Shift">
            <summary>
            How far up to shift to get sane average
            </summary>
        </member>
        <member name="P:Abodit.Units.ComparisonResultMeaningful.Deviation">
            <summary>
            How close is this to the other curve
            </summary>
        </member>
        <member name="T:Abodit.Units.TimedRangeValue`1">
            <summary>
            A time range with a value of time T
            </summary>
        </member>
        <member name="M:Abodit.Units.TimedRangeValue`1.#ctor(System.DateTimeOffset,System.DateTimeOffset,`0)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.TimedRangeValue`1"/> class
            </summary>
        </member>
        <member name="P:Abodit.Units.TimedRangeValue`1.Start">
            <summary>
            The start of the range
            </summary>
        </member>
        <member name="P:Abodit.Units.TimedRangeValue`1.End">
            <summary>
            The end of the range
            </summary>
        </member>
        <member name="P:Abodit.Units.TimedRangeValue`1.Value">
            <summary>
            The value over this range
            </summary>
        </member>
        <member name="P:Abodit.Units.TimedRangeValue`1.TotalSeconds">
            <summary>
            The total number of seconds in the range of time
            </summary>
        </member>
        <member name="P:Abodit.Units.TimedRangeValue`1.TotalMinutes">
            <summary>
            The total number of minutes in the range of time
            </summary>
        </member>
        <member name="P:Abodit.Units.TimedRangeValue`1.TotalHours">
            <summary>
            The total number of hours in the range of time
            </summary>
        </member>
        <member name="M:Abodit.Units.TimedRangeValue`1.Overlaps(Abodit.Units.TimedRangeValue{`0})">
            <summary>
            Is there an overlap?
            </summary>
        </member>
        <member name="M:Abodit.Units.TimedRangeValue`1.Overlap(Abodit.Units.TimedRangeValue{`0})">
            <summary>
            How big is the overlap?
            </summary>
        </member>
        <member name="M:Abodit.Units.TimedRangeValue`1.ToString">
            <summary>
            Returns a string representation of this object
            </summary>
        </member>
        <member name="T:Abodit.Units.TimedRangeValueExtensions">
            <summary>
            Extensions for dealing with <see cref="T:Abodit.Units.TimedRangeValue`1"/> objects
            </summary>
        </member>
        <member name="M:Abodit.Units.TimedRangeValueExtensions.MergeMatchingSegments``1(System.Collections.Generic.IEnumerable{Abodit.Units.TimedRangeValue{``0}})">
            <summary>
            Merge any two adjacent segments that have the SAME value
            </summary>
            <remarks>
            TODO: Move this to a more general class!
            </remarks>
        </member>
        <member name="T:Abodit.Units.TimedRangeValueCollection`1">
            <summary>
            A contiguous set of segments each having discrete values of T.
            </summary>
            <remarks>
            Attempts to add the same value next to each other get merged.
            Not thread safe.
            </remarks>
        </member>
        <member name="M:Abodit.Units.TimedRangeValueCollection`1.Add(Abodit.Units.TimedRangeValue{`0})">
            <summary>
            Add a <see cref="T:Abodit.Units.TimedRangeValue`1"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.TimedRangeValueRange">
            <summary>
            A range of times having an index and a description, e.g. #2 "good"
            </summary>
        </member>
        <member name="P:Abodit.Units.TimedRangeValueRange.Index">
            <summary>
            Gets the index part of the Tuple
            </summary>
        </member>
        <member name="P:Abodit.Units.TimedRangeValueRange.Description">
            <summary>
            Gets the description part of the Tuple
            </summary>
        </member>
        <member name="M:Abodit.Units.TimedRangeValueRange.#ctor(System.DateTime,System.DateTime,System.Int32,System.String)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TimedRangeValueRange"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.TimedValue`1">
            <summary>
            A TimedValue is simply a pair of a time plus a Serializable value
            </summary>
        </member>
        <member name="F:Abodit.Units.TimedValue`1.DateTime">
            <summary>
            Get the DateTimeOffset at which this value occurred
            </summary>
        </member>
        <member name="P:Abodit.Units.TimedValue`1.Value">
            <summary>
            Get the value itself
            </summary>
        </member>
        <member name="M:Abodit.Units.TimedValue`1.#ctor(System.DateTimeOffset,`0)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.TimedValue`1"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.TimedValue`1.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Units.TimedValue`1.CompareTo(Abodit.Units.TimedValue{`0})">
            <summary>
            Compares two TimedValues by date time order
            </summary>
        </member>
        <member name="T:Abodit.Units.TimedValueList`1">
            <summary>
            A list of TimedValues of type T maintained in sorted order
            </summary>
        </member>
        <member name="M:Abodit.Units.TimedValueList`1.Add(Abodit.Units.TimedValue{`0})">
            <summary>
            Add a <see cref="T:Abodit.Units.TimedValue`1"/> to the list
            </summary>
        </member>
        <member name="P:Abodit.Units.TimedValueList`1.Count">
            <summary>
            Gets the count of values in the list
            </summary>
        </member>
        <member name="P:Abodit.Units.TimedValueList`1.Item(System.Int32)">
            <summary>
            Gets the value at position index
            </summary>
        </member>
        <member name="M:Abodit.Units.TimedValueList`1.RemoveAt(System.Int32)">
            <summary>
            Removes the item at a given position
            </summary>
        </member>
        <member name="T:Abodit.Units.Amperage">
            <summary>
            An amperage (1 amp, ...)
            </summary>
        </member>
        <member name="M:Abodit.Units.Amperage.#ctor">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Amperage"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Amperage.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates an instance of a Amperage based on a number of amps
            </summary>
        </member>
        <member name="M:Abodit.Units.Amperage.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Amperage"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Amperage.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="F:Abodit.Units.Amperage.OneAmp">
            <summary>
            A unit of one Amp
            </summary>
        </member>
        <member name="T:Abodit.Units.Angle">
            <summary>
            An angle value
            </summary>
        </member>
        <member name="P:Abodit.Units.Angle.Radians">
            <summary>
            Angle in radians
            </summary>
        </member>
        <member name="P:Abodit.Units.Angle.Degrees">
            <summary>
            Angle in degrees
            </summary>
        </member>
        <member name="M:Abodit.Units.Angle.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates an instance of an Angle
            </summary>
        </member>
        <member name="M:Abodit.Units.Angle.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Create an <see cref="T:Abodit.Units.Angle"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Angle.CreateRadians(System.Double)">
            <summary>
            Create an <see cref="T:Abodit.Units.Angle"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Angle.CreateDegrees(System.Double)">
            <summary>
            Create an <see cref="T:Abodit.Units.Angle"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Angle.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Units.Angle.InMetric">
            <summary>
            In radians
            </summary>
        </member>
        <member name="M:Abodit.Units.Angle.InImperial">
            <summary>
            In imperial degrees
            </summary>
        </member>
        <member name="F:Abodit.Units.Angle.OneRadian">
            <summary>
            A unit of one radian
            </summary>
        </member>
        <member name="F:Abodit.Units.Angle.OneDegree">
            <summary>
            A unit of oned degree
            </summary>
        </member>
        <member name="T:Abodit.Units.Area">
            <summary>
            An area value
            </summary>
        </member>
        <member name="P:Abodit.Units.Area.SquareMeters">
            <summary>
            Area in Square meters
            </summary>
        </member>
        <member name="P:Abodit.Units.Area.SquareKm">
            <summary>
            Area in Square kilometers
            </summary>
        </member>
        <member name="P:Abodit.Units.Area.Hectares">
            <summary>
            Area in Hectares
            </summary>
        </member>
        <member name="P:Abodit.Units.Area.SquareCentimeters">
            <summary>
            Area in square centimeters
            </summary>
        </member>
        <member name="P:Abodit.Units.Area.SquareMillimeters">
            <summary>
            Area in square millimeters
            </summary>
        </member>
        <member name="P:Abodit.Units.Area.SquareMicrons">
            <summary>
            Area in square microns
            </summary>
        </member>
        <member name="P:Abodit.Units.Area.SquareMiles">
            <summary>
            Area in square miles
            </summary>
        </member>
        <member name="P:Abodit.Units.Area.Acres">
            <summary>
            Area in acres
            </summary>
        </member>
        <member name="P:Abodit.Units.Area.SquareYards">
            <summary>
            Area in square yards
            </summary>
        </member>
        <member name="P:Abodit.Units.Area.SquareFeet">
            <summary>
            Area in square feet
            </summary>
        </member>
        <member name="P:Abodit.Units.Area.SquareInches">
            <summary>
            Area in square inches
            </summary>
        </member>
        <member name="P:Abodit.Units.Area.SquareThous">
            <summary>
            Area in square thou
            </summary>
        </member>
        <member name="M:Abodit.Units.Area.#ctor">
            <summary>
            Create a new area
            </summary>
        </member>
        <member name="M:Abodit.Units.Area.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates an instance of Area based on a multiplier and a unit of Area
            </summary>
        </member>
        <member name="M:Abodit.Units.Area.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Create a new area
            </summary>
        </member>
        <member name="F:Abodit.Units.Area.OneMeterSquared">
            <summary>
            One square meter
            </summary>
        </member>
        <member name="F:Abodit.Units.Area.OneKilometerSquared">
            <summary>
            One square kilometer
            </summary>
        </member>
        <member name="F:Abodit.Units.Area.OneCentimeterSquared">
            <summary>
            One square centimeter
            </summary>
        </member>
        <member name="F:Abodit.Units.Area.OneMillimeterSquared">
            <summary>
            One square millimeter
            </summary>
        </member>
        <member name="F:Abodit.Units.Area.OneMicronSquared">
            <summary>
            One square micron
            </summary>
        </member>
        <member name="F:Abodit.Units.Area.OneHectare">
            <summary>
            One hectare
            </summary>
        </member>
        <member name="F:Abodit.Units.Area.OneAcre">
            <summary>
            One hectare
            </summary>
        </member>
        <member name="F:Abodit.Units.Area.OneMileSquared">
            <summary>
            One square mile
            </summary>
        </member>
        <member name="F:Abodit.Units.Area.OneYardSquared">
            <summary>
            One square yard
            </summary>
        </member>
        <member name="F:Abodit.Units.Area.OneFootSquared">
            <summary>
            One square foot
            </summary>
        </member>
        <member name="F:Abodit.Units.Area.OneInchSquared">
            <summary>
            One square inch
            </summary>
        </member>
        <member name="F:Abodit.Units.Area.OneThouSquared">
            <summary>
            One square thou
            </summary>
        </member>
        <member name="F:Abodit.Units.Area.Zero">
            <summary>
            An area of zero
            </summary>
        </member>
        <member name="M:Abodit.Units.Area.InImperial">
            <summary>
            Get a non-metric version of the Area using a best-match unit
            </summary>
        </member>
        <member name="M:Abodit.Units.Area.InMetric">
            <summary>
            Get a metric version of the Area using a best-match unit
            </summary>
        </member>
        <member name="T:Abodit.Units.AreaMetric">
            <summary>
            A metric Area
            </summary>
        </member>
        <member name="M:Abodit.Units.AreaMetric.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Area"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.AreaImperial">
            <summary>
            A non-metric Area
            </summary>
        </member>
        <member name="M:Abodit.Units.AreaImperial.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Area"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.AreaSquareKm">
            <summary>
            An Area in square km
            </summary>
        </member>
        <member name="M:Abodit.Units.AreaSquareKm.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Area"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.AreaSquareM">
            <summary>
            An Area in square m
            </summary>
        </member>
        <member name="M:Abodit.Units.AreaSquareM.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Area"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.AreaSquareCm">
            <summary>
            An Area in square cm
            </summary>
        </member>
        <member name="M:Abodit.Units.AreaSquareCm.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Area"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.AreaSquareMm">
            <summary>
            An Area in square mm
            </summary>
        </member>
        <member name="M:Abodit.Units.AreaSquareMm.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Area"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.AreaSquareMicrons">
            <summary>
            An Area in square Microns
            </summary>
        </member>
        <member name="M:Abodit.Units.AreaSquareMicrons.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Area"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.AreaSquareMiles">
            <summary>
            An Area in square Miles
            </summary>
        </member>
        <member name="M:Abodit.Units.AreaSquareMiles.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Area"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.AreaSquareYards">
            <summary>
            An Area in square Yards
            </summary>
        </member>
        <member name="M:Abodit.Units.AreaSquareYards.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Area"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.AreaSquareFeet">
            <summary>
            An Area in square Feet
            </summary>
        </member>
        <member name="M:Abodit.Units.AreaSquareFeet.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Area"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.AreaSquareInches">
            <summary>
            An Area in square Inches
            </summary>
        </member>
        <member name="M:Abodit.Units.AreaSquareInches.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Area"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.AreaSquareThou">
            <summary>
            An Area in square Thou
            </summary>
        </member>
        <member name="M:Abodit.Units.AreaSquareThou.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Area"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.AreaHectares">
            <summary>
            An Area in hectares
            </summary>
        </member>
        <member name="M:Abodit.Units.AreaHectares.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Area"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.AreaAcres">
            <summary>
            An Area in acres
            </summary>
        </member>
        <member name="M:Abodit.Units.AreaAcres.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Area"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.Bequerel">
            <summary>
            An Bequerel, a measure of radioactivity (1 Bq, ...)
            </summary>
        </member>
        <member name="M:Abodit.Units.Bequerel.#ctor">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Bequerel"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Bequerel.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates an instance of a Bequerel based on a number of amps
            </summary>
        </member>
        <member name="M:Abodit.Units.Bequerel.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Create a value
            </summary>
        </member>
        <member name="M:Abodit.Units.Bequerel.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="F:Abodit.Units.Bequerel.OneBequerel">
            <summary>
            One Bequerel unit
            </summary>
        </member>
        <member name="F:Abodit.Units.Bequerel.Zero">
            <summary>
            Zero Bequerels
            </summary>
        </member>
        <member name="T:Abodit.Units.BMI">
            <summary>
            A Body Mass Index (weight / height relationship)
            </summary>
            <remarks>
            The BMI is defined as the body mass divided by the square of the body height, and is universally expressed in units of kg/m2
            </remarks>
        </member>
        <member name="M:Abodit.Units.BMI.#ctor">
            <summary>
            Ceates a new instance of the <see cref="T:Abodit.Units.BMI"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.BMI.#ctor(System.Double)">
            <summary>
            Ceates a new instance of the <see cref="T:Abodit.Units.BMI"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.BMI.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Ceates a new instance of the <see cref="T:Abodit.Units.BMI"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.BMI.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Ceates a new instance of the <see cref="T:Abodit.Units.BMI"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.BMI.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="F:Abodit.Units.BMI.One">
            <summary>
            One BMI
            </summary>
        </member>
        <member name="T:Abodit.Units.Conversion`1">
            <summary>
            Words for each part of a complex unitised expression, e.g. miles,mi; the actual distance value and false for metric
            </summary>
        </member>
        <member name="P:Abodit.Units.Conversion`1.Words">
            <summary>
            Get the words
            </summary>
        </member>
        <member name="P:Abodit.Units.Conversion`1.Metric">
            <summary>
            Is this a metric conversion?
            </summary>
        </member>
        <member name="P:Abodit.Units.Conversion`1.Value">
            <summary>
            Gets the value
            </summary>
        </member>
        <member name="M:Abodit.Units.Conversion`1.#ctor(System.String,`0,System.Boolean)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Conversion`1"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.Coulomb">
            <summary>
            An Coulomb, a measure of electric charge
            </summary>
        </member>
        <member name="M:Abodit.Units.Coulomb.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.Coulomb"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Coulomb.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates an instance of a Coulomb based on a number of amps
            </summary>
        </member>
        <member name="M:Abodit.Units.Coulomb.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.Coulomb"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Coulomb.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="F:Abodit.Units.Coulomb.OneCoulomb">
            <summary>
            A unit of one Coulomb
            </summary>
        </member>
        <member name="T:Abodit.Units.ThingType">
            <summary>
            A thing type, e.g. an angry spider, a daft duck, ...
            </summary>
        </member>
        <member name="P:Abodit.Units.ThingType.Name">
            <summary>
            Gets the name
            </summary>
        </member>
        <member name="P:Abodit.Units.ThingType.NamePlural">
            <summary>
            Gets the plural name
            </summary>
        </member>
        <member name="M:Abodit.Units.ThingType.#ctor(System.String,System.String)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.ThingType"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.ThingType.Format(System.Double)">
            <summary>
            Get a noun for quantity of these, e.g. 1 goose, 2 geese, ...
            </summary>
        </member>
        <member name="T:Abodit.Units.CountableThingsQuantity`1">
            <summary>
            A measure of things (any adjective plus any noun)
            5 angry spider, 2 hungry snails, ...
            </summary>
        </member>
        <member name="M:Abodit.Units.CountableThingsQuantity`1.#ctor">
            <summary>
            Creates a new <see cref="T:Abodit.Units.CountableThingsQuantity`1"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.CountableThingsQuantity`1.#ctor(`0,System.Double)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.CountableThingsQuantity`1"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.CountableThingsQuantity`1.#ctor(System.Collections.Generic.IDictionary{`0,System.Double})">
            <summary>
            Creates a new <see cref="T:Abodit.Units.CountableThingsQuantity`1"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.CountableThingsQuantity`1.Create(System.Collections.Generic.IDictionary{`0,System.Double})">
            <summary>
            Creates a new <see cref="T:Abodit.Units.CountableThingsQuantity`1"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.CountableThingsQuantity`1.DoDescribe(System.Boolean,System.Int32)">
            <summary>
            Describe the value
            </summary>
        </member>
        <member name="M:Abodit.Units.CountableThingsQuantity`1.Project(System.Func{`0,`0})">
            <summary>
            Project the things to a more general TSynset (maybe a Noun or Adjective reduction)
            </summary>
        </member>
        <member name="T:Abodit.Units.Currency">
            <summary>
            Currency objects may contain a mixture of different currencysymbols and values 
            (could be a sum, could be same value in different, caller decides)
            </summary>
        </member>
        <member name="F:Abodit.Units.Currency.DateTimeOffset">
            <summary>
            A date time stamp for the time when this currency was valid
            </summary>
        </member>
        <member name="M:Abodit.Units.Currency.#ctor(Abodit.Units.CurrencySymbol,System.Double)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Currency"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Currency.#ctor(System.Collections.Generic.IDictionary{Abodit.Units.CurrencySymbol,System.Double})">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Currency"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Currency.#ctor(Abodit.Units.CurrencySymbol,System.Double,System.DateTimeOffset)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Currency"/>
            </summary>
        </member>
        <member name="F:Abodit.Units.Currency.One">
            <summary>
            A Unit of Currency - Except Currency is a Vector, could have multiple units
            TODO: Reconcile this
            </summary>
        </member>
        <member name="M:Abodit.Units.Currency.#ctor(System.Collections.Generic.IDictionary{Abodit.Units.CurrencySymbol,System.Double},System.DateTimeOffset)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Currency"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Currency.Create(System.Collections.Generic.IDictionary{Abodit.Units.CurrencySymbol,System.Double})">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Currency"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.CurrencySymbol">
            <summary>
            Represents a Unit of Currency
            </summary>
            <remarks>
            Maybe CurrencySymbols can only be made from a CurrencyFactory and that links them to
            an Exchange Rate object that can then convert between currencies for a given date?
            </remarks>
        </member>
        <member name="P:Abodit.Units.CurrencySymbol.Symbol">
            <summary>
            The symbol
            </summary>
        </member>
        <member name="P:Abodit.Units.CurrencySymbol.Before">
            <summary>
            A flag as to whether the symbol comes before the decimal value (vs after)
            </summary>
        </member>
        <member name="P:Abodit.Units.CurrencySymbol.All">
            <summary>
            Gets all possible CurrencySymbols
            </summary>
        </member>
        <member name="M:Abodit.Units.CurrencySymbol.Get(System.String)">
            <summary>
            Get a CurrencySymbol by name (identity mapped)
            </summary>
        </member>
        <member name="M:Abodit.Units.CurrencySymbol.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.CurrencySymbol"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.CurrencySymbol.Format(System.Double)">
            <summary>
            Format a value with this currency symol
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.GBPSymbol">
            <summary>
            GBP symbol
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.USDSymbol">
            <summary>
            USD symbol
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.EURSymbol">
            <summary>
            EUR symbol
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.GBP">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.USD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.EUR">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.AED">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.AFN">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.ALL">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.AMD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.ANG">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.AOA">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.ARS">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.AUD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.AWG">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.AZN">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.BAM">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.BBD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.BDT">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.BGN">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.BHD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.BIF">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.BMD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.BND">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.BOB">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.BRL">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.BSD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.BTC">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.BTN">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.BWP">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.BYR">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.BZD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.CAD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.CDF">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.CHF">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.CLF">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.CLP">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.CNY">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.COP">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.CRC">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.CUC">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.CUP">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.CVE">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.CZK">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.DJF">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.DKK">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.DOP">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.DZD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.EEK">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.EGP">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.ERN">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.ETB">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.FJD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.FKP">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.GEL">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.GGP">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.GHS">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.GIP">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.GMD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.GNF">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.GTQ">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.GYD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.HKD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.HNL">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.HRK">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.HTG">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.HUF">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.IDR">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.ILS">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.IMP">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.INR">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.IQD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.IRR">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.ISK">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.JEP">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.JMD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.JOD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.JPY">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.KES">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.KGS">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.KHR">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.KMF">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.KPW">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.KRW">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.KWD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.KYD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.KZT">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.LAK">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.LBP">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.LKR">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.LRD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.LSL">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.LTL">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.LVL">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.LYD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.MAD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.MDL">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.MGA">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.MKD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.MMK">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.MNT">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.MOP">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.MRO">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.MTL">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.MUR">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.MVR">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.MWK">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.MXN">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.MYR">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.MZN">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.NAD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.NGN">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.NIO">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.NOK">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.NPR">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.NZD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.OMR">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.PAB">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.PEN">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.PGK">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.PHP">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.PKR">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.PLN">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.PYG">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.QAR">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.RON">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.RSD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.RUB">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.RWF">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.SAR">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.SBD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.SCR">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.SDG">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.SEK">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.SGD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.SHP">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.SLL">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.SOS">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.SRD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.STD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.SVC">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.SYP">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.SZL">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.THB">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.TJS">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.TMT">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.TND">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.TOP">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.TRY">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.TTD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.TWD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.TZS">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.UAH">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.UGX">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.UYU">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.UZS">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.VEF">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.VND">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.VUV">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.WST">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.XAF">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.XAG">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.XAU">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.XCD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.XDR">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.XOF">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.XPD">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.XPF">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.XPT">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.YER">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.ZAR">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.ZMK">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.ZMW">
            <summary>
            A currency
            </summary>
        </member>
        <member name="F:Abodit.Units.CurrencySymbol.ZWL">
            <summary>
            A currency
            </summary>
        </member>
        <member name="T:Abodit.Units.DateTimeQuantity">
            <summary>
            A DateTime quantity
            </summary>
        </member>
        <member name="P:Abodit.Units.DateTimeQuantity.CalendarDateTime">
            <summary>
            The actual date time value
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeQuantity.#ctor">
            <summary>
            Creates a new instance of the the <see cref="T:Abodit.Units.DateTimeQuantity"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeQuantity.#ctor(Abodit.Units.CalendarDateTime)">
            <summary>
            Creates an instance of a DateTime
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeQuantity.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.DateTimeQuantity"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeQuantity.CreateStatic(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.DateTimeQuantity"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeQuantity.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Units.DateTimeQuantity.DoDescribe(System.Boolean,System.Int32)">
            <summary>
            Describes this quantity
            </summary>
        </member>
        <member name="F:Abodit.Units.DateTimeQuantity.OneEarthDay">
            <summary>
            One earth day
            </summary>
        </member>
        <member name="T:Abodit.Units.Density">
            <summary>
            A density
            </summary>
        </member>
        <member name="P:Abodit.Units.Density.KilogramsPerMeterCubed">
            <summary>
            Density in kilogrammes per meter cubed
            </summary>
        </member>
        <member name="M:Abodit.Units.Density.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.Density"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Density.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.Density"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Density.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.Density"/> class
            </summary>
        </member>
        <member name="F:Abodit.Units.Density.OneKilogramPerMeterCubed">
            <summary>
            A Density of One kilogram per meter cubed
            </summary>
        </member>
        <member name="T:Abodit.Units.DimensionalException">
            <summary>
            An exception that occurs if you try to combine or convert incompatible units of measure
            e.g. adding a distance to a time
            </summary>
        </member>
        <member name="M:Abodit.Units.DimensionalException.#ctor(Abodit.Units.Dimensions.Dimension,Abodit.Units.Dimensions.Dimension)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.DimensionalException"/> class
            </summary>
        </member>
        <member name="T:Abodit.Units.Dimensions.Dimension">
            <summary>
            There are seven fundamental dimensions from which all others are created
            </summary>
            <remarks>
            mass, length, time, temperature, electric current, luminous intensity, amount of matter
            </remarks>
        </member>
        <member name="P:Abodit.Units.Dimensions.Dimension.Alias">
            <summary>
            A common name for the dimension (e.g. velocity)
            </summary>
        </member>
        <member name="P:Abodit.Units.Dimensions.Dimension.Name">
            <summary>
            The official name for the dimension (e.g. length^2)
            </summary>
        </member>
        <member name="P:Abodit.Units.Dimensions.Dimension.FullName">
            <summary>
            A full name for the dimension, e.g. area (length^2)
            </summary>
        </member>
        <member name="P:Abodit.Units.Dimensions.Dimension.Complexity">
            <summary>
            The complexity of this dimension (for sorting in UI)
            </summary>
            <remarks>
            PrimaryDimensions with order 1 are first, then primary dimensions with powers
            then combinations
            </remarks>
        </member>
        <member name="M:Abodit.Units.Dimensions.Dimension.#ctor(Abodit.Units.Dimensions.DimensionComponent[])">
            <summary>
            You can only create new dimensions by using * and / on existing dimensions
            </summary>
        </member>
        <member name="M:Abodit.Units.Dimensions.Dimension.SetAlias(System.String)">
            <summary>
            Overrides the name for a dimension with a common name, e.g. area for length^2
            </summary>
        </member>
        <member name="M:Abodit.Units.Dimensions.Dimension.op_Multiply(Abodit.Units.Dimensions.Dimension,Abodit.Units.Dimensions.Dimension)">
            <summary>
            Forms a new Dimension from the product of two other Dimensions
            </summary>
        </member>
        <member name="M:Abodit.Units.Dimensions.Dimension.op_ExclusiveOr(Abodit.Units.Dimensions.Dimension,System.Int32)">
            <summary>
            Forms a new Dimension from the power of another dimension
            </summary>
        </member>
        <member name="M:Abodit.Units.Dimensions.Dimension.op_Division(Abodit.Units.Dimensions.Dimension,Abodit.Units.Dimensions.Dimension)">
            <summary>
            Forms a new Dimension from the division of two other Dimensions
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.Mass">
            <summary>
            Mass Dimension
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.Length">
            <summary>
            Length Dimension
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.Time">
            <summary>
            Time Dimension
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.Temperature">
            <summary>
            Temperature Dimension
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.ElectricCurrent">
            <summary>
            Electric current Dimension
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.LuminousIntensity">
            <summary>
            Luminous intensity Dimension
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.AmountOfMatter">
            <summary>
            Amount of matter Dimension (moles)
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.AmountOfMemory">
            <summary>
            Amount of memory Dimension (e.g. kilobytes)
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.AmountOfMoney">
            <summary>
            An amount of money Dimension
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.Scalar">
            <summary>
            A scalar Dimension (e.g. angle)
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.Unknown">
            <summary>
            An Unknown Dimension
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.DateTime">
            <summary>
            DateTime isn't really a Dimension but we need to separate datetime quantities from time periods
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.AbsorbedRadiation">
            <summary>
            Absorbed radiation Dimension
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.Acceleration">
            <summary>
            Acceleration Dimension
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.Area">
            <summary>
            Area Dimension
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.Bandwidth">
            <summary>
            Bandwidth Dimension
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.BMI">
            <summary>
            BMI Dimension
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.Capacitance">
            <summary>
            Capacitance Dimension
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.Density">
            <summary>
            Density Dimension
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.Energy">
            <summary>
            Energy Dimension
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.Power">
            <summary>
            Power Dimension
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.ElectricCharge">
            <summary>
            Electric charge Dimension
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.Force">
            <summary>
            Force Dimension
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.Inductance">
            <summary>
            Inductance Dimension
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.Pressure">
            <summary>
            Pressure Dimension
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.Rate">
            <summary>
            A rate of a scalar over time, or a frequency Dimension
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.Voltage">
            <summary>
            Voltage Dimension
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.Volume">
            <summary>
            Volume Dimension
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.Velocity">
            <summary>
            Velocity Dimension
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.Strength">
            <summary>
            Strength Dimension
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Dimension.ReciprocalLength">
            <summary>
            Dimension
            </summary>
        </member>
        <member name="M:Abodit.Units.Dimensions.Dimension.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Units.Dimensions.Dimension.FromString(System.String)">
            <summary>
            Creates a new Dimension by name
            </summary>
        </member>
        <member name="M:Abodit.Units.Dimensions.Dimension.GetDefaultUnit(System.Boolean)">
            <summary>
            Get the default IUnit for this dimension (e.g. meters for length)
            </summary>
            <param name="metric">Whether to prefer metric or imperial</param>
            <returns>The matching IUnit or null if there are none, or more than one possible</returns>
        </member>
        <member name="M:Abodit.Units.Dimensions.Dimension.GetAllPossibleUnits">
            <summary>
            Get all possible units that have this dimension
            </summary>
        </member>
        <member name="P:Abodit.Units.Dimensions.DimensionComponent.Id">
            <summary>
            Id is just to keep them in the customary order
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.DimensionComponent.DateTime">
            <summary>
            DateTime isn't really a Dimension but we need to separate datetime quantities from time periods
            </summary>
        </member>
        <member name="M:Abodit.Units.Dimensions.DimensionComponent.Create(System.String,System.Int32)">
            <summary>
            Identity maps all requests so that there is only ever one DimensionComponent for a given pair of dimension and exponent
            </summary>
        </member>
        <member name="M:Abodit.Units.Dimensions.DimensionComponent.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Units.Dimensions.Interpretation">
            <summary>
            How an adjective is interpreted
            </summary>
        </member>
        <member name="P:Abodit.Units.Dimensions.Interpretation.Dimension">
            <summary>
            The dimension this adjective can apply to - each can only apply to one dimension (otherwise it's a different meaning, so separate interface, e.g. light and light)
            </summary>
        </member>
        <member name="P:Abodit.Units.Dimensions.Interpretation.Qualifiers">
            <summary>
            Required qualifiers on the field, e.g. must be a Width field to match "wide"
            </summary>
        </member>
        <member name="P:Abodit.Units.Dimensions.Interpretation.IsPositive">
            <summary>
            Does this adjective represent a positive increment on the value it describes
            e.g. larger, longer, heavier, ...
            </summary>
        </member>
        <member name="P:Abodit.Units.Dimensions.Interpretation.SynSetName">
            <summary>
            Name of Synset
            </summary>
        </member>
        <member name="T:Abodit.Units.Dimensions.Interpretation.Sense">
            <summary>
            Negative or positive sense
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Interpretation.Sense.Positive">
            <summary>
            The interpretation is in a positive (increasing) sense
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Interpretation.Sense.Negative">
            <summary>
            The interpretation is in a negative (decreasing) sense
            </summary>
        </member>
        <member name="M:Abodit.Units.Dimensions.Interpretation.#ctor(System.String,Abodit.Units.Dimensions.Interpretation.Sense,Abodit.Units.Dimensions.Qualifier)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.Dimensions.Interpretation"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Dimensions.Interpretation.#ctor(System.String,Abodit.Units.Dimensions.Dimension,Abodit.Units.Dimensions.Interpretation.Sense,Abodit.Units.Dimensions.Qualifier[])">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.Dimensions.Interpretation"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Dimensions.Interpretation.Invert">
            <summary>
            Invert an interpretation, i.e. small to large, large to small
            </summary>
            <returns></returns>
        </member>
        <member name="F:Abodit.Units.Dimensions.Interpretation.None">
            <summary>
            Marker value for no interpretation
            </summary>
        </member>
        <member name="M:Abodit.Units.Dimensions.Interpretation.ForDimension(Abodit.Units.Dimensions.Dimension)">
            <summary>
            Mostly for testing
            </summary>
        </member>
        <member name="M:Abodit.Units.Dimensions.Interpretation.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Units.Dimensions.Interpretation.Plus(Abodit.Units.Dimensions.Interpretation)">
            <summary>
            Combines two <see cref="T:Abodit.Units.Dimensions.Interpretation"/> values in a range, e.g. 2-3km
            </summary>
            <remarks>
            When we combine a scalar and a dimension we become the dimension
            e.g. between 2 [scalar] and 3km [Length] => 2km-3km [Length]
            </remarks>
        </member>
        <member name="T:Abodit.Units.Dimensions.Qualifier">
            <summary>
            A Qualifier on a quantity with units (e.g. length vs breadth vs height)
            </summary>
        </member>
        <member name="P:Abodit.Units.Dimensions.Qualifier.AllQualifiers">
            <summary>
            Get all of the qualifiers that have been defined
            </summary>
        </member>
        <member name="P:Abodit.Units.Dimensions.Qualifier.Name">
            <summary>
            Gets the name of this Qualifier
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Qualifier.Dimension">
            <summary>
            Dimension that works with this qualifier, or empty set for all
            </summary>
        </member>
        <member name="M:Abodit.Units.Dimensions.Qualifier.#ctor(System.String,Abodit.Units.Dimensions.Dimension)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.Dimensions.Qualifier"/> class
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Qualifier.None">
            <summary>
            No qualifier
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Qualifier.Interval">
            <summary>
            Time as an interval
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Qualifier.Age">
            <summary>
            Time as an age
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Qualifier.Length">
            <summary>
            Length in a horizontal direction
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Qualifier.Width">
            <summary>
            Width
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Qualifier.Height">
            <summary>
            Height (ascending length)
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Qualifier.Depth">
            <summary>
            Depth (descending length)
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Qualifier.Driven">
            <summary>
            Driven distance (along a road or path)
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Qualifier.Countable">
            <summary>
            A scalar quantity could be countable (e.g. people) or uncountable (eg. sand)
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Qualifier.Uncountable">
            <summary>
            A scalar quantity could be countable (e.g. people) or uncountable (eg. sand)
            </summary>
        </member>
        <member name="F:Abodit.Units.Dimensions.Qualifier.WarmOrCold">
            <summary>
            Warm or cold
            </summary>
        </member>
        <member name="M:Abodit.Units.Dimensions.Qualifier.Equals(Abodit.Units.Dimensions.Qualifier)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Units.Dimensions.Qualifier.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Units.Dimensions.Qualifier.IsA(Abodit.Units.Dimensions.Qualifier)">
            <summary>
            Is this qualifier the same as another
            </summary>
            <remarks>
            Allows for later implementation of hierarchy in Qualifiers
            </remarks>
        </member>
        <member name="T:Abodit.Units.Distance">
            <summary>
            A distance
            </summary>
        </member>
        <member name="P:Abodit.Units.Distance.Meters">
            <summary>
            Distance in meters
            </summary>
        </member>
        <member name="P:Abodit.Units.Distance.Km">
            <summary>
            Gets the Distance in Km
            </summary>
        </member>
        <member name="P:Abodit.Units.Distance.Centimeters">
            <summary>
            Gets the Distance in Centimeters
            </summary>
        </member>
        <member name="P:Abodit.Units.Distance.Millimeters">
            <summary>
            Gets the Distance in mm
            </summary>
        </member>
        <member name="P:Abodit.Units.Distance.Microns">
            <summary>
            Gets the Distance in microns
            </summary>
        </member>
        <member name="P:Abodit.Units.Distance.Miles">
            <summary>
            Gets the Distance in miles
            </summary>
        </member>
        <member name="P:Abodit.Units.Distance.Yards">
            <summary>
            Gets the Distance in yards
            </summary>
        </member>
        <member name="P:Abodit.Units.Distance.Feet">
            <summary>
            Gets the Distance in feet
            </summary>
        </member>
        <member name="P:Abodit.Units.Distance.Inches">
            <summary>
            Gets the Distance in inches
            </summary>
        </member>
        <member name="P:Abodit.Units.Distance.Thou">
            <summary>
            Gets the Distance in thou
            </summary>
        </member>
        <member name="P:Abodit.Units.Distance.Chains">
            <summary>
            Gets the Distance in chains
            </summary>
        </member>
        <member name="P:Abodit.Units.Distance.Furlongs">
            <summary>
            Gets the Distance in furlongs
            </summary>
        </member>
        <member name="P:Abodit.Units.Distance.Leagues">
            <summary>
            Gets the Distance in leagues
            </summary>
        </member>
        <member name="P:Abodit.Units.Distance.Fathoms">
            <summary>
            Gets the Distance in fathoms
            </summary>
        </member>
        <member name="P:Abodit.Units.Distance.Cables">
            <summary>
            Gets the Distance in cables
            </summary>
        </member>
        <member name="P:Abodit.Units.Distance.Nm">
            <summary>
            Gets the Distance in Nm
            </summary>
        </member>
        <member name="M:Abodit.Units.Distance.#ctor">
            <summary>
            Creates a new zero Distance
            </summary>
        </member>
        <member name="M:Abodit.Units.Distance.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates an instance of distance based on a multiplier and a unit of distance
            </summary>
        </member>
        <member name="M:Abodit.Units.Distance.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.Distance"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Distance.BetweenTwoPointsOnEarth(Abodit.Units.LocationOnEarth,Abodit.Units.LocationOnEarth)">
            <summary>
            Calculate the distance between two points on earth
            </summary>
        </member>
        <member name="M:Abodit.Units.Distance.BetweenTwoPointsOnEarth(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Calculate the distance between two points on earth
            </summary>
        </member>
        <member name="F:Abodit.Units.Distance.Units">
            <summary>
            Gets the AI UnitSet for metric Distances
            </summary>
        </member>
        <member name="F:Abodit.Units.Distance.OneMile">
            <summary>
            A unit of one mile
            </summary>
        </member>
        <member name="F:Abodit.Units.Distance.OneYard">
            <summary>
            A unit of one yard
            </summary>
        </member>
        <member name="F:Abodit.Units.Distance.OneFoot">
            <summary>
            A unit of one foot
            </summary>
        </member>
        <member name="F:Abodit.Units.Distance.OneInch">
            <summary>
            A unit of one inch
            </summary>
        </member>
        <member name="F:Abodit.Units.Distance.OneThou">
            <summary>
            A unit of one thou
            </summary>
        </member>
        <member name="F:Abodit.Units.Distance.OneMeter">
            <summary>
            Alias for Units.One (one meter)
            </summary>
        </member>
        <member name="F:Abodit.Units.Distance.OneKiloMeter">
            <summary>
            Alias for Units.Kilo (one kilometer)
            </summary>
        </member>
        <member name="F:Abodit.Units.Distance.OneCentimeter">
            <summary>
            Alias for Units.Centi (one centimeter)
            </summary>
        </member>
        <member name="F:Abodit.Units.Distance.OneMillimeter">
            <summary>
            Alias for Units.Milli (one millimeter)
            </summary>
        </member>
        <member name="F:Abodit.Units.Distance.Zero">
            <summary>
            Distance of Zero
            </summary>
        </member>
        <member name="M:Abodit.Units.Distance.Canonicalize">
            <summary>
            Convert a distance into a Unit that is most suitable for its magnitude
            </summary>
            <returns></returns>
        </member>
        <member name="M:Abodit.Units.Distance.InMetric">
            <summary>
            Convert to metric using appropriate units
            </summary>
        </member>
        <member name="M:Abodit.Units.Distance.InImperial">
            <summary>
            Convert to imperial using appropriate units
            </summary>
        </member>
        <member name="M:Abodit.Units.Distance.Multiply(Abodit.Units.Distance,Abodit.Units.Distance)">
            <summary>
            Multiply two distances to form an area
            </summary>
        </member>
        <member name="T:Abodit.Units.DistanceMetric">
            <summary>
            A metric Distance
            </summary>
        </member>
        <member name="M:Abodit.Units.DistanceMetric.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new Distance
            </summary>
        </member>
        <member name="T:Abodit.Units.DistanceImperial">
            <summary>
            An non-metric Distance
            </summary>
        </member>
        <member name="M:Abodit.Units.DistanceImperial.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new Distance
            </summary>
        </member>
        <member name="T:Abodit.Units.DistanceKm">
            <summary>
            A Distance in Km
            </summary>
        </member>
        <member name="M:Abodit.Units.DistanceKm.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new Distance
            </summary>
        </member>
        <member name="T:Abodit.Units.DistanceM">
            <summary>
            A Distance in m
            </summary>
        </member>
        <member name="M:Abodit.Units.DistanceM.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new Distance
            </summary>
        </member>
        <member name="T:Abodit.Units.DistanceCm">
            <summary>
            A Distance in Cm
            </summary>
        </member>
        <member name="M:Abodit.Units.DistanceCm.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new Distance
            </summary>
        </member>
        <member name="T:Abodit.Units.DistanceMm">
            <summary>
            A Distance in mm
            </summary>
        </member>
        <member name="M:Abodit.Units.DistanceMm.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new Distance
            </summary>
        </member>
        <member name="T:Abodit.Units.DistanceMicrons">
            <summary>
            A Distance in microns
            </summary>
        </member>
        <member name="M:Abodit.Units.DistanceMicrons.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new Distance
            </summary>
        </member>
        <member name="T:Abodit.Units.DistanceMiles">
            <summary>
            A Distance in miles
            </summary>
        </member>
        <member name="M:Abodit.Units.DistanceMiles.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new Distance
            </summary>
        </member>
        <member name="T:Abodit.Units.DistanceYards">
            <summary>
            A Distance in yards
            </summary>
        </member>
        <member name="M:Abodit.Units.DistanceYards.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new Distance
            </summary>
        </member>
        <member name="T:Abodit.Units.DistanceFeet">
            <summary>
            A Distance in feet
            </summary>
        </member>
        <member name="M:Abodit.Units.DistanceFeet.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new Distance
            </summary>
        </member>
        <member name="T:Abodit.Units.DistanceInches">
            <summary>
            A Distance in inches
            </summary>
        </member>
        <member name="M:Abodit.Units.DistanceInches.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new Distance
            </summary>
        </member>
        <member name="T:Abodit.Units.DistanceThou">
            <summary>
            A Distance in Thou
            </summary>
        </member>
        <member name="M:Abodit.Units.DistanceThou.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new Distance
            </summary>
        </member>
        <member name="T:Abodit.Units.DoubleOrNull">
            <summary>
            Just a double wrapped up in a class that can behave like any other unit
            </summary>
        </member>
        <member name="P:Abodit.Units.DoubleOrNull.Value">
            <summary>
            Gets the value (or null)
            </summary>
        </member>
        <member name="M:Abodit.Units.DoubleOrNull.#ctor(System.Double)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.DoubleOrNull"/>
            </summary>
        </member>
        <member name="F:Abodit.Units.DoubleOrNull.One">
            <summary>
            Gets the Unit for a double
            </summary>
        </member>
        <member name="M:Abodit.Units.DoubleOrNull.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.DoubleOrNull"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.DoubleOrNull.DoDescribe(System.Boolean,System.Int32)">
            <summary>
            Describes this value
            </summary>
        </member>
        <member name="T:Abodit.Units.Force">
            <summary>
            A Force
            </summary>
        </member>
        <member name="M:Abodit.Units.Force.#ctor">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Force"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Force.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates an instance of a Force
            </summary>
        </member>
        <member name="M:Abodit.Units.Force.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Force"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Force.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="F:Abodit.Units.Force.Units">
            <summary>
            SI unit Newtons
            </summary>
        </member>
        <member name="T:Abodit.Units.Frequency">
            <summary>
            A Frequency in Hz
            </summary>
        </member>
        <member name="M:Abodit.Units.Frequency.#ctor">
            <summary>
            Create a new instance of the Frequency class
            </summary>
        </member>
        <member name="M:Abodit.Units.Frequency.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates an instance of a Frequency
            </summary>
        </member>
        <member name="M:Abodit.Units.Frequency.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Frequency"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Frequency.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="F:Abodit.Units.Frequency.Units">
            <summary>
            Gets the SI UnitSet for Frequency
            </summary>
        </member>
        <member name="P:Abodit.Units.Frequency.Hertz">
            <summary>
            Get the frequency in Hertz
            </summary>
        </member>
        <member name="P:Abodit.Units.Frequency.KiloHertz">
            <summary>
            Get the frequency in KiloHertz
            </summary>
        </member>
        <member name="P:Abodit.Units.Frequency.MegaHertz">
            <summary>
            Get the frequency in MegaHertz
            </summary>
        </member>
        <member name="P:Abodit.Units.Frequency.GigaHertz">
            <summary>
            Get the frequency in GigaHertz
            </summary>
        </member>
        <member name="P:Abodit.Units.Frequency.TerraHertz">
            <summary>
            Get the frequency in TerraHertz
            </summary>
        </member>
        <member name="P:Abodit.Units.Frequency.PetaHertz">
            <summary>
            Get the frequency in PetaHertz
            </summary>
        </member>
        <member name="P:Abodit.Units.Frequency.ExaHertz">
            <summary>
            Get the frequency in ExaHertz
            </summary>
        </member>
        <member name="P:Abodit.Units.Frequency.ZettaHertz">
            <summary>
            Get the frequency in ZettaHertz
            </summary>
        </member>
        <member name="P:Abodit.Units.Frequency.YottaHertz">
            <summary>
            Get the frequency in YottaHertz
            </summary>
        </member>
        <member name="T:Abodit.Units.FuelConsumption">
            <summary>
            A fuel consumption value
            </summary>
            <remarks>
            Unusual in that units do not have the same dimension!
            </remarks>
        </member>
        <member name="P:Abodit.Units.FuelConsumption.LitresPer100Km">
            <summary>
            FuelConsumption in litres per 100 km
            </summary>
        </member>
        <member name="P:Abodit.Units.FuelConsumption.MilesPerGallon">
            <summary>
            FuelConsumption in miles per gallon
            </summary>
        </member>
        <member name="M:Abodit.Units.FuelConsumption.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates an instance of FuelConsumption
            </summary>
        </member>
        <member name="M:Abodit.Units.FuelConsumption.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.FuelConsumption"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.FuelConsumption.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Units.FuelConsumption.DoDescribe(System.Boolean,System.Int32)">
            <summary>
            Describe this FuelConsumption (different because l/100km vs miles per gallon)
            </summary>
        </member>
        <member name="F:Abodit.Units.FuelConsumption.OneLiterPer100Km">
            <summary>
            A unit of one liter per 100km
            </summary>
        </member>
        <member name="F:Abodit.Units.FuelConsumption.OneMilePerGallon">
            <summary>
            A unit of miles per gallon
            </summary>
        </member>
        <member name="T:Abodit.Units.Hardness">
            <summary>
            A hardness value
            </summary>
        </member>
        <member name="M:Abodit.Units.Hardness.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates an instance of <see cref="T:Abodit.Units.Hardness"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Hardness.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Hardness"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Hardness.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="F:Abodit.Units.Hardness.One">
            <summary>
            A hardness of one
            </summary>
        </member>
        <member name="T:Abodit.Units.IOPSQuantity">
            <summary>
            An IOPSUnit
            </summary>
        </member>
        <member name="M:Abodit.Units.IOPSQuantity.#ctor">
            <summary>
            Creates a new <see cref="T:Abodit.Units.IOPSQuantity"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.IOPSQuantity.#ctor(System.Double)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.IOPSQuantity"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.IOPSQuantity.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.IOPSQuantity"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.IOPSQuantity.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.IOPSQuantity"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.IOPSQuantity.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="F:Abodit.Units.IOPSQuantity.One">
            <summary>
            A unit of one IOPs
            </summary>
        </member>
        <member name="P:Abodit.Units.IOPSQuantity.IOPS">
            <summary>
            Get the IOPs
            </summary>
        </member>
        <member name="T:Abodit.Units.LocationOnEarth">
            <summary>
            A lat/long value on Earth
            </summary>
        </member>
        <member name="P:Abodit.Units.LocationOnEarth.Latitude">
            <summary>
            Gets the latitude
            </summary>
        </member>
        <member name="P:Abodit.Units.LocationOnEarth.Longitude">
            <summary>
            Gets the longitude
            </summary>
        </member>
        <member name="M:Abodit.Units.LocationOnEarth.#ctor(System.Double,System.Double)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.LocationOnEarth"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.LocationOnEarth.DistanceFrom(Abodit.Units.LocationOnEarth)">
            <summary>
            Gets the <see cref="T:Abodit.Units.Distance"/> to another location on earth
            </summary>
        </member>
        <member name="P:Abodit.Units.LocationOnEarth.Nowhere">
            <summary>
            An unknown location
            </summary>
        </member>
        <member name="M:Abodit.Units.LocationOnEarth.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Units.LocationOnEarth.FromGeoRSS(System.Xml.Linq.XElement)">
            <summary>
            Creates a <see cref="T:Abodit.Units.LocationOnEarth"/> from an XML GeoRSS point
            </summary>
        </member>
        <member name="T:Abodit.Units.Luminosity">
            <summary>
            An Luminosity (1 lumen, ...)
            </summary>
        </member>
        <member name="M:Abodit.Units.Luminosity.#ctor">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Luminosity"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Luminosity.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates an instance of a Luminosity based on a number of amps
            </summary>
        </member>
        <member name="M:Abodit.Units.Luminosity.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Luminosity"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Luminosity.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="F:Abodit.Units.Luminosity.Units">
            <summary>
            Gets the SI UnitSet for Luminosity
            </summary>
        </member>
        <member name="T:Abodit.Units.MemoryCapacity">
            <summary>
            A memory capacity value (1MB, 2MB, ...)
            </summary>
        </member>
        <member name="M:Abodit.Units.MemoryCapacity.#ctor">
            <summary>
            Creates a new <see cref="T:Abodit.Units.MemoryCapacity"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.MemoryCapacity.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates an instance of a MemoryCapacity based on a number of bytes
            </summary>
        </member>
        <member name="M:Abodit.Units.MemoryCapacity.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.MemoryCapacity"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.MemoryCapacity.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryCapacity.OneByte">
            <summary>
            A unit of one byte
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryCapacity.OneKiloByte">
            <summary>
            A unit of one kilo byte
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryCapacity.OneMegaByte">
            <summary>
            A unit of one mega byte
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryCapacity.OneGigaByte">
            <summary>
            A unit of one giga byte
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryCapacity.OneTerraByte">
            <summary>
            A unit of one terra byte
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryCapacity.OnePetaByte">
            <summary>
            A unit of one peta byte
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryCapacity.OneExaByte">
            <summary>
            A unit of one exa byte
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryCapacity.OneZettaByte">
            <summary>
            A unit of one zetta byte
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryCapacity.OneYottaByte">
            <summary>
            A unit of one yotta byte
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryCapacity.OneBit">
            <summary>
            A unit of one bit
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryCapacity.OneKiloBit">
            <summary>
            A unit of one kilobit
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryCapacity.OneMegaBit">
            <summary>
            A unit of one megabit
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryCapacity.OneGigaBit">
            <summary>
            A unit of one giga bit
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryCapacity.OneTerraBit">
            <summary>
            A unit of one terra bit
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryCapacity.OnePetaBit">
            <summary>
            A unit of one peta bit
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryCapacity.OneExaBit">
            <summary>
            A unit of one exa bit
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryCapacity.OneZettaBit">
            <summary>
            A unit of one zetta bit
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryCapacity.OneYottaBit">
            <summary>
            A unit of one yotta bit
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryCapacity.Zero">
            <summary>
            A memory capacity of Zero
            </summary>
        </member>
        <member name="P:Abodit.Units.MemoryCapacity.Bytes">
            <summary>
            Gets the number of bytes
            </summary>
        </member>
        <member name="P:Abodit.Units.MemoryCapacity.Bits">
            <summary>
            Gets the number of bits
            </summary>
        </member>
        <member name="P:Abodit.Units.MemoryCapacity.Kilobytes">
            <summary>
            Gets the number of kilobytes
            </summary>
        </member>
        <member name="P:Abodit.Units.MemoryCapacity.Megabytes">
            <summary>
            Gets the number of megabytes
            </summary>
        </member>
        <member name="P:Abodit.Units.MemoryCapacity.Gigabytes">
            <summary>
            Gets the number of giga bytes
            </summary>
        </member>
        <member name="P:Abodit.Units.MemoryCapacity.Terrabytes">
            <summary>
            Gets the number of terra bytes
            </summary>
        </member>
        <member name="P:Abodit.Units.MemoryCapacity.Petabytes">
            <summary>
            Gets the number of peta bytes
            </summary>
        </member>
        <member name="P:Abodit.Units.MemoryCapacity.Exabytes">
            <summary>
            Gets the number of exa bytes
            </summary>
        </member>
        <member name="P:Abodit.Units.MemoryCapacity.Zettabytes">
            <summary>
            Gets the number of zetta bytes
            </summary>
        </member>
        <member name="P:Abodit.Units.MemoryCapacity.Yottabytes">
            <summary>
            Gets the number of yotta bytes
            </summary>
        </member>
        <member name="M:Abodit.Units.MemoryCapacity.DoDescribe(System.Boolean,System.Int32)">
            <summary>
            Describe this value
            </summary>
        </member>
        <member name="T:Abodit.Units.MemoryPerSecond">
            <summary>
            Memory capacity in bits per second
            </summary>
        </member>
        <member name="M:Abodit.Units.MemoryPerSecond.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.MemoryPerSecond"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.MemoryPerSecond.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Create a new <see cref="T:Abodit.Units.MemoryPerSecond"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.MemoryPerSecond.CreateStatic(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Create a new <see cref="T:Abodit.Units.MemoryPerSecond"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.MemoryPerSecond.Create(Abodit.Units.MemoryCapacity,Abodit.Units.Rate,Abodit.Units.QuantityQualifier)">
            <summary>
            Create a new <see cref="T:Abodit.Units.MemoryPerSecond"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.MemoryPerSecond.Create(Abodit.Units.MemoryCapacity,Abodit.Units.TimePeriod,Abodit.Units.QuantityQualifier)">
            <summary>
            Create a new <see cref="T:Abodit.Units.MemoryPerSecond"/>
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryPerSecond.OneBytePerSecond">
            <summary>
            One byte per second
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryPerSecond.OneBitPerSecond">
            <summary>
            One bit per second
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryPerSecond.OneKiloBytePerSecond">
            <summary>
            One kilo byte per second
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryPerSecond.OneKiloBitPerSecond">
            <summary>
            One kilo bit per second
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryPerSecond.OneMegaBytePerSecond">
            <summary>
            One mega byte per second
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryPerSecond.OneMegaBitPerSecond">
            <summary>
            One mega bit per second
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryPerSecond.OneGigaBytePerSecond">
            <summary>
            One giga byte per second
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryPerSecond.OneGigaBitPerSecond">
            <summary>
            One giga bit per second
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryPerSecond.OneTerraBytePerSecond">
            <summary>
            One terra byte per second
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryPerSecond.OneTerraBitPerSecond">
            <summary>
            One terra bit per second
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryPerSecond.OnePetaBytePerSecond">
            <summary>
            One peta byte per second
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryPerSecond.OnePetaBitPerSecond">
            <summary>
            One peta bit per second
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryPerSecond.OneExaBytePerSecond">
            <summary>
            One exa byte per second
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryPerSecond.OneExaBitPerSecond">
            <summary>
            One exa bit per second
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryPerSecond.OneYottaBytePerSecond">
            <summary>
            One yotta byte per second
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryPerSecond.OneYottaBitPerSecond">
            <summary>
            One yotta bit per second
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryPerSecond.OneZettaBytePerSecond">
            <summary>
            One zetta byte per second
            </summary>
        </member>
        <member name="F:Abodit.Units.MemoryPerSecond.OneZettaBitPerSecond">
            <summary>
            One zetta bit per second
            </summary>
        </member>
        <member name="P:Abodit.Units.MemoryPerSecond.BytesPerSecond">
            <summary>
            Get the number of bytes per second
            </summary>
        </member>
        <member name="P:Abodit.Units.MemoryPerSecond.BitsPerSecond">
            <summary>
            Get the number of bits per second
            </summary>
        </member>
        <member name="T:Abodit.Units.Mole">
            <summary>
            A quantity of matter (1 Mole, ...)
            </summary>
        </member>
        <member name="M:Abodit.Units.Mole.#ctor">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Mole"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Mole.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates an instance of Moles based on a number of moles of matter
            </summary>
        </member>
        <member name="M:Abodit.Units.Mole.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Mole"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Mole.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="F:Abodit.Units.Mole.Units">
            <summary>
            SI Units for Moles
            </summary>
        </member>
        <member name="T:Abodit.Units.Percentage">
            <summary>
            A percentage
            </summary>
        </member>
        <member name="M:Abodit.Units.Percentage.#ctor">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Percentage"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Percentage.#ctor(System.Double)">
            <summary>
            Creates an instance of a Percentage, pass in 0.0 to 100.0
            </summary>
        </member>
        <member name="M:Abodit.Units.Percentage.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.Percentage"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Percentage.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.Percentage"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Percentage.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="F:Abodit.Units.Percentage.OnePercent">
            <summary>
            One percent
            </summary>
        </member>
        <member name="F:Abodit.Units.Percentage.OneHundredPercent">
            <summary>
            One hundred percent
            </summary>
        </member>
        <member name="M:Abodit.Units.Percentage.DoDescribe(System.Boolean,System.Int32)">
            <summary>
            Describe this TokenExpressionUnits
            </summary>
        </member>
        <member name="T:Abodit.Units.Ph">
            <summary>
            A pH value
            </summary>
        </member>
        <member name="M:Abodit.Units.Ph.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates an instance of a <see cref="T:Abodit.Units.Ph"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Ph.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Create an <see cref="T:Abodit.Units.Ph"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Ph.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Units.Ph.InMetric">
            <summary>
            In metric
            </summary>
        </member>
        <member name="M:Abodit.Units.Ph.InImperial">
            <summary>
            In imperial
            </summary>
        </member>
        <member name="F:Abodit.Units.Ph.OnePh">
            <summary>
            A unit of one pH
            </summary>
        </member>
        <member name="T:Abodit.Units.Power">
            <summary>
            A Power (wattage)
            </summary>
        </member>
        <member name="M:Abodit.Units.Power.#ctor">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Units.Power"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Power.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates an instance of a Power
            </summary>
        </member>
        <member name="M:Abodit.Units.Power.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Units.Power"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Power.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="F:Abodit.Units.Power.Units">
            <summary>
            SI Units for Power
            </summary>
        </member>
        <member name="F:Abodit.Units.Power.OneHorsePower">
            <summary>
            One horse power
            </summary>
        </member>
        <member name="F:Abodit.Units.Power.Zero">
            <summary>
            Zero power
            </summary>
        </member>
        <member name="T:Abodit.Units.Pressure">
            <summary>
            A pressure
            </summary>
        </member>
        <member name="P:Abodit.Units.Pressure.NewtonsPerSquareMeter">
            <summary>
            Pressure in Newtons per Square meter
            </summary>
        </member>
        <member name="P:Abodit.Units.Pressure.PoundsPerSquareInch">
            <summary>
            Pressure in pounds per square inch
            </summary>
        </member>
        <member name="M:Abodit.Units.Pressure.#ctor">
            <summary>
            Create a new Pressure of zero
            </summary>
        </member>
        <member name="M:Abodit.Units.Pressure.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates an instance of Pressure based on a multiplier and a unit of Pressure
            </summary>
        </member>
        <member name="M:Abodit.Units.Pressure.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Create a new Pressure
            </summary>
        </member>
        <member name="F:Abodit.Units.Pressure.OneNewtonPerSquaredMeter">
            <summary>
            One Newton per quare inch
            </summary>
        </member>
        <member name="F:Abodit.Units.Pressure.OnePSI">
            <summary>
            One PSI
            </summary>
        </member>
        <member name="M:Abodit.Units.Pressure.InMetric">
            <summary>
            Convert to metric using appropriate units
            </summary>
        </member>
        <member name="M:Abodit.Units.Pressure.InImperial">
            <summary>
            Convert to imperial using appropriate units
            </summary>
        </member>
        <member name="T:Abodit.Units.Quantity`1">
            <summary>
            A measurement with a specific dimension, and unit
            The base class for any measurement type, e.g. Distance, Force, Mass, ... with units
            </summary>
            <remarks>
            Scalars with units include distances, times, temperatures, weights, ...
            See http://www.mne.psu.edu/cimbala/Learning/General/units.htm
            See http://www.iso.org/sites/JCGM/VIM/JCGM_200e_FILES/MAIN_JCGM_200e/01_e.html
            </remarks>
        </member>
        <member name="P:Abodit.Units.Quantity`1.Qualifier">
            <summary>
            A quantity may be further qualified, e.g a length may be a radius, or a circumference, ...
            </summary>
        </member>
        <member name="P:Abodit.Units.Quantity`1.ValueInCanonicalUnit">
            <summary>
            Gets the double value in the canonical unit
            </summary>
        </member>
        <member name="M:Abodit.Units.Quantity`1.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Quantity`1"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Quantity`1.Convert(Abodit.Units.IUnit)">
            <summary>
            Convert a quantity to a different Unit (with the same dimension)
            </summary>
        </member>
        <member name="M:Abodit.Units.Quantity`1.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new quantity
            </summary>
        </member>
        <member name="M:Abodit.Units.Quantity`1.Add(`0)">
            <summary>
            Add two units of the same kind together
            (Should also have the same QuantityQualifier - not checked)
            </summary>
        </member>
        <member name="M:Abodit.Units.Quantity`1.Multiply(System.Double)">
            <summary>
            Scale up by a factor
            </summary>
        </member>
        <member name="M:Abodit.Units.Quantity`1.op_Multiply(Abodit.Units.Quantity{`0},System.Double)">
            <summary>
            Multiply a <see cref="T:Abodit.Units.Quantity`1"/> by a constant
            </summary>
        </member>
        <member name="M:Abodit.Units.Quantity`1.op_Multiply(System.Double,Abodit.Units.Quantity{`0})">
            <summary>
            Multiply a <see cref="T:Abodit.Units.Quantity`1"/> by a constant
            </summary>
        </member>
        <member name="M:Abodit.Units.Quantity`1.op_Addition(Abodit.Units.Quantity{`0},Abodit.Units.Quantity{`0})">
            <summary>
            Add two <see cref="T:Abodit.Units.Quantity`1"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Quantity`1.CreateWithSameScale(System.Double)">
            <summary>
            Create a value with the same underlying scale (e.g. 4 on 1km -> 4km)
            </summary>
        </member>
        <member name="M:Abodit.Units.Quantity`1.Equals(`0)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Units.Quantity`1.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Units.Quantity`1.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="M:Abodit.Units.Quantity`1.CompareTo(`0)">
            <summary>
            IComparable implementation compares two quantities using the canonical unit
            </summary>
        </member>
        <member name="M:Abodit.Units.Quantity`1.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="P:Abodit.Units.Quantity`1.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Quantity`1.InMetric">
            <summary>
            Convert to metric using appropriate units
            </summary>
        </member>
        <member name="M:Abodit.Units.Quantity`1.InImperial">
            <summary>
            Convert to imperial using appropriate units
            </summary>
        </member>
        <member name="M:Abodit.Units.Quantity`1.DoDescribe(System.Boolean,System.Int32)">
            <summary>
            Describe this quanitity in text
            </summary>
        </member>
        <member name="M:Abodit.Units.Quantity`1.CreateDescription(Abodit.Expressions.TokenExpressionUnits,System.Nullable{System.Int32})">
            <summary>
            Creates the description
            </summary>
        </member>
        <member name="M:Abodit.Units.Quantity`1.DescribeUsingMagnitudes(System.String)">
            <summary>
            Creates the description using magnitudes
            </summary>
        </member>
        <member name="T:Abodit.Units.QuantityComponent">
            <summary>
            A single component of a quantity with an IUnit
            </summary>
            <remarks>
            A quantity may have multiple components provided they have the same dimension
            e.g. 5 miles, 3 feet, 6 inches
            </remarks>
        </member>
        <member name="F:Abodit.Units.QuantityComponent.Amount">
            <summary>
            Gets the amount
            </summary>
        </member>
        <member name="P:Abodit.Units.QuantityComponent.Unit">
            <summary>
            The unit for this component
            </summary>
        </member>
        <member name="P:Abodit.Units.QuantityComponent.Dimension">
            <summary>
            The Dimension of the IUnit for this component of a quantity
            </summary>
        </member>
        <member name="P:Abodit.Units.QuantityComponent.ValueInCanonicalUnit">
            <summary>
            Get the valud in the canonical unit
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityComponent.#ctor(System.Double,Abodit.Units.IUnit)">
            <summary>
            Create a new instance of the QuantityComponent class, e.g. 5 kg
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityComponent.Convert(Abodit.Units.IUnit)">
            <summary>
            Convert a component of a quantity into another unit using forward and reverse canonicalization
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityComponent.Add(Abodit.Units.QuantityComponent)">
            <summary>
            Add two components of Quantity, preserving the unit where possible or going for the larger unit
            if not. Checks that the quantity components have the same dimension.
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityComponent.Multiply(System.Double)">
            <summary>
            Scale up by a factor
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityComponent.op_Multiply(Abodit.Units.QuantityComponent,System.Double)">
            <summary>
            Multiply a <see cref="T:Abodit.Units.QuantityComponent"/> by a constant
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityComponent.op_Division(Abodit.Units.QuantityComponent,System.Double)">
            <summary>
            Divide a <see cref="T:Abodit.Units.QuantityComponent"/> by a constant
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityComponent.op_Multiply(System.Double,Abodit.Units.QuantityComponent)">
            <summary>
            Multiply a Quantity component by a constant
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityComponent.op_Addition(Abodit.Units.QuantityComponent,Abodit.Units.QuantityComponent)">
            <summary>
            Add two <see cref="T:Abodit.Units.QuantityComponent"/> values
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityComponent.op_Subtraction(Abodit.Units.QuantityComponent,Abodit.Units.QuantityComponent)">
            <summary>
            Subtract two <see cref="T:Abodit.Units.QuantityComponent"/> values
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityComponent.op_UnaryNegation(Abodit.Units.QuantityComponent)">
            <summary>
            Unary minus of a <see cref="T:Abodit.Units.QuantityComponent"/> value
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityComponent.CreateWithSameScale(System.Double)">
            <summary>
            Create a value with the same underlying scale (e.g. 4 on 1km -> 4km)
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityComponent.Equals(Abodit.Units.QuantityComponent)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityComponent.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityComponent.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityComponent.CompareTo(Abodit.Units.QuantityComponent)">
            <summary>
            Compare two <see cref="T:Abodit.Units.QuantityComponent"/> values
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityComponent.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityComponent.Describe(System.Boolean)">
            <summary>
            Describe this object as the amount and unit
            </summary>
        </member>
        <member name="T:Abodit.Units.QuantityDirectionQualifier">
            <summary>
            Describes a quantity (TBD whether I will use this class. FieldTypes already specify what type of distance they are)
            </summary>
        </member>
        <member name="P:Abodit.Units.QuantityDirectionQualifier.Name">
            <summary>
            Gets the name
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityDirectionQualifier.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="F:Abodit.Units.QuantityDirectionQualifier.None">
            <summary>
            No quantity direction qualifier
            </summary>
        </member>
        <member name="F:Abodit.Units.QuantityDirectionQualifier.Length">
            <summary>
            A QuantityDirection in any direction
            </summary>
        </member>
        <member name="F:Abodit.Units.QuantityDirectionQualifier.Position">
            <summary>
            A QuantityDirection for position
            </summary>
        </member>
        <member name="F:Abodit.Units.QuantityDirectionQualifier.Perimiter">
            <summary>
            A QuantityDirection for a perimiter
            </summary>
        </member>
        <member name="F:Abodit.Units.QuantityDirectionQualifier.Thickness">
            <summary>
            A QuantityDirection for a thickness
            </summary>
        </member>
        <member name="F:Abodit.Units.QuantityDirectionQualifier.Wavelength">
            <summary>
            A QuantityDirection for a wavelength
            </summary>
        </member>
        <member name="F:Abodit.Units.QuantityDirectionQualifier.Wavenumber">
            <summary>
            A QuantityDirection for a wavenumber
            </summary>
        </member>
        <member name="F:Abodit.Units.QuantityDirectionQualifier.Curvature">
            <summary>
            A QuantityDirection for a curvature
            </summary>
        </member>
        <member name="F:Abodit.Units.QuantityDirectionQualifier.Convergence">
            <summary>
            A QuantityDirection for a convergence (dioptre)
            </summary>
        </member>
        <member name="F:Abodit.Units.QuantityDirectionQualifier.Attenuation">
            <summary>
            A QuantityDirection for attenuation
            </summary>
        </member>
        <member name="T:Abodit.Units.QuantityQualifier">
            <summary>
            Describes a quantity
            </summary>
        </member>
        <member name="P:Abodit.Units.QuantityQualifier.Name">
            <summary>
            Gets the Name
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityQualifier.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="F:Abodit.Units.QuantityQualifier.None">
            <summary>
            No QuantityQualifier
            </summary>
        </member>
        <member name="F:Abodit.Units.QuantityQualifier.Average">
            <summary>
            The Quantity is an Average
            </summary>
        </member>
        <member name="F:Abodit.Units.QuantityQualifier.Minimum">
            <summary>
            The Quantity is an Minimum
            </summary>
        </member>
        <member name="F:Abodit.Units.QuantityQualifier.Maximum">
            <summary>
            The Quantity is a Maximum
            </summary>
        </member>
        <member name="F:Abodit.Units.QuantityQualifier.Differential">
            <summary>
            The Quantity is a Differential
            </summary>
        </member>
        <member name="F:Abodit.Units.QuantityQualifier.Internal">
            <summary>
            The Quantity is an internal measurement
            </summary>
        </member>
        <member name="F:Abodit.Units.QuantityQualifier.External">
            <summary>
            The Quantity is an external measurement
            </summary>
        </member>
        <member name="F:Abodit.Units.QuantityQualifier.Inside">
            <summary>
            The Quantity is an inside measurement
            </summary>
        </member>
        <member name="F:Abodit.Units.QuantityQualifier.Outside">
            <summary>
            The Quantity is an outside measurement
            </summary>
        </member>
        <member name="T:Abodit.Units.QuantityVectorBase`2">
            <summary>
            The base for any class with units that are a vector (e.g. Currency, Collections of disparate things, ...)
            </summary>
        </member>
        <member name="F:Abodit.Units.QuantityVectorBase`2.components">
            <summary>
            Gets the components of this <see cref="T:Abodit.Units.QuantityVectorBase`2"/>
            </summary>
        </member>
        <member name="P:Abodit.Units.QuantityVectorBase`2.Components">
            <summary>
            Gets the components of this vector
            </summary>
        </member>
        <member name="P:Abodit.Units.QuantityVectorBase`2.ValueInCanonicalUnit">
            <summary>
            The value for a vector for comparisons should probably be the distance in n-space where that's possible
            but what about Currency? Would need to convert each to same currency... ISSUE need to know more about
            the units of the components of the Vector
            TODO: Fix this issue with vector components
            </summary>
        </member>
        <member name="P:Abodit.Units.QuantityVectorBase`2.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityVectorBase`2.#ctor(Abodit.Units.IUnit)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.QuantityVectorBase`2"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityVectorBase`2.#ctor(`1,System.Double,Abodit.Units.IUnit)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.QuantityVectorBase`2"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityVectorBase`2.#ctor(System.Collections.Generic.IDictionary{`1,System.Double},Abodit.Units.IUnit)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.QuantityVectorBase`2"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityVectorBase`2.Multiply(System.Double)">
            <summary>
            Returns a new <see cref="T:Abodit.Units.QuantityVectorBase`2"/> after multiplying by a constant
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityVectorBase`2.Create(System.Collections.Generic.IDictionary{`1,System.Double})">
            <summary>
            Creates a new <see cref="T:Abodit.Units.QuantityVectorBase`2"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityVectorBase`2.Add(`0)">
            <summary>
            Adds two <see cref="T:Abodit.Units.QuantityVectorBase`2"/> values
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityVectorBase`2.CreateWithSameScale(System.Double)">
            <summary>
            Create a similar value with the same scale replacing each value with the passed in value
            (Does not make sense for disparate values, e.g. GBP2, USD3 => GBP4, USD4
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityVectorBase`2.DoDescribe(System.Boolean,System.Int32)">
            <summary>
            Describe a TokenExpressionUnits
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityVectorBase`2.CompareTo(`0)">
            <summary>
            Compares two <see cref="T:Abodit.Units.QuantityVectorBase`2"/> if they have the same symbol
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityVectorBase`2.Equals(`0)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityVectorBase`2.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityVectorBase`2.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="M:Abodit.Units.QuantityVectorBase`2.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Units.Rackspace">
            <summary>
            A RackspaceUnit
            </summary>
        </member>
        <member name="M:Abodit.Units.Rackspace.#ctor">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Units.Rackspace"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Rackspace.#ctor(System.Double)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Units.Rackspace"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Rackspace.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Units.Rackspace"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Rackspace.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Units.Rackspace"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Rackspace.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="F:Abodit.Units.Rackspace.One">
            <summary>
            One RU
            </summary>
        </member>
        <member name="F:Abodit.Units.Rackspace.Two">
            <summary>
            Two RU
            </summary>
        </member>
        <member name="F:Abodit.Units.Rackspace.Three">
            <summary>
            Three RU
            </summary>
        </member>
        <member name="F:Abodit.Units.Rackspace.Zero">
            <summary>
            Zero RU
            </summary>
        </member>
        <member name="T:Abodit.Units.IRange`1">
            <summary>
            A marker interface used for programatically created ranges that aren't concrete types
            </summary>
        </member>
        <member name="T:Abodit.Units.Range`1">
            <summary>
            A range of values of type T
            </summary>
        </member>
        <member name="P:Abodit.Units.Range`1.Min">
            <summary>
            The minimum value in the range
            </summary>
        </member>
        <member name="P:Abodit.Units.Range`1.Max">
            <summary>
            The maximum value in the range
            </summary>
        </member>
        <member name="P:Abodit.Units.Range`1.Dimension">
            <summary>
            Get the dimension for this range
            </summary>
        </member>
        <member name="F:Abodit.Units.Range`1.Empty">
            <summary>
            Special sentinel value
            </summary>
        </member>
        <member name="M:Abodit.Units.Range`1.#ctor(`0,`0,System.Boolean,System.Boolean,Abodit.Units.Dimensions.Interpretation)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Units.Range`1"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Range`1.BetweenInclusive(`0,`0,Abodit.Units.Dimensions.Interpretation)">
            <summary>
            Between Inclusive
            </summary>
        </member>
        <member name="M:Abodit.Units.Range`1.BetweenExclusive(`0,`0,Abodit.Units.Dimensions.Interpretation)">
            <summary>
            Between Exclusive
            </summary>
        </member>
        <member name="M:Abodit.Units.Range`1.AtMost(`0,Abodit.Units.Dimensions.Interpretation)">
            <summary>
            AtMost
            </summary>
        </member>
        <member name="M:Abodit.Units.Range`1.AtLeast(`0,Abodit.Units.Dimensions.Interpretation)">
            <summary>
            AtLeast
            </summary>
        </member>
        <member name="M:Abodit.Units.Range`1.LessThan(`0,Abodit.Units.Dimensions.Interpretation)">
            <summary>
            A range with an upper limit
            </summary>
        </member>
        <member name="M:Abodit.Units.Range`1.GreaterThan(`0,Abodit.Units.Dimensions.Interpretation)">
            <summary>
            A range with a lower limit
            </summary>
        </member>
        <member name="M:Abodit.Units.Range`1.Everything(Abodit.Units.Dimensions.Interpretation)">
            <summary>
            An unbounded range
            </summary>
        </member>
        <member name="M:Abodit.Units.Range`1.Create(`0,`0,System.Boolean,System.Boolean,Abodit.Units.Dimensions.Interpretation)">
            <summary>
            Create a range
            </summary>
        </member>
        <member name="M:Abodit.Units.Range`1.Contains(`0)">
            <summary>
            Contains another range
            </summary>
        </member>
        <member name="M:Abodit.Units.Range`1.Intersects(Abodit.Units.Range{`0})">
            <summary>
            Intersects another range
            </summary>
        </member>
        <member name="M:Abodit.Units.Range`1.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Units.Range`1.Equals(Abodit.Units.Range{`0})">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Units.Range`1.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Units.Range`1.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Units.Range`1.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="M:Abodit.Units.Range`1.Clone(Abodit.Units.Dimensions.Interpretation)">
            <summary>
            Clone
            </summary>
        </member>
        <member name="T:Abodit.Units.Rate">
            <summary>
            A rate per period of time
            </summary>
        </member>
        <member name="M:Abodit.Units.Rate.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.Rate"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Rate.#ctor(Abodit.Units.TimePeriod,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.Rate"/> class
            </summary>
        </member>
        <member name="P:Abodit.Units.Rate.TimePeriod">
            <summary>
            Gets the time period
            </summary>
        </member>
        <member name="M:Abodit.Units.Rate.Create(Abodit.Units.TimePeriod)">
            <summary>
            Create a new Rate as 1 / TimePeriod
            </summary>
        </member>
        <member name="F:Abodit.Units.Rate.OnePerSecond">
            <summary>
            One per second
            </summary>
        </member>
        <member name="F:Abodit.Units.Rate.OnePerMinute">
            <summary>
            One per minute
            </summary>
        </member>
        <member name="F:Abodit.Units.Rate.OnePerHour">
            <summary>
            One per hour
            </summary>
        </member>
        <member name="F:Abodit.Units.Rate.OnePerDay">
            <summary>
            One per day
            </summary>
        </member>
        <member name="F:Abodit.Units.Rate.OnePerWeek">
            <summary>
            One per week
            </summary>
        </member>
        <member name="F:Abodit.Units.Rate.OnePerMonth">
            <summary>
            One per month
            </summary>
        </member>
        <member name="F:Abodit.Units.Rate.OnePerQuarter">
            <summary>
            One per quarter year
            </summary>
        </member>
        <member name="F:Abodit.Units.Rate.OnePerHalf">
            <summary>
            One per half year
            </summary>
        </member>
        <member name="F:Abodit.Units.Rate.OnePerYear">
            <summary>
            One per year
            </summary>
        </member>
        <member name="P:Abodit.Units.Rate.PerSecond">
            <summary>
            Get the per second rate
            </summary>
        </member>
        <member name="P:Abodit.Units.Rate.PerMinute">
            <summary>
            Get the per minute rate
            </summary>
        </member>
        <member name="P:Abodit.Units.Rate.PerHour">
            <summary>
            Get the per hour rate
            </summary>
        </member>
        <member name="P:Abodit.Units.Rate.PerDay">
            <summary>
            Get the per day rate
            </summary>
        </member>
        <member name="M:Abodit.Units.Rate.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Create a new Rate
            </summary>
        </member>
        <member name="M:Abodit.Units.Rate.DoDescribe(System.Boolean,System.Int32)">
            <summary>
            Describe method for units (special case)
            </summary>
        </member>
        <member name="T:Abodit.Units.RatingUnit">
            <summary>
            A measure of rating (stars)
            </summary>
        </member>
        <member name="M:Abodit.Units.RatingUnit.#ctor">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Units.RatingUnit"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.RatingUnit.#ctor(System.Double)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Units.RatingUnit"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.RatingUnit.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Units.UsersUnit"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.RatingUnit.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Units.RatingUnit"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.RatingUnit.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Units.RatingUnit"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.RatingUnit.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Units.RatingUnit.DoDescribe(System.Boolean,System.Int32)">
            <summary>
            Describe this TokenExpressionUnits
            </summary>
        </member>
        <member name="F:Abodit.Units.RatingUnit.One">
            <summary>
            One user
            </summary>
        </member>
        <member name="P:Abodit.Units.RatingUnit.Stars">
            <summary>
            Gets a number of stars
            </summary>
        </member>
        <member name="T:Abodit.Units.Temperature">
            <summary>
            A Temperature value
            </summary>
        </member>
        <member name="P:Abodit.Units.Temperature.Celcius">
            <summary>
            Temperature in celcius
            </summary>
        </member>
        <member name="P:Abodit.Units.Temperature.Farenheight">
            <summary>
            Temperature in farenheight
            </summary>
        </member>
        <member name="M:Abodit.Units.Temperature.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Temperature"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Temperature.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Temperature"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Temperature.CreateStatic(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Temperature"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Temperature.Farenheit(System.Double)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Temperature"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Temperature.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Units.Temperature.InMetric">
            <summary>
            Convert to metric using appropriate units
            </summary>
        </member>
        <member name="M:Abodit.Units.Temperature.InImperial">
            <summary>
            Convert to imperial using appropriate units
            </summary>
        </member>
        <member name="M:Abodit.Units.Temperature.DoDescribe(System.Boolean,System.Int32)">
            <summary>
            Describes this valye using the appropriate unit
            </summary>
        </member>
        <member name="F:Abodit.Units.Temperature.OneCelcius">
            <summary>
            A unit of one Celcius
            </summary>
        </member>
        <member name="F:Abodit.Units.Temperature.OneFarenheit">
            <summary>
            A unit of one Farenheit
            </summary>
        </member>
        <member name="F:Abodit.Units.Temperature.OneKelvin">
            <summary>
            A unit of one Kelvin
            </summary>
        </member>
        <member name="T:Abodit.Units.TimePeriod">
            <summary>
            A TimePeriod is like a TimeSpan but better because it can handle weeks, months, ... and it knows how granular it is
            </summary>
        </member>
        <member name="P:Abodit.Units.TimePeriod.Millennia">
            <summary>
            Gets the Millennia component
            </summary>
        </member>
        <member name="P:Abodit.Units.TimePeriod.Centuries">
            <summary>
            Gets the Centuries component
            </summary>
        </member>
        <member name="P:Abodit.Units.TimePeriod.Decades">
            <summary>
            Gets the Decades component
            </summary>
        </member>
        <member name="P:Abodit.Units.TimePeriod.Years">
            <summary>
            Gets the Years component
            </summary>
        </member>
        <member name="P:Abodit.Units.TimePeriod.Halves">
            <summary>
            Gets the halves component
            </summary>
        </member>
        <member name="P:Abodit.Units.TimePeriod.Quarters">
            <summary>
            Gets the quarters component
            </summary>
        </member>
        <member name="P:Abodit.Units.TimePeriod.Months">
            <summary>
            Gets the months component
            </summary>
        </member>
        <member name="P:Abodit.Units.TimePeriod.Weeks">
            <summary>
            Gets the weeks component
            </summary>
        </member>
        <member name="P:Abodit.Units.TimePeriod.Days">
            <summary>
            Gets the days component
            </summary>
        </member>
        <member name="P:Abodit.Units.TimePeriod.Hours">
            <summary>
            Gets the hours component
            </summary>
        </member>
        <member name="P:Abodit.Units.TimePeriod.Minutes">
            <summary>
            Gets the minutes component
            </summary>
        </member>
        <member name="P:Abodit.Units.TimePeriod.Seconds">
            <summary>
            Gets the seconds component
            </summary>
        </member>
        <member name="P:Abodit.Units.TimePeriod.Milliseconds">
            <summary>
            Gets the milliseconds component
            </summary>
        </member>
        <member name="P:Abodit.Units.TimePeriod.ValueInCanonicalUnit">
            <summary>
            Gets the value in seconds
            </summary>
        </member>
        <member name="P:Abodit.Units.TimePeriod.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.From(System.TimeSpan)">
            <summary>
            Create a TimePeriod from a TimeSpan - ignores some possibilities like partial weeks
            Canonicalizes the result
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Create a new instance of a <see cref="T:Abodit.Units.TimePeriod"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.Deserialize(System.String)">
            <summary>
            Read a TimePeriod from a string
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.Add(Abodit.Units.TimePeriod)">
            <summary>
            Add a TimePeriod (canonicalize it afterwards if you want)
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.CreateWithSameScale(System.Double)">
            <summary>
            Create another TimePeriod with the same scale
            </summary>
        </member>
        <member name="P:Abodit.Units.TimePeriod.TotalMilliseconds">
            <summary>
            Get the total number of milliseconds in this TimePeriod
            </summary>
        </member>
        <member name="P:Abodit.Units.TimePeriod.TimeSpanApproximate">
            <summary>
            An approximate time span for this TimePeriod (approximate because we don't know which months it covers if it has months)
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.Multiply(System.Double)">
            <summary>
            Multiply this time period by a factor preserving the units
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.UnitOneMillennium">
            <summary>
            A unit of one thousand years
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.UnitOneCentury">
            <summary>
            A unit of one hundred years
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.UnitOneDecade">
            <summary>
            A unit of ten years
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.UnitOneYear">
            <summary>
            A unit of one year
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.UnitOneHalf">
            <summary>
            A unit of one half
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.UnitOneQuarter">
            <summary>
            A unit of one quarter
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.UnitOneMonth">
            <summary>
            A unit of one month
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.UnitOneWeek">
            <summary>
            A unit of one week
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.UnitOneDay">
            <summary>
            A unit of one day
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.UnitOneHour">
            <summary>
            A unit of one hour
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.UnitOneMinute">
            <summary>
            A unit of one minute
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.UnitOneSecond">
            <summary>
            A unit of one second
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.Zero">
            <summary>
            A TimePeriod of Zero
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.OneMillennium">
            <summary>
            A TimePeriod of one millennium
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.OneCentury">
            <summary>
            A TimePeriod of one century
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.OneDecade">
            <summary>
            A TimePeriod of one decade
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.OneYear">
            <summary>
            A TimePeriod of one year
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.OneHalf">
            <summary>
            A TimePeriod of one month
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.OneQuarter">
            <summary>
            A TimePeriod of one month
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.OneMonth">
            <summary>
            A TimePeriod of one month
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.TwoMonths">
            <summary>
            A TimePeriod of two months
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.ThreeMonths">
            <summary>
            A TimePeriod of three months
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.FourMonths">
            <summary>
            A TimePeriod of four months
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.OneWeek">
            <summary>
            A TimePeriod of one week
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.TwoWeeks">
            <summary>
            A TimePeriod of two weeks
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.ThreeWeeks">
            <summary>
            A TimePeriod of thee weeks
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.FourWeeks">
            <summary>
            A TimePeriod of four weeks
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.FiveWeeks">
            <summary>
            A TimePeriod of five weeks
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.SixWeeks">
            <summary>
            A TimePeriod of six weeks
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.SevenWeeks">
            <summary>
            A TimePeriod of seven weeks
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.EightWeeks">
            <summary>
            A TimePeriod of eight weeks
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.NineWeeks">
            <summary>
            A TimePeriod of nine weeks
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.TenWeeks">
            <summary>
            A TimePeriod of ten weeks
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.OneDay">
            <summary>
            A TimePeriod of one day
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.TwoDays">
            <summary>
            A TimePeriod of two days
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.FiveDays">
            <summary>
            A TimePeriod of five days
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.OneHour">
            <summary>
            A TimePeriod of one hour
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.TwoHours">
            <summary>
            A TimePeriod of two hours
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.ThreeHours">
            <summary>
            A TimePeriod of three hours
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.FourHours">
            <summary>
            A TimePeriod of four hours
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.FiveHours">
            <summary>
            A TimePeriod of five hours
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.SixHours">
            <summary>
            A TimePeriod of six hours
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.SevenHours">
            <summary>
            A TimePeriod of seven hours
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.EightHours">
            <summary>
            A TimePeriod of eight hours
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.NineHours">
            <summary>
            A TimePeriod of nine hours
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.TenHours">
            <summary>
            A TimePeriod of ten hours
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.ElevenHours">
            <summary>
            A TimePeriod of eleven hours
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.TwelveHours">
            <summary>
            A TimePeriod of twelve hours
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.TwentyFourHours">
            <summary>
            A TimePeriod of twenty four hours
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.OneMinute">
            <summary>
            A TimePeriod of one minute
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.TwoMinutes">
            <summary>
            A TimePeriod of two minutes
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.FiveMinutes">
            <summary>
            A TimePeriod of five minutes
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.TenMinutes">
            <summary>
            A TimePeriod of ten minutes
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.OneSecond">
            <summary>
            A TimePeriod of one second
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.TwoSeconds">
            <summary>
            A TimePeriod of two seconds
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.FiveSeconds">
            <summary>
            A TimePeriod of five seconds
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.TenSeconds">
            <summary>
            A TimePeriod of ten seconds
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.OneMillisecond">
            <summary>
            A TimePeriod of one millisecond
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.TenMilliseconds">
            <summary>
            A TimePeriod of ten milliseconds
            </summary>
        </member>
        <member name="F:Abodit.Units.TimePeriod.HundredMilliseconds">
            <summary>
            A TimePeriod of one hundred milliseconds
            </summary>
        </member>
        <member name="P:Abodit.Units.TimePeriod.Granularity">
            <summary>
            The granularity of a time unit is how much you move on to go back or forward by one of these
            </summary>
            <remarks>
            public setter only because .NET XML serialization needs it
            </remarks>
        </member>
        <member name="F:Abodit.Units.TimePeriod.granularity">
            <summary>
            Delayed creation of Granularity because it uses TimePeriods as the granularity and they all need constructing first
            </summary>
        </member>
        <member name="P:Abodit.Units.TimePeriod.IntermediateTransformationOffset">
            <summary>
            Transforms a DateTimeOffset according to this defined amount of time (an integer number of times)
            </summary>
        </member>
        <member name="P:Abodit.Units.TimePeriod.IntermediateTransformationDateTime">
            <summary>
            Transforms a DateTime according to this defined amount of time (an integer number of times)
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.Transform(System.DateTime,System.Double)">
            <summary>
            Transform a DateTime n times using this TimePeriod (essentially adding it)
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.Transform(System.DateTimeOffset,System.Double)">
            <summary>
            Transform a DateTimeOffset n times using this TimePeriod (essentially adding it)
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.Abs">
            <summary>
            Absolute value of a TimePeriod
            </summary>
            <remarks>
            For example, 
                Abs( minus (one year minus one month) ) == one year minus one month
                Abs( minus (one year plus one month) ) == one year plus one month
                Abs( minus two months plus a week) == two months
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Abodit.Units.TimePeriod.op_UnaryNegation(Abodit.Units.TimePeriod)">
            <summary>
            Negate a time period
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.op_Addition(Abodit.Units.TimePeriod,Abodit.Units.TimePeriod)">
            <summary>
            Add two time periods
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.op_Subtraction(Abodit.Units.TimePeriod,Abodit.Units.TimePeriod)">
            <summary>
            Subtract two time periods
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.ToString(System.IFormatProvider)">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.SingularOrPlural(System.Double,System.String,System.String)">
            <summary>
            Singular, plural or empty depending on -1, 0, 1, other
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.DoDescribe(System.Boolean,System.Int32)">
            <summary>
            Describe a time period
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.Canonicalize">
            <summary>
            Convert the TimePeriod to a canonical form (e.g. 90 minutes vs 1 hour 30 minutes)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Abodit.Units.TimePeriod.CompareTo(Abodit.Units.TimePeriod)">
            <summary>
            DANGER: One month may be larger or smaller than 30 days but this will always say 1 month > any number of days!!!
            Hard to compare in the absence of knowing which day month or year we are discussing
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.FromTicks(System.Int64)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TimePeriod"/> from a tick value
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.op_Multiply(Abodit.Units.TimePeriod,System.Double)">
            <summary>
            Returns a new <see cref="T:Abodit.Units.TimePeriod"/> by multiplying this one by a constant, preserving scale
            </summary>
            <remarks>
            e.g. 2 weeks x 2 = 4 weeks
            </remarks>
        </member>
        <member name="M:Abodit.Units.TimePeriod.Equals(Abodit.Units.TimePeriod)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.GetTypeCode">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.ToBoolean(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.ToChar(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.ToSByte(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.ToByte(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.ToInt16(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.ToUInt16(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.ToInt32(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.ToUInt32(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.ToInt64(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.ToUInt64(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.ToSingle(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.ToDouble(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.ToDecimal(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.ToDateTime(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriod.ToType(System.Type,System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="T:Abodit.Units.TimePeriodMillennia">
            <summary>
            A TimePeriod with just millennia
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriodMillennia.#ctor(System.Double)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TimePeriod"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.TimePeriodCenturies">
            <summary>
            A TimePeriod with just centuries
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriodCenturies.#ctor(System.Double)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TimePeriod"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.TimePeriodDecades">
            <summary>
            A TimePeriod with just decades
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriodDecades.#ctor(System.Double)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TimePeriod"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.TimePeriodYears">
            <summary>
            A TimePeriod with just years
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriodYears.#ctor(System.Double)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TimePeriod"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.TimePeriodHalves">
            <summary>
            A TimePeriod with just halves
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriodHalves.#ctor(System.Double)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TimePeriod"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.TimePeriodQuarters">
            <summary>
            A TimePeriod with just quarters
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriodQuarters.#ctor(System.Double)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TimePeriod"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.TimePeriodMonths">
            <summary>
            A TimePeriod with just months
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriodMonths.#ctor(System.Double)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TimePeriod"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.TimePeriodWeeks">
            <summary>
            A TimePeriod with just weeks
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriodWeeks.#ctor(System.Double)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TimePeriod"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.TimePeriodDays">
            <summary>
            A TimePeriod with just days
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriodDays.#ctor(System.Double)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TimePeriod"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.TimePeriodHours">
            <summary>
            A TimePeriod with just hours
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriodHours.#ctor(System.Double)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TimePeriod"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.TimePeriodMinutes">
            <summary>
            A TimePeriod with just minutes
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriodMinutes.#ctor(System.Double)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TimePeriod"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.TimePeriodSeconds">
            <summary>
            A TimePeriod with just seconds
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriodSeconds.#ctor(System.Double)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TimePeriod"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.TimePeriodMilliseconds">
            <summary>
            A TimePeriod with just milliseconds
            </summary>
        </member>
        <member name="M:Abodit.Units.TimePeriodMilliseconds.#ctor(System.Double)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TimePeriod"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.TransactionRate">
            <summary>
            A rate of transactions
            </summary>
        </member>
        <member name="M:Abodit.Units.TransactionRate.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TransactionRate"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.TransactionRate.Create(System.Double,Abodit.Units.Rate,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TransactionRate"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.TransactionRate.Create(Abodit.Units.TransactionsUnit,Abodit.Units.TimePeriod,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TransactionRate"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.TransactionRate.Create(Abodit.Units.TransactionsUnit,Abodit.Units.Rate,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TransactionRate"/>
            </summary>
        </member>
        <member name="F:Abodit.Units.TransactionRate.OnePerDay">
            <summary>
            One transaction per day
            </summary>
        </member>
        <member name="F:Abodit.Units.TransactionRate.OnePerHour">
            <summary>
            One transaction per hour
            </summary>
        </member>
        <member name="F:Abodit.Units.TransactionRate.OnePerMinute">
            <summary>
            One transaction per minute
            </summary>
        </member>
        <member name="F:Abodit.Units.TransactionRate.OnePerSecond">
            <summary>
            One transaction per second
            </summary>
        </member>
        <member name="P:Abodit.Units.TransactionRate.RatePerSecond">
            <summary>
            Gets the rate per second
            </summary>
        </member>
        <member name="P:Abodit.Units.TransactionRate.RatePerMinute">
            <summary>
            Gets the rate per minute
            </summary>
        </member>
        <member name="P:Abodit.Units.TransactionRate.RatePerHour">
            <summary>
            Gets the rate per hour
            </summary>
        </member>
        <member name="P:Abodit.Units.TransactionRate.RatePerDay">
            <summary>
            Gets the rate per day
            </summary>
        </member>
        <member name="M:Abodit.Units.TransactionRate.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TransactionRate"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.TransactionsUnit">
            <summary>
            A measure of transactions
            </summary>
        </member>
        <member name="M:Abodit.Units.TransactionsUnit.#ctor">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TransactionsUnit"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.TransactionsUnit.#ctor(System.Double)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TransactionsUnit"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.TransactionsUnit.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TransactionsUnit"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.TransactionsUnit.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.TransactionsUnit"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.TransactionsUnit.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="F:Abodit.Units.TransactionsUnit.One">
            <summary>
            A transaction unit of one
            </summary>
        </member>
        <member name="P:Abodit.Units.TransactionsUnit.Transactions">
            <summary>
            Gets the number of transactions in the canonical unit (one)
            </summary>
        </member>
        <member name="T:Abodit.Units.Unitless">
            <summary>
            A scalar unit of unknown units (not an angle, ...)
            </summary>
        </member>
        <member name="M:Abodit.Units.Unitless.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates an instance of the <see cref="T:Abodit.Units.Unitless"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Unitless.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Unitless"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Unitless.ToString">
            <summary>
            Creates a string representation of this object
            </summary>
            <returns></returns>
        </member>
        <member name="F:Abodit.Units.Unitless.One">
            <summary>
            A Unitless IUnit having a mutliplier of 1
            </summary>
        </member>
        <member name="T:Abodit.Units.IUnitRegistry">
            <summary>
            Provides all the units defined in an Assembly
            </summary>
        </member>
        <member name="P:Abodit.Units.IUnitRegistry.AllUnits">
            <summary>
            Get all possible Units
            </summary>
        </member>
        <member name="T:Abodit.Units.UnitRegistry">
            <summary>
            A registry of all units that have been created (anywhere in the application)
            </summary>
        </member>
        <member name="P:Abodit.Units.UnitRegistry.AllUnits">
            <summary>
            All units (virtual so you can extend it)
            </summary>
        </member>
        <member name="F:Abodit.Units.UnitRegistry.allUnits">
            <summary>
            All units
            </summary>
        </member>
        <member name="M:Abodit.Units.UnitRegistry.GetOrCreate(Abodit.Units.Dimensions.Dimension,System.Double,System.String)">
            <summary>
            Get an existing unit with the same dimension and conversion factor
            or create a new one with the name given
            </summary>
        </member>
        <member name="M:Abodit.Units.UnitRegistry.IsCloseTo(System.Double,System.Double)">
            <summary>
            Are two values close to each other, used internally to create each unit only once
            </summary>
        </member>
        <member name="M:Abodit.Units.UnitRegistry.IdentityMap(Abodit.Units.Unit)">
            <summary>
            Identity map a unit
            </summary>
        </member>
        <member name="T:Abodit.Units.IQuantity">
            <summary>
            A quantity is a double value with a unit, e.g. 5.2 km
            </summary>
        </member>
        <member name="M:Abodit.Units.IQuantity.Describe(System.Boolean)">
            <summary>
            Creates a string that describes this quantity in metric or imperial units
            </summary>
        </member>
        <member name="P:Abodit.Units.IQuantity.ValueInCanonicalUnit">
            <summary>
            For a distance this would be meters
            </summary>
        </member>
        <member name="P:Abodit.Units.IQuantity.ValueDouble">
            <summary>
            Get the actual double value
            </summary>
        </member>
        <member name="P:Abodit.Units.IQuantity.Unit">
            <summary>
            Get the unit for this quantity
            </summary>
        </member>
        <member name="P:Abodit.Units.IQuantity.Dimension">
            <summary>
            Get the dimension for this quantity
            </summary>
        </member>
        <member name="T:Abodit.Units.IQuantity`1">
            <summary>
            A quantity of a given self-referencing type
            </summary>
        </member>
        <member name="M:Abodit.Units.IQuantity`1.Multiply(System.Double)">
            <summary>
            Multiply a quantity by a constant
            </summary>
        </member>
        <member name="M:Abodit.Units.IQuantity`1.Add(`0)">
            <summary>
            Add another quantity
            </summary>
        </member>
        <member name="M:Abodit.Units.IQuantity`1.CreateWithSameScale(System.Double)">
            <summary>
            Create a new Quanity with the same scale
            </summary>
        </member>
        <member name="T:Abodit.Units.IUnitPartial">
            <summary>
            A base unit with a name and a Format method
            </summary>
        </member>
        <member name="P:Abodit.Units.IUnitPartial.Name">
            <summary>
            Name of the unit
            </summary>
        </member>
        <member name="P:Abodit.Units.IUnitPartial.NamePlural">
            <summary>
            Plural name of the unit
            </summary>
        </member>
        <member name="M:Abodit.Units.IUnitPartial.Format(System.Double)">
            <summary>
            Format a double value with this unit
            </summary>
        </member>
        <member name="T:Abodit.Units.IUnit">
            <summary>
            A unit, like meters, kilogrammes, amps, ...
            </summary>
        </member>
        <member name="P:Abodit.Units.IUnit.CanonicalizeTokenExpression">
            <summary>
            An expression that can be applied to a value (from a database) to get the value in canonical units
            e.g. x => x-32 * 5/9
            </summary>
        </member>
        <member name="P:Abodit.Units.IUnit.InverseCanonicalizeTokenExpression">
            <summary>
            An expression that undoes the canonicalization function, e.g. x=> x * 9/5 + 32
            </summary>
        </member>
        <member name="P:Abodit.Units.IUnit.Canonicalize">
            <summary>
            A function to convert this value to canonical units
            </summary>
        </member>
        <member name="P:Abodit.Units.IUnit.InverseCanonicalize">
            <summary>
            A function to convert from canonical units to this units
            </summary>
        </member>
        <member name="P:Abodit.Units.IUnit.Names">
            <summary>
            Alternative names
            </summary>
        </member>
        <member name="P:Abodit.Units.IUnit.Dimension">
            <summary>
            A unit has a dimension. It only makes sense to compare quantities having the same dimension.
            It may also make sense to group displays by Dimension when trying to display a lot of units
            </summary>
        </member>
        <member name="M:Abodit.Units.IUnit.CompareTo(Abodit.Units.IUnit)">
            <summary>
            If the units are comparable in some way compares them by sort order
            </summary>
        </member>
        <member name="P:Abodit.Units.IUnit.Scale">
            <summary>
            For Units with no offset, a Scale value is provided
            </summary>
        </member>
        <member name="M:Abodit.Units.IUnit.MakesSenseFor(System.Double)">
            <summary>
            Is this a good unit to represent the given canonical value
            </summary>
        </member>
        <member name="P:Abodit.Units.IUnit.IsMetric">
            <summary>
            Is this a metric unit of measure?
            </summary>
        </member>
        <member name="P:Abodit.Units.IUnit.Create">
            <summary>
            Create a <see cref="T:Abodit.Expressions.TokenExpressionUnits"/> for this Unit of measure
            </summary>
        </member>
        <member name="T:Abodit.Units.Unit">
            <summary>
            A Unit, e.g. miles, kilometers, grammes, IOPS, Hz, celcius, ...
            </summary>
            <remarks>
            Units can convert to and from each other IF they have the same Dimension
            </remarks>
        </member>
        <member name="P:Abodit.Units.Unit.CanonicalizeTokenExpression">
            <summary>
            A factory to create an expression that converts a value in this unit to the canonical unit value (e.g. meters from miles)
            </summary>
        </member>
        <member name="P:Abodit.Units.Unit.InverseCanonicalizeTokenExpression">
            <summary>
            A factory to create an expression that converts a value from the canonical unit to this unit (e.g. meters to miles)
            </summary>
        </member>
        <member name="P:Abodit.Units.Unit.Canonicalize">
            <summary>
            Convert a value in this unit to the canonical unit value (e.g. meters from miles)
            </summary>
        </member>
        <member name="P:Abodit.Units.Unit.InverseCanonicalize">
            <summary>
            Convert a value from the canonical unit to this unit (e.g. meters to miles)
            </summary>
        </member>
        <member name="P:Abodit.Units.Unit.Create">
            <summary>
            Create a <see cref="T:Abodit.Expressions.TokenExpressionUnits"/> for this Unit of measure
            </summary>
        </member>
        <member name="P:Abodit.Units.Unit.Scale">
            <summary>
            For canonicalization that has no offset, a simple scale
            </summary>
        </member>
        <member name="M:Abodit.Units.Unit.MakesSenseFor(System.Double)">
            <summary>
            Does the value passed in make sense expressed in these units
            </summary>
        </member>
        <member name="P:Abodit.Units.Unit.Name">
            <summary>
            Display name for a unit (e.g. 'kg')
            </summary>
        </member>
        <member name="P:Abodit.Units.Unit.NamePlural">
            <summary>
            Plural display name for a unit (e.g. 'miles')
            </summary>
        </member>
        <member name="P:Abodit.Units.Unit.Dimension">
            <summary>
            A quantity has a dimension. It only makes sense to compare quantities having the same dimension.
            </summary>
        </member>
        <member name="P:Abodit.Units.Unit.IsMetric">
            <summary>
            Is this a metric unit of measure?
            </summary>
        </member>
        <member name="M:Abodit.Units.Unit.CompareTo(Abodit.Units.IUnit)">
            <summary>
            Compare to another unit (which represents more of the quantity)
            </summary>
        </member>
        <member name="M:Abodit.Units.Unit.#ctor(System.Double,System.String,System.String,Abodit.Units.Dimensions.Dimension,System.Boolean,System.Func{System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier,Abodit.Expressions.TokenExpressionUnits})">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Units.Unit"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Unit.#ctor(System.Double,System.Double,System.String,System.String,Abodit.Units.Dimensions.Dimension,System.Boolean,System.Func{System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier,Abodit.Expressions.TokenExpressionUnits})">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Units.Unit"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Unit.#ctor(System.String,System.String,Abodit.Units.Dimensions.Dimension,System.Boolean,System.Func{Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression},System.Func{Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression},System.Func{System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier,Abodit.Expressions.TokenExpressionUnits})">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Units.Unit"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Unit.ForScaleAndOffset(System.Double,System.Double)">
            <summary>
            Get an expression that scales a value and adds an offset
            but simplified for cases where scale is 1 and/or offset is zero
            </summary>
        </member>
        <member name="M:Abodit.Units.Unit.ForInverseScaleAndOffset(System.Double,System.Double)">
            <summary>
            Get an inverse expression that scales a value and adds an offset
            but simplified for cases where scale is 1 and/or offset is zero
            </summary>
        </member>
        <member name="M:Abodit.Units.Unit.Equals(Abodit.Units.Unit)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Units.Unit.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Units.Unit.Format(System.Double)">
            <summary>
            Format a double value with this unit
            </summary>
        </member>
        <member name="P:Abodit.Units.Unit.Names">
            <summary>
            Gets all possible names for this Unit
            </summary>
        </member>
        <member name="T:Abodit.Units.UnitSet">
            <summary>
            A standard set of SI units
            </summary>
            <remarks>
            Automatically handles pico, nano, milli, micro, kilo, mega etc.
            </remarks>
        </member>
        <member name="P:Abodit.Units.UnitSet.Femto">
            <summary>
            Femto
            </summary>
        </member>
        <member name="P:Abodit.Units.UnitSet.Nano">
            <summary>
            Nano
            </summary>
        </member>
        <member name="P:Abodit.Units.UnitSet.Pico">
            <summary>
            Pico
            </summary>
        </member>
        <member name="P:Abodit.Units.UnitSet.Micro">
            <summary>
            Micro
            </summary>
        </member>
        <member name="P:Abodit.Units.UnitSet.Milli">
            <summary>
            Milli
            </summary>
        </member>
        <member name="P:Abodit.Units.UnitSet.Centi">
            <summary>
            Centi
            </summary>
        </member>
        <member name="P:Abodit.Units.UnitSet.Deci">
            <summary>
            Deci
            </summary>
        </member>
        <member name="P:Abodit.Units.UnitSet.One">
            <summary>
            One
            </summary>
        </member>
        <member name="P:Abodit.Units.UnitSet.Deca">
            <summary>
            Deca
            </summary>
        </member>
        <member name="P:Abodit.Units.UnitSet.Hecto">
            <summary>
            Hecto
            </summary>
        </member>
        <member name="P:Abodit.Units.UnitSet.Kilo">
            <summary>
            Kilo
            </summary>
        </member>
        <member name="P:Abodit.Units.UnitSet.Mega">
            <summary>
            Mega
            </summary>
        </member>
        <member name="P:Abodit.Units.UnitSet.Giga">
            <summary>
            Giga
            </summary>
        </member>
        <member name="P:Abodit.Units.UnitSet.Terra">
            <summary>
            Terra
            </summary>
        </member>
        <member name="P:Abodit.Units.UnitSet.Peta">
            <summary>
            Peta
            </summary>
        </member>
        <member name="P:Abodit.Units.UnitSet.Exa">
            <summary>
            Exa
            </summary>
        </member>
        <member name="P:Abodit.Units.UnitSet.Zetta">
            <summary>
            Zetta
            </summary>
        </member>
        <member name="P:Abodit.Units.UnitSet.Yotta">
            <summary>
            Yotta
            </summary>
        </member>
        <member name="M:Abodit.Units.UnitSet.#ctor(System.String,Abodit.Units.Dimensions.Dimension,System.Func{System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier,Abodit.Expressions.TokenExpressionUnits})">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.UnitSet"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.UnitSet.GetEnumerator">
            <summary>
            IEnumerable implementation
            </summary>
        </member>
        <member name="T:Abodit.Units.UserType">
            <summary>
            The type of a user
            </summary>
            <remarks>
            This is an experimental class, not intended for consumption yet
            </remarks>
        </member>
        <member name="F:Abodit.Units.UserType.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:Abodit.Units.UserType.Named">
            <summary>
            Named
            </summary>
        </member>
        <member name="F:Abodit.Units.UserType.Active">
            <summary>
            Active
            </summary>
        </member>
        <member name="F:Abodit.Units.UserType.Concurrent">
            <summary>
            Concurrent
            </summary>
        </member>
        <member name="F:Abodit.Units.UserType.Deleted">
            <summary>
            Deleted
            </summary>
        </member>
        <member name="F:Abodit.Units.UserType.Monthly">
            <summary>
            Monthly
            </summary>
        </member>
        <member name="F:Abodit.Units.UserType.Weekly">
            <summary>
            Weekly
            </summary>
        </member>
        <member name="F:Abodit.Units.UserType.Annual">
            <summary>
            Annual
            </summary>
        </member>
        <member name="T:Abodit.Units.UsersUnit">
            <summary>
            A measure of users
            </summary>
            <remarks>
            This is an experimental class, not intended for consumption yet
            </remarks>
        </member>
        <member name="P:Abodit.Units.UsersUnit.UserType">
            <summary>
            Get the UserType
            </summary>
        </member>
        <member name="M:Abodit.Units.UsersUnit.#ctor">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Units.UsersUnit"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.UsersUnit.#ctor(System.Double)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Units.UsersUnit"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.UsersUnit.#ctor(System.Double,Abodit.Units.UserType,Abodit.Units.QuantityQualifier)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Units.UsersUnit"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.UsersUnit.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Units.UsersUnit"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.UsersUnit.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Units.UsersUnit"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.UsersUnit.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="F:Abodit.Units.UsersUnit.One">
            <summary>
            One user
            </summary>
        </member>
        <member name="P:Abodit.Units.UsersUnit.Users">
            <summary>
            Gets a number of users
            </summary>
        </member>
        <member name="M:Abodit.Units.UsersUnit.DoDescribe(System.Boolean,System.Int32)">
            <summary>
            Describe in english
            </summary>
        </member>
        <member name="T:Abodit.Units.Velocity">
            <summary>
            A Velocity (distance / time)
            </summary>
        </member>
        <member name="M:Abodit.Units.Velocity.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.Velocity"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Velocity.Create(Abodit.Units.Distance,Abodit.Units.Rate,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.Velocity"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Velocity.Create(Abodit.Units.Distance,Abodit.Units.TimePeriod,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.Velocity"/> class
            </summary>
        </member>
        <member name="F:Abodit.Units.Velocity.OneMeterPerSecond">
            <summary>
            One Meter per second
            </summary>
        </member>
        <member name="F:Abodit.Units.Velocity.OneMilePerHour">
            <summary>
            One mile per hour
            </summary>
        </member>
        <member name="F:Abodit.Units.Velocity.OneKmPerHour">
            <summary>
            One Km per hour
            </summary>
        </member>
        <member name="P:Abodit.Units.Velocity.VelocityInMetersPerSecond">
            <summary>
            Get the velocity in meters per second
            </summary>
        </member>
        <member name="P:Abodit.Units.Velocity.VelocityInMilesPerHour">
            <summary>
            Get the velocity in miles per hour
            </summary>
        </member>
        <member name="M:Abodit.Units.Velocity.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Units.Velocity"/> class
            </summary>
        </member>
        <member name="T:Abodit.Units.Voltage">
            <summary>
            A voltage
            </summary>
        </member>
        <member name="M:Abodit.Units.Voltage.#ctor">
            <summary>
            Creates an instance of the <see cref="T:Abodit.Units.Voltage"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Voltage.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates an instance of the <see cref="T:Abodit.Units.Voltage"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Voltage.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates an instance of the <see cref="T:Abodit.Units.Voltage"/> class
            </summary>
        </member>
        <member name="M:Abodit.Units.Voltage.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="F:Abodit.Units.Voltage.Units">
            <summary>
            Get the SI Unit set
            </summary>
        </member>
        <member name="F:Abodit.Units.Voltage.Zero">
            <summary>
            Zero voltage
            </summary>
        </member>
        <member name="T:Abodit.Units.Volume">
            <summary>
            A distance
            </summary>
        </member>
        <member name="P:Abodit.Units.Volume.CubicMeters">
            <summary>
            Volume in cubic meters
            </summary>
        </member>
        <member name="P:Abodit.Units.Volume.CubicKm">
            <summary>
            Get the volume in cubic kilometers
            </summary>
        </member>
        <member name="P:Abodit.Units.Volume.CubicCentimeters">
            <summary>
            Get the volume in cubic centimeters
            </summary>
        </member>
        <member name="P:Abodit.Units.Volume.CubicMillimeters">
            <summary>
            Get the volume in cubic millimeters
            </summary>
        </member>
        <member name="P:Abodit.Units.Volume.CubicMiles">
            <summary>
            Get the volume in cubic miles
            </summary>
        </member>
        <member name="P:Abodit.Units.Volume.CubicYards">
            <summary>
            Get the volume in cubic yards
            </summary>
        </member>
        <member name="P:Abodit.Units.Volume.CubicFeet">
            <summary>
            Get the volume in cubic feet
            </summary>
        </member>
        <member name="P:Abodit.Units.Volume.CubicInches">
            <summary>
            Get the volume in cubic inches
            </summary>
        </member>
        <member name="P:Abodit.Units.Volume.FluidOuncesUs">
            <summary>
            Get the volume in fluid ounces
            </summary>
        </member>
        <member name="M:Abodit.Units.Volume.#ctor">
            <summary>
            Creates a new zero Volume
            </summary>
        </member>
        <member name="M:Abodit.Units.Volume.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates an instance of volume based on a multiplier and a unit of volume
            </summary>
        </member>
        <member name="M:Abodit.Units.Volume.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Volume"/>
            </summary>
        </member>
        <member name="F:Abodit.Units.Volume.OneMeterCubed">
            <summary>
            A unit of one meter cubed
            </summary>
        </member>
        <member name="F:Abodit.Units.Volume.OneKilometerCubed">
            <summary>
            A unit of one kilometer cubed
            </summary>
        </member>
        <member name="F:Abodit.Units.Volume.OneCentimeterCubed">
            <summary>
            A unit of one centimeter cubed
            </summary>
        </member>
        <member name="F:Abodit.Units.Volume.OneMillimeterCubed">
            <summary>
            A unit of one millimeter cubed
            </summary>
        </member>
        <member name="F:Abodit.Units.Volume.OneMicronCubed">
            <summary>
            A unit of one micron cubed
            </summary>
        </member>
        <member name="F:Abodit.Units.Volume.OneMileCubed">
            <summary>
            A unit of one mile cubed
            </summary>
        </member>
        <member name="F:Abodit.Units.Volume.OneYardCubed">
            <summary>
            A unit of one yard cubed
            </summary>
        </member>
        <member name="F:Abodit.Units.Volume.OneFootCubed">
            <summary>
            A unit of one foot cubed
            </summary>
        </member>
        <member name="F:Abodit.Units.Volume.OneInchCubed">
            <summary>
            A unit of one inch cubed
            </summary>
        </member>
        <member name="F:Abodit.Units.Volume.OneUsFluidGallon">
            <summary>
            A unit of one US fluid gallon
            </summary>
        </member>
        <member name="F:Abodit.Units.Volume.OneUsDryGallon">
            <summary>
            A unit of one US dry gallon
            </summary>
        </member>
        <member name="F:Abodit.Units.Volume.OneUkGallon">
            <summary>
            A unit of one UK gallon
            </summary>
        </member>
        <member name="F:Abodit.Units.Volume.OneLitre">
            <summary>
            A unit of one liter
            </summary>
        </member>
        <member name="F:Abodit.Units.Volume.OneHectoLitre">
            <summary>
            A unit of one hecto liter
            </summary>
        </member>
        <member name="F:Abodit.Units.Volume.OneUsFluidOunce">
            <summary>
            A unit of one US fluid ounce
            </summary>
        </member>
        <member name="F:Abodit.Units.Volume.OneUkFluidOunce">
            <summary>
            A unit of one UK fluid ounce
            </summary>
        </member>
        <member name="F:Abodit.Units.Volume.Zero">
            <summary>
            A volume of zero
            </summary>
        </member>
        <member name="M:Abodit.Units.Volume.InMetric">
            <summary>
            Gets the Volume in metric
            </summary>
        </member>
        <member name="M:Abodit.Units.Volume.InImperial">
            <summary>
            Gets the volume in a non-metric unit
            </summary>
        </member>
        <member name="T:Abodit.Units.VolumeMetric">
            <summary>
            A metric Volume
            </summary>
        </member>
        <member name="M:Abodit.Units.VolumeMetric.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Volume"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.VolumeImperial">
            <summary>
            A non-metric Volume
            </summary>
        </member>
        <member name="M:Abodit.Units.VolumeImperial.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Volume"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.VolumeCubicKm">
            <summary>
            A Volume in cubic Km
            </summary>
        </member>
        <member name="M:Abodit.Units.VolumeCubicKm.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Volume"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.VolumeCubicM">
            <summary>
            A Volume in cubic m
            </summary>
        </member>
        <member name="M:Abodit.Units.VolumeCubicM.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Volume"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.VolumeCubicCm">
            <summary>
            A Volume in cubic cm
            </summary>
        </member>
        <member name="M:Abodit.Units.VolumeCubicCm.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Volume"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.VolumeCubicMm">
            <summary>
            A Volume in cubic mm
            </summary>
        </member>
        <member name="M:Abodit.Units.VolumeCubicMm.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Volume"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.VolumeCubicMicrons">
            <summary>
            A Volume in cubic microns
            </summary>
        </member>
        <member name="M:Abodit.Units.VolumeCubicMicrons.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Volume"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.VolumeCubicMiles">
            <summary>
            A Volume in cubic miles
            </summary>
        </member>
        <member name="M:Abodit.Units.VolumeCubicMiles.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Volume"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.VolumeCubicYards">
            <summary>
            A Volume in cubicyards
            </summary>
        </member>
        <member name="M:Abodit.Units.VolumeCubicYards.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Volume"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.VolumeCubicFeet">
            <summary>
            A Volume in cubic feet
            </summary>
        </member>
        <member name="M:Abodit.Units.VolumeCubicFeet.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Volume"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.VolumeCubicInches">
            <summary>
            A Volume in cubic inches
            </summary>
        </member>
        <member name="M:Abodit.Units.VolumeCubicInches.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Volume"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.Weight">
            <summary>
            A weight value
            </summary>
        </member>
        <member name="M:Abodit.Units.Weight.#ctor">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Weight"/>
            </summary>
        </member>
        <member name="M:Abodit.Units.Weight.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates an instance of a Weight
            </summary>
        </member>
        <member name="M:Abodit.Units.Weight.ToString">
            <summary>
            Default ToString() is in kilos
            </summary>
            <returns></returns>
        </member>
        <member name="M:Abodit.Units.Weight.Create(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Weight"/>
            </summary>
        </member>
        <member name="P:Abodit.Units.Weight.Zero">
            <summary>
            A weight of zero
            </summary>
        </member>
        <member name="F:Abodit.Units.Weight.OneKilogram">
            <summary>
            A unit of one kilogram
            </summary>
        </member>
        <member name="F:Abodit.Units.Weight.OneGramme">
            <summary>
            A unit of one gram
            </summary>
        </member>
        <member name="F:Abodit.Units.Weight.OneTonne">
            <summary>
            A unit of one tonne
            </summary>
        </member>
        <member name="F:Abodit.Units.Weight.OneOunce">
            <summary>
            A unit of one ounce
            </summary>
        </member>
        <member name="F:Abodit.Units.Weight.OnePound">
            <summary>
            A unit of one pound
            </summary>
        </member>
        <member name="F:Abodit.Units.Weight.OneStone">
            <summary>
            A unit of one stone
            </summary>
        </member>
        <member name="F:Abodit.Units.Weight.OneTon">
            <summary>
            A unit of one ton
            </summary>
        </member>
        <member name="F:Abodit.Units.Weight.OneLongTon">
            <summary>
            A unit of one long ton
            </summary>
        </member>
        <member name="P:Abodit.Units.Weight.Kilogrammes">
            <summary>
            Get the weight in kilogrammes
            </summary>
        </member>
        <member name="P:Abodit.Units.Weight.MetricTonnes">
            <summary>
            Get the weight in metric tonnes
            </summary>
        </member>
        <member name="P:Abodit.Units.Weight.Ounces">
            <summary>
            Get the weight in ounces
            </summary>
        </member>
        <member name="P:Abodit.Units.Weight.Lbs">
            <summary>
            Get the weight in lbs
            </summary>
        </member>
        <member name="P:Abodit.Units.Weight.Stone">
            <summary>
            Get the weight in stone
            </summary>
        </member>
        <member name="P:Abodit.Units.Weight.Tons">
            <summary>
            Get the weight in tons
            </summary>
        </member>
        <member name="M:Abodit.Units.Weight.InMetric">
            <summary>
            Convert to metric using appropriate units
            </summary>
        </member>
        <member name="M:Abodit.Units.Weight.InImperial">
            <summary>
            Convert to imperial using appropriate units
            </summary>
        </member>
        <member name="T:Abodit.Units.WeightMetric">
            <summary>
            A metric weight
            </summary>
        </member>
        <member name="M:Abodit.Units.WeightMetric.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Weight"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.WeightImperial">
            <summary>
            An non-metric Weight
            </summary>
        </member>
        <member name="M:Abodit.Units.WeightImperial.#ctor(System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Weight"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.WeightTonnes">
            <summary>
            Weight in Tonnes
            </summary>
        </member>
        <member name="M:Abodit.Units.WeightTonnes.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Weight"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.WeightKg">
            <summary>
            Weight in Kg
            </summary>
        </member>
        <member name="M:Abodit.Units.WeightKg.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Weight"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.WeightGrammes">
            <summary>
            Weight in Grammes
            </summary>
        </member>
        <member name="M:Abodit.Units.WeightGrammes.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Weight"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.WeightTons">
            <summary>
            Weight in Tons
            </summary>
        </member>
        <member name="M:Abodit.Units.WeightTons.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Weight"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.WeightLongTons">
            <summary>
            Weight in Long Tons
            </summary>
        </member>
        <member name="M:Abodit.Units.WeightLongTons.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Weight"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.WeightStone">
            <summary>
            Weight in Stone
            </summary>
        </member>
        <member name="M:Abodit.Units.WeightStone.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Weight"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.WeightPounds">
            <summary>
            Weight in Pounds
            </summary>
        </member>
        <member name="M:Abodit.Units.WeightPounds.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Weight"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.WeightOunces">
            <summary>
            Weight in Ounces
            </summary>
        </member>
        <member name="M:Abodit.Units.WeightOunces.#ctor(System.Double,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new <see cref="T:Abodit.Units.Weight"/>
            </summary>
        </member>
        <member name="T:Abodit.Units.Utility.TypeUtility">
            <summary>
            Utility class for working with Types
            </summary>
        </member>
        <member name="M:Abodit.Units.Utility.TypeUtility.CreateTypeStringFromObject(System.Object)">
            <summary>
            Replaces .GeType().Name with a string that also handles generics
            </summary>
        </member>
        <member name="M:Abodit.Units.Utility.TypeUtility.CreateTypeStringFromType(System.Type)">
            <summary>
            Replaces .GeType().Name with a string that also handles generics
            </summary>
        </member>
        <member name="T:Abodit.Utility.IHighLow">
            <summary>
            An object that has a high value and a low value
            </summary>
        </member>
        <member name="P:Abodit.Utility.IHighLow.High">
            <summary>
            The high value
            </summary>
        </member>
        <member name="P:Abodit.Utility.IHighLow.Low">
            <summary>
            The low value
            </summary>
        </member>
        <member name="T:Abodit.Utility.Inflector">
            <summary>
            Converts nouns between singular and plural forms using rules.
            </summary>
            <remarks>
            See http://meta.stackexchange.com/questions/61380/inflector-net-not-correctly-attributed-to-andrew-peters-in-stack-exchange-data-e
            for licensing details. Apache 2.0 license applies to this one class, it is not strictly
            part of AboditNLP but is included here for convenience.
            </remarks>
        </member>
        <member name="M:Abodit.Utility.Inflector.Pluralize(System.String)">
            <summary>
            Converts a noun to its plural form
            </summary>
        </member>
        <member name="M:Abodit.Utility.Inflector.SingularPossessive(System.String)">
            <summary>
            Create the singular possessive of a noun
            </summary>
        </member>
        <member name="M:Abodit.Utility.Inflector.PluralPossessive(System.String,System.String)">
            <summary>
            Create the plural possessive of a Noun
            </summary>
        </member>
        <member name="M:Abodit.Utility.Inflector.Singularize(System.String)">
            <summary>
            Converts a noun to its singular form
            </summary>
        </member>
        <member name="M:Abodit.Utility.Inflector.Titleize(System.String)">
            <summary>
            Converts a word to Title Case
            </summary>
        </member>
        <member name="M:Abodit.Utility.Inflector.Humanize(System.String)">
            <summary>
            Converts a lower case underscored word to an english form
            </summary>
        </member>
        <member name="M:Abodit.Utility.Inflector.Pascalize(System.String)">
            <summary>
            Convert a string to pascal case
            </summary>
        </member>
        <member name="M:Abodit.Utility.Inflector.Camelize(System.String)">
            <summary>
            Converts from underscored to camel case
            </summary>
        </member>
        <member name="M:Abodit.Utility.Inflector.Underscore(System.String)">
            <summary>
            Converts from pascal cased to underscored
            </summary>
        </member>
        <member name="M:Abodit.Utility.Inflector.Capitalize(System.String)">
            <summary>
            Capitalize a word, leaving the tail unchanged IF it's already capitalized
            </summary>
        </member>
        <member name="M:Abodit.Utility.Inflector.CapitalizeForceTailToLower(System.String)">
            <summary>
            Capitalize a word forcing the tail to lower case, e.g. iPhoNe becomes iPhone
            </summary>
        </member>
        <member name="M:Abodit.Utility.Inflector.Uncapitalize(System.String)">
            <summary>
            Change first capitalized letter to non-caps
            </summary>
        </member>
        <member name="M:Abodit.Utility.Inflector.Ordinalize(System.String)">
            <summary>
            Get the ordinal version of a number (1st, 2nd, ...)
            </summary>
        </member>
        <member name="M:Abodit.Utility.Inflector.OrdinalizeWithFirstSecondThird(System.Int32)">
            <summary>
            Get the ordinal version of a number (first, second, third, 4th, ...)
            </summary>
        </member>
        <member name="M:Abodit.Utility.Inflector.Ordinalize(System.Int32)">
            <summary>
            Get the ordinal version of a number (1st, 2nd, ...)
            </summary>
        </member>
        <member name="M:Abodit.Utility.Inflector.Dasherize(System.String)">
            <summary>
            Convert underscore to dashes in a string
            </summary>
        </member>
        <member name="T:Abodit.Utility.FindValue">
            <summary>
            Extension methods for finding split points in a TimedDoubleCollection
            </summary>
        </member>
        <member name="M:Abodit.Utility.FindValue.ExtractIndex(System.Double[],System.Double)">
            <summary>
            Find where this value lies in a range of values, returns index of last element that is less than this one
            </summary>
        </member>
        <member name="M:Abodit.Utility.FindValue.ExtractIndex(System.Tuple{System.Double,System.String}[],System.Double)">
            <summary>
            Find where this value lies in a range of values, returns index of last element that is less than this one
            </summary>
        </member>
        <member name="M:Abodit.Utility.FindValue.ExtractIndexByHighLow(System.Collections.Generic.IEnumerable{Abodit.Utility.IHighLow},System.Double)">
            <summary>
            Find where this value lies in a range of values, returns index of last element that is less than this one
            </summary>
        </member>
        <member name="T:Abodit.Utility.Interpolation">
            <summary>
            Interpolation methods for time series data
            </summary>
        </member>
        <member name="M:Abodit.Utility.Interpolation.SpLine(System.Collections.Generic.List{Abodit.Units.TimedValue{System.Double}},System.DateTime)">
            <summary>
            Interpolate the value at time z
            </summary>
        </member>
        <member name="M:Abodit.Utility.Interpolation.SpLine(System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{System.Double,System.Double}},System.Double)">
            <summary>
            Interpolate the value at position z using a spline
            </summary>
        </member>
        <member name="M:Abodit.Utility.Interpolation.solveTridiag(System.Double[],System.Double[],System.Double[],System.Double[]@,System.Int32)">
            <summary>
            Part of spline solution
            </summary>
        </member>
        <member name="T:Abodit.Utility.ObjectActivator`1">
            <summary>
            Delegate for creating an object using reflection
            </summary>
        </member>
        <member name="T:Abodit.Utility.ActivatorUtility">
            <summary>
            Extension methods for creating object activators from <see cref="T:System.Reflection.ConstructorInfo"/> values
            </summary>
        </member>
        <member name="M:Abodit.Utility.ActivatorUtility.GetActivator``1(System.Reflection.ConstructorInfo)">
            <summary>
            Get an activator from a ConstructorInfo
            </summary>
        </member>
        <member name="T:Abodit.Utility.Attributes">
            <summary>
            Attribute methods 
            </summary>
        </member>
        <member name="M:Abodit.Utility.Attributes.GetAttribute``1(System.Object)">
            <summary>
            Get the first of a particular attribute from an object's class by type of attribute
            </summary>
        </member>
        <member name="M:Abodit.Utility.Attributes.GetAttribute``1(System.Type)">
            <summary>
            Get the first of a particular attribute from this class by type of attribute
            </summary>
        </member>
        <member name="M:Abodit.Utility.Attributes.HasAttribute``1(System.Type)">
            <summary>
            Does a given object have this particular attribute?
            </summary>
        </member>
        <member name="M:Abodit.Utility.Attributes.HasAttribute``1(System.Object)">
            <summary>
            Does a given object have this particular attribute?
            </summary>
        </member>
        <member name="M:Abodit.Utility.Attributes.GetAttributes``1(System.Object)">
            <summary>
            Get all attribute from this class matching an attribute (with caching)
            </summary>
        </member>
        <member name="M:Abodit.Utility.Attributes.GetAttributes``1(System.Type)">
            <summary>
            Get all attribute from this class matching an attribute
            </summary>
        </member>
        <member name="T:Abodit.Utility.TypeExtensions">
            <summary>
            Extension methhods for Types
            </summary>
        </member>
        <member name="M:Abodit.Utility.TypeExtensions.IsCastableTo(System.Type,System.Type)">
            <summary>
            Is a type castable 
            </summary>
            <remarks>
            This is like IsAssignableFrom but it handles all the numeric types that aren't 'Assignable' according to that method but really are
            </remarks>
        </member>
        <member name="T:Abodit.Utility.CombineLambda">
            <summary>
            http://blogs.msdn.com/meek/archive/2008/05/02/linq-to-entities-combining-predicates.aspx
            </summary>
        </member>
        <member name="M:Abodit.Utility.CombineLambda.Compose``1(System.Linq.Expressions.Expression{``0},System.Linq.Expressions.Expression{``0},System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression})">
            <summary>
            Compose two lambda expressions replacing parameters as appropriate
            </summary>
        </member>
        <member name="M:Abodit.Utility.CombineLambda.And``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Creates an And expression
            </summary>
        </member>
        <member name="M:Abodit.Utility.CombineLambda.Or``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Creates an Or expression
            </summary>
        </member>
        <member name="T:Abodit.Utility.ParameterRebinder">
            <summary>
            Rebinds a parameter in a .NET Expression
            </summary>
        </member>
        <member name="M:Abodit.Utility.ParameterRebinder.#ctor(System.Collections.Generic.Dictionary{System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression})">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Utility.ParameterRebinder"/> class
            </summary>
        </member>
        <member name="M:Abodit.Utility.ParameterRebinder.ReplaceParameters(System.Collections.Generic.Dictionary{System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression)">
            <summary>
            Replace parameters to create a new Expression
            </summary>
        </member>
        <member name="M:Abodit.Utility.ParameterRebinder.VisitParameter(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="T:Abodit.Utility.ExpressionVisitor">
            <summary>
            http://blogs.msdn.com/mattwar/archive/2007/07/31/linq-building-an-iqueryable-provider-part-ii.aspx
            </summary>
        </member>
        <member name="M:Abodit.Utility.ExpressionVisitor.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Utility.ExpressionVisitor"/> class
            </summary>
        </member>
        <member name="M:Abodit.Utility.ExpressionVisitor.Visit(System.Linq.Expressions.Expression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Utility.ExpressionVisitor.VisitBinding(System.Linq.Expressions.MemberBinding)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Utility.ExpressionVisitor.VisitElementInitializer(System.Linq.Expressions.ElementInit)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Utility.ExpressionVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Utility.ExpressionVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Utility.ExpressionVisitor.VisitTypeIs(System.Linq.Expressions.TypeBinaryExpression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Utility.ExpressionVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Utility.ExpressionVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Utility.ExpressionVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Utility.ExpressionVisitor.VisitMemberAccess(System.Linq.Expressions.MemberExpression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Utility.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Utility.ExpressionVisitor.VisitExpressionList(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.Expression})">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Utility.ExpressionVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Utility.ExpressionVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Utility.ExpressionVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Utility.ExpressionVisitor.VisitBindingList(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.MemberBinding})">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Utility.ExpressionVisitor.VisitElementInitializerList(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ElementInit})">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Utility.ExpressionVisitor.VisitLambda(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Utility.ExpressionVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Utility.ExpressionVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Utility.ExpressionVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Utility.ExpressionVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Utility.ExpressionVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="T:Abodit.Utility.ExceptionExtensions">
            <summary>
            Extension methods for Exceptions
            </summary>
        </member>
        <member name="M:Abodit.Utility.ExceptionExtensions.DumpException(System.Exception)">
            <summary>
            Dump an exception and all exception data in it to a StringBuilder
            </summary>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="T:Abodit.Utility.Memoization">
            <summary>
            Memoization operations for enumerable sources
            </summary>
        </member>
        <member name="M:Abodit.Utility.Memoization.Memoize``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Memoizes an enumerable source to avoid repeated evaluation
            </summary>
        </member>
        <member name="M:Abodit.Utility.Memoization.Let``2(System.Collections.Generic.IEnumerable{``0},System.Func{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Applies a function to a memoized enumerable
            </summary>
            <remarks>
            Not sure this helps since it disposes of the memoization immediately
            </remarks>
        </member>
        <member name="T:Abodit.Utility.MemoizeEnumerable`1">
            <summary>
            A memoized enumerable (IDisposable, use this only in a using block)
            </summary>
        </member>
        <member name="M:Abodit.Utility.MemoizeEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new <see cref="T:Abodit.Utility.MemoizeEnumerable`1"/>
            </summary>
        </member>
        <member name="M:Abodit.Utility.MemoizeEnumerable`1.GetEnumerator">
            <summary>
            Get the enumerator for this memoized enumerable
            </summary>
            <returns></returns>
        </member>
        <member name="M:Abodit.Utility.MemoizeEnumerable`1.Dispose">
            <summary>
            Dispose of this enumerator and any underlying enumeration
            </summary>
        </member>
        <member name="T:Abodit.Utility.MemoizeEnumerable`1.MemoizeEnumerator">
            <summary>
            A memoized enumerator
            </summary>
        </member>
        <member name="M:Abodit.Utility.MemoizeEnumerable`1.MemoizeEnumerator.#ctor(Abodit.Utility.MemoizeEnumerable{`0})">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Utility.MemoizeEnumerable`1.MemoizeEnumerator"/>
            </summary>
        </member>
        <member name="P:Abodit.Utility.MemoizeEnumerable`1.MemoizeEnumerator.Current">
            <summary>
            Get the current value
            </summary>
        </member>
        <member name="M:Abodit.Utility.MemoizeEnumerable`1.MemoizeEnumerator.MoveNext">
            <summary>
            Move next
            </summary>
        </member>
        <member name="M:Abodit.Utility.MemoizeEnumerable`1.MemoizeEnumerator.Reset">
            <summary>
            Reset the enumerator
            </summary>
        </member>
        <member name="M:Abodit.Utility.MemoizeEnumerable`1.MemoizeEnumerator.Dispose">
            <summary>
            Dispose of this enumerator
            </summary>
        </member>
        <member name="T:Abodit.Utility.StringUtility">
            <summary>
            Utility methods for string manipulation, list rendering, ...
            </summary>
        </member>
        <member name="M:Abodit.Utility.StringUtility.ToTextList``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String)">
            <summary>
            Convert to a comma separated list with an "and" on the last item
            </summary>
        </member>
        <member name="M:Abodit.Utility.StringUtility.DamerauLevenshteinDistance(System.String,System.String)">
            <summary>
            Damerau–Levenshtein distance algorithm and code 
            from http://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance (as retrieved in June 2012)
            </summary>
        </member>
        <member name="T:Abodit.ExpressionParser.Parser">
            <summary>
            Serialize/Deserialize TokenExpressions from a string
            </summary>
        </member>
        <member name="M:Abodit.ExpressionParser.Parser.Deserialize(System.String,Abodit.ExpressionParser.ParserEnvironment)">
            <summary>
            Deserialize a <see cref="T:Abodit.Expressions.TokenExpression"/> from a string
            </summary>
        </member>
        <member name="M:Abodit.ExpressionParser.Parser.Serialize(Abodit.Expressions.TokenExpression)">
            <summary>
            Serialize a TokenExpression
            </summary>
        </member>
        <member name="M:Abodit.ExpressionParser.Parser.ReadRangeFunction(Abodit.Expressions.TokenExpression[])">
            <summary>
            Read a range function
            </summary>
        </member>
        <member name="T:Abodit.ExpressionParser.Parser.RangeConverter">
            <summary>
            A Type Converter for Ranges
            </summary>
        </member>
        <member name="M:Abodit.ExpressionParser.Parser.RangeConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Can convert to the destination type (must be a string)
            </summary>
        </member>
        <member name="M:Abodit.ExpressionParser.Parser.RangeConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Converts the given value object to the specified type, using the specified context and culture
            </summary>
        </member>
        <member name="M:Abodit.ExpressionParser.Parser.RangeConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Returns whether this converter can convertan object of the given type to the type of this converter, using the specified context
            </summary>
        </member>
        <member name="M:Abodit.ExpressionParser.Parser.RangeConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            Converts the given object to the type of this converter, using the specified context and culture
            </summary>
        </member>
        <member name="F:Abodit.ExpressionParser.Parser.quotableCharacters">
            <summary>
            Characters that can be quoted inside a string literal by adding a backslash
            </summary>
        </member>
        <member name="T:Abodit.ExpressionParser.Parser.Token">
            <summary>
            A Token recognized by the <see cref="T:Abodit.ExpressionParser.Parser"/>
            </summary>
        </member>
        <member name="T:Abodit.ExpressionParser.Parser.FixedToken">
            <summary>
            A fixed token
            </summary>
        </member>
        <member name="P:Abodit.ExpressionParser.Parser.FixedToken.Value">
            <summary>
            The string for this Token
            </summary>
        </member>
        <member name="M:Abodit.ExpressionParser.Parser.FixedToken.#ctor(System.String)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.ExpressionParser.Parser.FixedToken"/> class
            </summary>
        </member>
        <member name="M:Abodit.ExpressionParser.Parser.FixedToken.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.ExpressionParser.Parser.OperatorToken">
            <summary>
            A Token representing an operator
            </summary>
        </member>
        <member name="P:Abodit.ExpressionParser.Parser.OperatorToken.Precedence">
            <summary>
            The precedence level for this Token
            </summary>
        </member>
        <member name="M:Abodit.ExpressionParser.Parser.OperatorToken.#ctor(System.String,System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.ExpressionParser.Parser.OperatorToken"/> class
            </summary>
        </member>
        <member name="T:Abodit.ExpressionParser.Parser.NumberConstantToken">
            <summary>
            A Token representing a constant number
            </summary>
        </member>
        <member name="P:Abodit.ExpressionParser.Parser.NumberConstantToken.Value">
            <summary>
            The numeric value of the token
            </summary>
        </member>
        <member name="M:Abodit.ExpressionParser.Parser.NumberConstantToken.#ctor(System.Double)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.ExpressionParser.Parser.NumberConstantToken"/> class
            </summary>
        </member>
        <member name="M:Abodit.ExpressionParser.Parser.NumberConstantToken.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.ExpressionParser.Parser.StringValuedToken">
            <summary>
            A Token representing a string value
            </summary>
        </member>
        <member name="P:Abodit.ExpressionParser.Parser.StringValuedToken.Value">
            <summary>
            The value 
            </summary>
        </member>
        <member name="M:Abodit.ExpressionParser.Parser.StringValuedToken.#ctor(System.String)">
            <summary>
            Creates a new instance of of the <see cref="T:Abodit.ExpressionParser.Parser.StringValuedToken"/> class
            </summary>
        </member>
        <member name="T:Abodit.ExpressionParser.Parser.IdentifierToken">
            <summary>
            A token representing an identifier
            </summary>
        </member>
        <member name="M:Abodit.ExpressionParser.Parser.IdentifierToken.#ctor(System.String)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.ExpressionParser.Parser.IdentifierToken"/> class
            </summary>
        </member>
        <member name="M:Abodit.ExpressionParser.Parser.IdentifierToken.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.ExpressionParser.Parser.QuotedStringToken">
            <summary>
            A quoted string token
            </summary>
        </member>
        <member name="M:Abodit.ExpressionParser.Parser.QuotedStringToken.#ctor(System.String)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.ExpressionParser.Parser.QuotedStringToken"/> class
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Abodit.ExpressionParser.Parser.QuotedStringToken.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.ExpressionParser.ParserEnvironment">
            <summary>
            Parser Environment maps variable names to their actual .NET types
            allowing TokenVariableAccess to have a correct Type on it
            </summary>
        </member>
        <member name="M:Abodit.ExpressionParser.ParserEnvironment.AddVariable(System.String,System.Type)">
            <summary>
            Add a variable declaration to the Parser Environment
            </summary>
            <param name="name">The name of the variable</param>
            <param name="type">The type of the variable</param>
        </member>
        <member name="M:Abodit.ExpressionParser.ParserEnvironment.TryGetVariable(System.String,System.Type@)">
            <summary>
            Try getting the type for a variable
            </summary>
            <param name="name"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Abodit.ExpressionParser.ParserEnvironment.AddFunction(Abodit.Expressions.Visitor.RegisteredFunction)">
            <summary>
            Add a function specification to the Parser Environment
            </summary>
        </member>
        <member name="M:Abodit.ExpressionParser.ParserEnvironment.TryGetFunction(System.String,System.Type[],System.Type@)">
            <summary>
            Try getting the type for a function
            </summary>
        </member>
        <member name="M:Abodit.ExpressionParser.ParserEnvironment.GetFunctions(System.String)">
            <summary>
            Get all matching functions with the same name
            </summary>
            <param name="name"></param>
            <returns>A list of registered functions with this name</returns>
        </member>
        <member name="M:Abodit.ExpressionParser.ParserEnvironment.AddFunctions(System.Collections.Generic.IEnumerable{Abodit.Expressions.Visitor.RegisteredFunction})">
            <summary>
            Add multiple functions to the environment
            </summary>
            <param name="registeredFunctions"></param>
        </member>
        <member name="T:Abodit.ExpressionParser.ParserException">
            <summary>
            An Exception that occured during parsing of an expression
            </summary>
        </member>
        <member name="M:Abodit.ExpressionParser.ParserException.#ctor(System.String)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.ExpressionParser.ParserException"/> class
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionAll">
            <summary>
            All of an Enumerable of a token expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionAll.#ctor(Abodit.Expressions.TokenExpression)">
            <summary>
            Creates a new instance of the All class for checking an enumerable of bool
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionAll.Priority">
            <summary>
            Gets the relative priority compared to other TokenExpression types
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionAll.Type">
            <summary>
            Get the result type
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionAll.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionAll.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionAny">
            <summary>
            Any of an Enumerable of a token expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionAny.#ctor(Abodit.Expressions.TokenExpression)">
            <summary>
            Creates a new instance of the Any class for checking an enumerable of bool
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionAny.Priority">
            <summary>
            Gets the relative priority compared to other TokenExpression types
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionAny.Type">
            <summary>
            Get the result type
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionAny.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionAny.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionAverage">
            <summary>
            Average of an Enumerable of a token expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionAverage.#ctor(Abodit.Expressions.TokenExpression)">
            <summary>
            Creates a new instance of the Average class for checking an enumerable of bool
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionAverage.Priority">
            <summary>
            Gets the relative priority compared to other TokenExpression types
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionAverage.Type">
            <summary>
            Get the result type
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionAverage.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionAverage.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionCount">
            <summary>
            Count of an Enumerable of a token expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionCount.#ctor(Abodit.Expressions.TokenExpression)">
            <summary>
            Creates a new instance of the Count class for checking an enumerable of bool
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionCount.Priority">
            <summary>
            Gets the relative priority compared to other TokenExpression types
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionCount.Type">
            <summary>
            Get the result type
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionCount.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionCount.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionDataSource">
            <summary>
            An enumerable expression is, for now, just a meta entity
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionDataSource.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionDataSource.type">
            <summary>
            The child type of the IEnumerable of this data source - used for in memory sources
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionDataSource.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionDataSource.TableName">
            <summary>
            Name of table or other identifier used to identify the data source
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionDataSource.#ctor(System.String,System.Type)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionDataSource"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionDataSource.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionDataSource.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionDataSource.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionDataSource.Equals(Abodit.Expressions.TokenExpressionDataSource)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionSelect">
            <summary>
            A Select expression takes a MetaEntity as the first parameter and a variable number of TokenExpressions
            selecting values from that enumerable MetaEntity, e.g. select Name, Type from Products
            For now LEFT should be a MetaEntity and right must be a TokenExpressionArray
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionSelect.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionSelect.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionSelect.#ctor(Abodit.Expressions.TokenExpressionDataSource,Abodit.Expressions.TokenExpressionArray)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionSelect"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionSelect.#ctor(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionSelect"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionSelect.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionSelect.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionSum">
            <summary>
            Sum of an Enumerable of a token expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionSum.#ctor(Abodit.Expressions.TokenExpression)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionSum"/> class for checking an enumerable of bool
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionSum.Priority">
            <summary>
            Gets the relative priority compared to other TokenExpression types
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionSum.Type">
            <summary>
            Get the result type
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionSum.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionSum.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionWhere">
            <summary>
            A Where expression takes a MetaEntity as the first parameter and a TokenExpression returning a bool
            For now LEFT should be a MetaEntity and RIGHT should be of type bool
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionWhere.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionWhere.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionWhere.#ctor(Abodit.Expressions.TokenExpressionDataSource,Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionWhere"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionWhere.WhereCouldMakeSense(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression)">
            <summary>
            Returns true if this could make sense as a match expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionWhere.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionWhere.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionAdd">
            <summary>
            A TokenExpression for adding two values (doubles or strings)
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionAdd.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionAdd.IsUnordered">
            <summary>
            Are the children unordered?
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionAdd.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionAdd.#ctor(Abodit.Expressions.TokenExpression[])">
            <summary>
            Creates a new instance of the TokenExpressionAdd class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionAdd.#ctor(Abodit.Expressions.TokenExpression,System.Double)">
            <summary>
            Creates a new instance of the TokenExpressionAdd class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionAdd.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Visitor pattern
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionAdd.ToString">
            <summary>
            ToString
            </summary>
            <returns></returns>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionAdd.Create(Abodit.Expressions.TokenExpression[])">
            <summary>
            Create an Add Expression or Zero if none
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionBinary">
            <summary>
            A binary TokenExpression
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionBinary.Left">
            <summary>
            The left expression
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionBinary.Right">
            <summary>
            The right expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionBinary.#ctor(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionBinary"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionBinary.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionBinary.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionBinary.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionDivide">
            <summary>
            A TokenExpression for divide
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionDivide.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionDivide.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionDivide.#ctor(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionDivide"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionDivide.#ctor(Abodit.Expressions.TokenExpression,System.Double)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionDivide"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionDivide.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionDivide.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionEquals">
            <summary>
            A TokenExpression for an equality comparison
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionEquals.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionEquals.Type">
            <summary>
            The .NET type of this TokenExpression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionEquals.#ctor(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionEquals"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionEquals.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionEquals.ToString">
            <summary>
            Returns a string representation of this object
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionGreater">
            <summary>
            A TokenExpression for greater than
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionGreater.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionGreater.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionGreater.#ctor(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionGreater"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionGreater.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionGreater.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionGreaterOrEqual">
            <summary>
            A TokenExpression for greater than or equal
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionGreaterOrEqual.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionGreaterOrEqual.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionGreaterOrEqual.#ctor(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionGreaterOrEqual"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionGreaterOrEqual.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionGreaterOrEqual.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionLess">
            <summary>
            A TokenExpression for less than
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionLess.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionLess.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionLess.#ctor(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionLess"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionLess.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionLess.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionLessOrEqual">
            <summary>
            A TokenExpression for less than or equal
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionLessOrEqual.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionLessOrEqual.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionLessOrEqual.#ctor(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionLessOrEqual"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionLessOrEqual.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionLessOrEqual.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionMatches">
            <summary>
            Matches is a fuzzier equals that allows matching of ranges, sets, datetime expressions, ...
            For now LEFT should be a VariableAccess and RIGHT should be a TemporalSet
            [Decided that TemporalSets behave like constants NOT functions, 'match' is the function]
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionMatches.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionMatches.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionMatches.#ctor(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionMatches"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionMatches.MatchCouldMakeSense(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression)">
            <summary>
            Returns true if this could make sense as a match expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionMatches.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionMatches.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionMatches.CreateMatchOrInequaity(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression)">
            <summary>
            Static method to create a Match OR a simple inequality
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionMatches.ConvertToInequalitiesForRange">
            <summary>
            Convert a matches expression into a less than / greater than expression
            for a RHS of TokenExpressionRange
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionMultiply">
            <summary>
            A TokenExpression for multiply
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionMultiply.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionMultiply.IsUnordered">
            <summary>
            Are the children unordered?
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionMultiply.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionMultiply.#ctor(Abodit.Expressions.TokenExpression[])">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionMultiply"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionMultiply.#ctor(Abodit.Expressions.TokenExpression,System.Double)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionMultiply"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionMultiply.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionMultiply.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionMultiply.Create(Abodit.Expressions.TokenExpression[])">
            <summary>
            Create a multiply expression or 1.0
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionNotEquals">
            <summary>
            A TokenExpression for not equals
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionNotEquals.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionNotEquals.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionNotEquals.#ctor(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionNotEquals"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionNotEquals.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionNotEquals.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionPower">
            <summary>
            TokenExpression for a raised to the power b
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionPower.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionPower.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionPower.#ctor(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionPower"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionPower.#ctor(Abodit.Expressions.TokenExpression,System.Double)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionPower"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionPower.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionPower.ToString">
            <summary>
            Returns a string of this object
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionRange">
            <summary>
            A range from a Min value to a Max value
            </summary>
            <remarks>
            The units are on the Min and the Max value and they may be different (e.g. 1cm to 10m)
            </remarks>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionRange.Type">
            <summary>
            Type for a Range Expression is IRange of T where T is the underlying ChildType
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionRange.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
            <remarks>
            A range is a constant (priority 1000) BUT it has lower priority than +, *, ...
            because 2 + 3 > 4 is really a comparison and not 2+3 compared to range > 4
            </remarks>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionRange.Interpretation">
            <summary>
            Qualifiers for the dimension-direction of this range, e.g. up/down/width/internal/...
            Also what dimensions it can apply to (if restricted by adjective)
            And what sense it has positive or negative (e.g. sentiment more than 30 negative)
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionRange.ChildType">
            <summary>
            The type of the Min and Max values (e.g. TokenDouble, Distance, Temperature, ...)
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionRange.MinValue">
            <summary>
            Gets the minimum value
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionRange.MaxValue">
            <summary>
            Gets the maximum value
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionRange.IncludesMin">
            <summary>
            Does this range include the minimum value (open inerval vs closed interval)
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionRange.IncludesMax">
            <summary>
            Does this range include the maximum value (open inerval vs closed interval)
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionRange.#ctor(System.Type,System.Type,Abodit.Expressions.TokenExpression,System.Boolean,Abodit.Expressions.TokenExpression,System.Boolean,Abodit.Units.Dimensions.Interpretation)">
            <summary>
            Creates a new <see cref="T:Abodit.Expressions.TokenExpressionRange"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionRange.Create``1(Abodit.Expressions.TokenExpression,System.Boolean,Abodit.Expressions.TokenExpression,System.Boolean,Abodit.Units.Dimensions.Interpretation)">
            <summary>
            Creates a new <see cref="T:Abodit.Expressions.TokenExpressionRange"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionRange.Clone(System.Type,System.Type,Abodit.Expressions.TokenExpression,System.Boolean,Abodit.Expressions.TokenExpression,System.Boolean,Abodit.Units.Dimensions.Interpretation)">
            <summary>
            Clone a range 
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionRange.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionRange.Equals(Abodit.Expressions.TokenExpressionRange)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionRange.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionRange.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionRange.ConvertToInequalities(Abodit.Expressions.TokenExpression)">
            <summary>
            Convert a Range into a set of inequalities with respect to a LHS variable (or other expression)
            e.g. 0-3 becomes left &gt;= 0, left &lt;= 3
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionSubtract">
            <summary>
            A TokenExpression for subtraction
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionSubtract.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionSubtract.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionSubtract.#ctor(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionSubtract"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionSubtract.#ctor(Abodit.Expressions.TokenExpression,System.Double)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionSubtract"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionSubtract.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionSubtract.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Expressions.BoundValue`1">
            <summary>
            A bound value is the result of a variable assignment
            </summary>
        </member>
        <member name="P:Abodit.Expressions.BoundValue`1.VariableName">
            <summary>
            The variable name
            </summary>
        </member>
        <member name="P:Abodit.Expressions.BoundValue`1.Value">
            <summary>
            The value of the variable
            </summary>
        </member>
        <member name="M:Abodit.Expressions.BoundValue`1.#ctor(System.String,`0)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Expressions.BoundValue`1"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.BoundValue`1.ToString">
            <summary>
            Returns a string representing this object
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenDouble">
            <summary>
            A number 1, 2, ...
            
            Hierarchy
                TokenNumber : TokenDouble : TokenLong : TokenInt : TokenIntWordForm
                TokenNumber : TokenDouble : TokenPercentage
                TokenNumber : TokenDouble : TokenFraction
                
            So if we get a better derived one first we are done
            
            
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenDouble.ValueDouble">
            <summary>
            Gets the double value
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenDouble.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenDouble.ValueInCanonicalUnit">
            <summary>
            Gets the value double
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenDouble.Dimension">
            <summary>
            Gets the Dimension of this constant value
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenDouble.Unit">
            <summary>
            Gets the Unit of this constant value
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenDouble.DoDescribe(System.Boolean)">
            <summary>
            Describe the value in text
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenDouble.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenDouble.#ctor(System.Double,System.String)">
            <summary>
            Creates a new instance of the TokenDouble class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenDouble.#ctor(System.Double)">
            <summary>
            Creates a new instance of the TokenDouble class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenDouble.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenDouble.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenDouble.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenDouble.Equals(Abodit.Expressions.TokenDouble)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenDouble.CompareTo(Abodit.Expressions.TokenDouble)">
            <summary>
            Compare
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenDouble.GetHashCode">
            <summary>
            GetHashcode
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenDouble.Multiply(System.Double)">
            <summary>
            Multiply by a double
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenDouble.Add(Abodit.Expressions.TokenDouble)">
            <summary>
            Add two token doubles
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenDouble.CreateWithSameScale(System.Double)">
            <summary>
            Create a TokenDouble with the same scale (it has no scale)
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionConstant">
            <summary>
            A TokenExpression that has a constant value
            </summary>
            <remarks>
            This is always a leaf node and has no children
            </remarks>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionConstant.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionConstant.Value">
            <summary>
            Gets the IConvertible value
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstant.#ctor(System.IConvertible)">
            <summary>
            Creates a new <see cref="T:Abodit.Expressions.TokenExpressionConstant"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstant.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstant.Create(System.Object)">
            <summary>
            Create a new constant token expression from a value
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstant.Create(System.DateTime)">
            <summary>
            Create a new <see cref="T:Abodit.Expressions.TokenExpressionConstantDateTime"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstant.Create(Abodit.Units.CalendarDateTime)">
            <summary>
            Create a new <see cref="T:Abodit.Expressions.TokenExpressionConstantDateTime"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstant.Create(System.Boolean)">
            <summary>
            Create a new <see cref="T:Abodit.Expressions.TokenExpressionConstantBool"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstant.Create(System.String)">
            <summary>
            Create a new <see cref="T:Abodit.Expressions.TokenExpressionConstantString"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstant.Create(System.Double)">
            <summary>
            Create a new <see cref="T:Abodit.Expressions.TokenDouble"/> from a double
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstant.Create(System.Int64)">
            <summary>
            Create a new <see cref="T:Abodit.Expressions.TokenDouble"/> from a long
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstant.Create(System.Int32)">
            <summary>
            Create a new <see cref="T:Abodit.Expressions.TokenDouble"/> from an int
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionConstantBool">
            <summary>
            A TokenExpression representing a constant boolean value
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionConstantBool.ValueBool">
            <summary>
            The boolean value
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionConstantBool.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantBool.#ctor(System.Boolean)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionConstantBool"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantBool.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantBool.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantBool.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Compare to another TokenExpression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantBool.Equals(System.Object)">
            <summary>
            Compare to another TokenExpression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantBool.GetHashCode">
            <summary>
            Get hash code
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionConstantColor">
            <summary>
            A TokenExpression representing a color
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionConstantColor.R">
            <summary>
            Red component (0-1)
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionConstantColor.G">
            <summary>
            Red component (0-1)
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionConstantColor.B">
            <summary>
            Red component (0-1)
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionConstantColor.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantColor.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionConstantColor"/> class using 0-255 values
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantColor.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionConstantColor"/> class using 0.0-1.0 values
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantColor.#ctor(System.String)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionConstantColor"/> class using a hex string value
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantColor.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantColor.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantColor.Equals(Abodit.Expressions.TokenExpressionConstantColor)">
            <summary>
            Compare to another TokenExpressionConstantColor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantColor.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Compare to another TokenExpression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantColor.Equals(System.Object)">
            <summary>
            Compare to another TokenExpression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantColor.GetHashCode">
            <summary>
            Get hash code
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantColor.ToHex(System.Double,System.Double,System.Double)">
            <summary>
            Returns the color as a six-digit hexadecimal string, in the form RRGGBB.
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantColor.ToHex(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the color as a six-digit hexadecimal string, in the form RRGGBB.
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionConstantColor.Hue">
            <summary>
            Get the hue from an HSL model of color
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionConstantColor.Saturation">
            <summary>
            Get the saturation from an HSL model of color (0 - 1.0)
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionConstantColor.Luminance">
            <summary>
            Get the luminance from an HSL model of color (0 - 1.0)
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantColor.Distance(Abodit.Expressions.TokenExpressionConstantColor)">
            <summary>
            Calculate the perceptual distance between two colors
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantColor.Distance(System.Double,System.Double,System.Double)">
            <summary>
            Calculate the perceptual distance between two colors
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantColor.GetClosestNamedColor(System.Double,System.Double,System.Double)">
            <summary>
            Get the closest named color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.INDIANRED">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.LIGHTCORAL">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.SALMON">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.DARKSALMON">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.LIGHTSALMON">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.CRIMSON">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.RED">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.FIREBRICK">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.DARKRED">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.PINK">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.LIGHTPINK">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.HOTPINK">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.DEEPPINK">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.MEDIUMVIOLETRED">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.PALEVIOLETRED">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.CORAL">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.TOMATO">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.ORANGERED">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.DARKORANGE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.ORANGE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.GOLD">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.YELLOW">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.LIGHTYELLOW">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.LEMONCHIFFON">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.LIGHTGOLDENRODYELLOW">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.PAPAYAWHIP">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.MOCCASIN">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.PEACHPUFF">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.PALEGOLDENROD">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.KHAKI">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.DARKKHAKI">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.LAVENDER">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.THISTLE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.PLUM">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.VIOLET">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.ORCHID">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.FUCHSIA">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.MAGENTA">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.MEDIUMORCHID">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.MEDIUMPURPLE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.REBECCAPURPLE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.BLUEVIOLET">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.DARKVIOLET">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.DARKORCHID">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.DARKMAGENTA">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.PURPLE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.INDIGO">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.SLATEBLUE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.DARKSLATEBLUE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.MEDIUMSLATEBLUE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.GREENYELLOW">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.CHARTREUSE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.LAWNGREEN">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.LIME">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.LIMEGREEN">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.PALEGREEN">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.LIGHTGREEN">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.MEDIUMSPRINGGREEN">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.SPRINGGREEN">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.MEDIUMSEAGREEN">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.SEAGREEN">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.FORESTGREEN">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.GREEN">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.DARKGREEN">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.YELLOWGREEN">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.OLIVEDRAB">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.OLIVE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.DARKOLIVEGREEN">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.MEDIUMAQUAMARINE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.DARKSEAGREEN">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.LIGHTSEAGREEN">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.DARKCYAN">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.TEAL">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.AQUA">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.CYAN">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.LIGHTCYAN">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.PALETURQUOISE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.AQUAMARINE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.TURQUOISE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.MEDIUMTURQUOISE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.DARKTURQUOISE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.CADETBLUE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.STEELBLUE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.LIGHTSTEELBLUE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.POWDERBLUE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.LIGHTBLUE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.SKYBLUE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.LIGHTSKYBLUE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.DEEPSKYBLUE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.DODGERBLUE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.CORNFLOWERBLUE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.ROYALBLUE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.MEDIUMBLUE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.DARKBLUE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.NAVY">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.MIDNIGHTBLUE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.CORNSILK">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.BLANCHEDALMOND">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.BISQUE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.NAVAJOWHITE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.WHEAT">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.BURLYWOOD">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.TAN">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.ROSYBROWN">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.SANDYBROWN">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.GOLDENROD">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.DARKGOLDENROD">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.PERU">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.CHOCOLATE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.SADDLEBROWN">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.SIENNA">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.BROWN">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.MAROON">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.WHITE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.SNOW">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.HONEYDEW">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.MINTCREAM">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.AZURE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.ALICEBLUE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.GHOSTWHITE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.WHITESMOKE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.SEASHELL">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.BEIGE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.OLDLACE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.FLORALWHITE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.IVORY">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.ANTIQUEWHITE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.LINEN">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.LAVENDERBLUSH">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.MISTYROSE">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.GAINSBORO">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.LIGHTGRAY">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.SILVER">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.DARKGRAY">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.GRAY">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.DIMGRAY">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.LIGHTSLATEGRAY">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.SLATEGRAY">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.DARKSLATEGRAY">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.BLACK">
             <summary>
             Color
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantColor.AllColors">
            <summary>
            All named colors
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionConstantDateTime">
            <summary>
            A constant date time TokenExpression
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionConstantDateTime.ValueDateTime">
            <summary>
            Gets the DateTime
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionConstantDateTime.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionConstantDateTime.Now">
            <summary>
            Gets a TokenExpressionConstantDateTime representing now
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantDateTime.#ctor(Abodit.Units.CalendarDateTime)">
            <summary>
            Creates a new <see cref="T:Abodit.Expressions.TokenExpressionConstantDateTime"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantDateTime.#ctor(System.DateTime)">
            <summary>
            Creates a new <see cref="T:Abodit.Expressions.TokenExpressionConstantDateTime"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantDateTime.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantDateTime.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantDateTime.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantDateTime.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantDateTime.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionConstantNull">
            <summary>
            The Null constant TokenExpression
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionConstantNull.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpressionConstantNull.Instance">
            <summary>
            Singleton instance of Null
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantNull.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantNull.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantNull.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantNull.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantNull.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionConstantString">
            <summary>
            A constant string TokenExpression
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionConstantString.ValueString">
            <summary>
            Gets the string value
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionConstantString.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantString.#ctor(System.String)">
            <summary>
            Creates a new instance of <see cref="T:Abodit.Expressions.TokenExpressionConstantString"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantString.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantString.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantString.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantString.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantString.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionConstantTime">
            <summary>
            A Time of day constant TokenExpression
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionConstantTime.ValueTime">
            <summary>
            Gets the Time value
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionConstantTime.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantTime.#ctor(Abodit.Units.Time)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionConstantTime"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantTime.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantTime.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantTime.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Compare to another TokenExpression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantTime.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConstantTime.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionUnits">
            <summary>
            Base class for Tokens that are a number and a unit of measure
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionUnits.ValueDouble">
            <summary>
            Gets the double value
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionUnits.Dimension">
            <summary>
            Any unitized expression has an immutable Dimension property
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionUnits.QuantityQualifier">
            <summary>
            Gets the QuantityQualifier
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionUnits.#ctor(System.IConvertible,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionUnits"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionUnits.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionUnits.Equals(Abodit.Expressions.TokenExpressionUnits)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionUnits.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionUnits.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionUnits.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionUnits.DoDescribe(System.Boolean,System.Int32)">
            <summary>
            Returns an English description of this object
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Env">
            <summary>
            An environment is a chain of linked stack frames containing variables
            or functions and their definitions
            It also handles undefining a value in the current stack frame
            </summary>
        </member>
        <member name="P:Abodit.Expressions.Env.TimeProvider">
            <summary>
            You can override the default time provider to evaluate an expression at a different point in time
            e.g. when someone last week said next week they mean this week
            </summary>
        </member>
        <member name="F:Abodit.Expressions.Env.undefinedValues">
            <summary>
            Tracks variables that have been marked undefined within this stack frame
            </summary>
        </member>
        <member name="F:Abodit.Expressions.Env.Empty">
            <summary>
            An empty environment
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Env.IsDefined(System.String)">
            <summary>
            Is there a definition for a given variable name
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Env.Get(System.String)">
            <summary>
            Get a given value
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Env.GetVariableType(System.String)">
            <summary>
            Get the type of a given variable
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Env.GetInternal(System.String)">
            <summary>
            Get a given value (or null)
            </summary>
        </member>
        <member name="P:Abodit.Expressions.Env.Variables">
            <summary>
            Get the variable names
            </summary>
        </member>
        <member name="P:Abodit.Expressions.Env.BoundValues">
            <summary>
            Gets the bound values
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Env.Undefine(System.String)">
            <summary>
            Undefines a value mutating the current environment
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Env.Assign(System.String,System.Object)">
            <summary>
            Assign mutates the current stack frame
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Env.Push">
            <summary>
            Push a new stack frame
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Env.Pop">
            <summary>
            Pop a stack frame
            </summary>
            <returns></returns>
        </member>
        <member name="M:Abodit.Expressions.Env.Equals(Abodit.Expressions.Env)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Env.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Env.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Env.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="P:Abodit.Expressions.Env.DebugDump">
            <summary>
            Dump the bound values to a string
            </summary>
        </member>
        <member name="T:Abodit.Expressions.ExpressionFactory">
            <summary>
            A factory class for creating Expressions
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ExpressionFactory.BetweenExpression``1(``0,``0)">
            <summary>
            Create an expression for dt >= start and dt &lt; end
            where start and end are constant values
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ExpressionFactory.After``1(``0)">
            <summary>
            Create an expression for dt >= start
            where start is a constant value
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ExpressionFactory.Before``1(``0)">
            <summary>
            Create an expression for dt &lt; end
            where end is a constant value
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ExpressionFactory.Equal``1(``0)">
            <summary>
            Create an expression for equal where value is a constant
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ExpressionFactory.ForScaleAndOffset(System.Double,System.Double)">
            <summary>
            Get an expression that scales a value and adds an offset
            but simplified for cases where scale is 1 and/or offset is zero
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ExpressionFactory.ForInverseScaleAndOffset(System.Double,System.Double)">
            <summary>
            Get an inverse expression that scales a value and adds an offset
            but simplified for cases where scale is 1 and/or offset is zero
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ExpressionFactory.Apply``5(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4,System.Boolean}},``0)">
            <summary>
            Partial application of first parameter
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ExpressionFactory.Apply``4(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,System.Boolean}},``0)">
            <summary>
            Partial application of first parameter
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ExpressionFactory.Apply``3(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,System.Boolean}},``0)">
            <summary>
            Partial application of first parameter
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ExpressionFactory.Apply``3(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,System.Boolean}},``0,``1)">
            <summary>
            Partial application of first and second parameter
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ExpressionFactory.Apply(System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.LambdaExpression)">
            <summary>
            Partially apply a value (or function) to an expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ExpressionFactory.Apply(System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.Expression)">
            <summary>
            Partially apply a value (or function) to an expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ExpressionFactory.Apply``2(System.Linq.Expressions.Expression{System.Func{``0,``1,System.Boolean}},``0)">
            <summary>
            Partially apply a value to an expression
            </summary>
        </member>
        <member name="T:Abodit.Expressions.ExpressionFactory.ExpressionSubstitute">
            <summary>
            An ExpressionVisitor for substitution
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ExpressionFactory.ExpressionSubstitute.#ctor(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Creates a new <see cref="T:Abodit.Expressions.ExpressionFactory.ExpressionSubstitute"/> visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ExpressionFactory.ExpressionSubstitute.Visit(System.Linq.Expressions.Expression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ExpressionFactory.ExpressionSubstitute.VisitParameter(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="T:Abodit.Expressions.ExpressionFactory.ExpressionParameterSubstitute">
            <summary>
            An ExpressionVisitor for parameter substitution
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ExpressionFactory.ExpressionParameterSubstitute.#ctor(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Expressions.ExpressionFactory.ExpressionParameterSubstitute"/> visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ExpressionFactory.ExpressionParameterSubstitute.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
            <summary>
            Visit a Lambda Expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ExpressionFactory.ExpressionParameterSubstitute.VisitParameter(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Visit a ParameterExpression
            </summary>
        </member>
        <member name="T:Abodit.Expressions.ITokenExpression">
            <summary>
            Interface for a TokenExpression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ITokenExpression.ToDouble``1(``0)">
            <summary>
            Convert the expression to a double
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ITokenExpression.ToDateTime``1(``0)">
            <summary>
            Convert the expression to a DateTime
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ITokenExpression.ToString``1(``0)">
            <summary>
            Convert the expression to a string
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ITokenExpression.ToBool``1(``0)">
            <summary>
            Convert the expression to a bool
            </summary>
        </member>
        <member name="P:Abodit.Expressions.ITokenExpression.UnboundVariables">
            <summary>
            Get the unbound variables used in the expression
            </summary>
        </member>
        <member name="P:Abodit.Expressions.ITokenExpression.UnboundFunctions">
            <summary>
            Get the unbound functions used in the expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ITokenExpression.Bind(System.String,System.Object)">
            <summary>
            Bind a variable name to a value
            </summary>
        </member>
        <member name="P:Abodit.Expressions.ITokenExpression.Text">
            <summary>
            Concrete tokens (i.e. ones we create using factories have actual text values)
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ITokenExpression.Serialize">
            <summary>
            Serialize the object to a string
            </summary>
            <returns></returns>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionAnd">
            <summary>
            A TokenExpression for a logical And
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionAnd.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionAnd.IsUnordered">
            <summary>
            Are the children of this expression un-ordered?
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionAnd.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionAnd.#ctor(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionAnd"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionAnd.#ctor(Abodit.Expressions.TokenExpression[])">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionAnd"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionAnd.CreateAndSimplify(System.Collections.Generic.IEnumerable{Abodit.Expressions.TokenExpression})">
            <summary>
            Create a new TokenExpressionAnd unless there is just one value in which case return it
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionAnd.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionAnd.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionAnd.CreateAndSimplify(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression)">
            <summary>
            Factory method to create an And Expression simplifying it as it's created
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionArray">
            <summary>
            An Array of Doubles (or at least we hope the expressions inside are doubles)
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionArray.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionArray.IsUnordered">
            <summary>
            Are the children unordered?
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionArray.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionArray.#ctor(Abodit.Expressions.TokenExpression[])">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionArray"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionArray.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionArray.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionArray.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionArray.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionArray.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionArray.GetTypeCode">
            <summary>
            Get the TypeCode for this conversion
            </summary>
            <returns></returns>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionArray.ToBoolean(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionArray.ToChar(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionArray.ToSByte(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionArray.ToByte(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionArray.ToInt16(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionArray.ToUInt16(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionArray.ToInt32(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionArray.ToUInt32(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionArray.ToInt64(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionArray.ToUInt64(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionArray.ToSingle(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionArray.ToDouble(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionArray.ToDecimal(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionArray.ToDateTime(System.IFormatProvider)">
            <summary>
            IConvertible
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionArray.ToString(System.IFormatProvider)">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionArray.ToType(System.Type,System.IFormatProvider)">
            <summary>
            Convert to a given type (IConvertible)
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionArray.Equals(Abodit.Expressions.TokenExpressionArray)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="T:Abodit.Expressions.ArrayConverter">
            <summary>
            A TypeConvertor for TokenExpressionArray values
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ArrayConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Returns true if conversion is possible
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ArrayConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
            Converts to the given destination type
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ArrayConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            Returns true if conversion is possible
            </summary>
        </member>
        <member name="M:Abodit.Expressions.ArrayConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            Converts from the given type
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionFunctionCall">
            <summary>
            Apply a named function
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionFunctionCall.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionFunctionCall.IsUnordered">
            <summary>
            Are the children unordered?
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionFunctionCall.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionFunctionCall.FunctionName">
            <summary>
            Get the function name
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionFunctionCall.#ctor(System.String,System.Type,Abodit.Expressions.TokenExpression[])">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionFunctionCall"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionFunctionCall.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionFunctionCall.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionFunctionCall.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionFunctionCall.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionFunctionCall.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionIntersection">
            <summary>
            Intersection of multiple ranges or sets
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionIntersection.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionIntersection.IsUnordered">
            <summary>
            Are the children unordered?
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionIntersection.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionIntersection.#ctor(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionIntersection"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionIntersection.#ctor(Abodit.Expressions.TokenExpression[])">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionIntersection"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionIntersection.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionIntersection.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionNary">
            <summary>
            And and Or can take an arbitrary number of parameters which simplifies many things
            when projecting to database queries
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionNary.Children">
            <summary>
            Gets the children TokenExpressions
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionNary.IsUnordered">
            <summary>
            Is this Nary sensitive to the order of its elements or not (for Equals)
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionNary.#ctor(Abodit.Expressions.TokenExpression[])">
            <summary>
            Creates a new <see cref="T:Abodit.Expressions.TokenExpressionNary"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionNary.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionNary.IsEqual``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>
            Tests that two lists are Equal (independeny of order)
            </summary>
            <remarks>
            Needs to move to a Utility class
            </remarks>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionNary.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionNary.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionOr">
            <summary>
            A TokenExpression for a logical OR
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionOr.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionOr.IsUnordered">
            <summary>
            Are the children unordered?
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionOr.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionOr.#ctor(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionOr"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionOr.#ctor(Abodit.Expressions.TokenExpression[])">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionOr"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionOr.CreateAndSimplify(System.Collections.Generic.IEnumerable{Abodit.Expressions.TokenExpression})">
            <summary>
            Create a new TokenExpressionOr unless there is just one value in which case return it
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionOr.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionOr.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionTernary">
            <summary>
            A Ternary operator TokenExpression
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionTernary.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionTernary.IsUnordered">
            <summary>
            Are the children ordered
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionTernary.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionTernary.Conditional">
            <summary>
            The condition
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionTernary.Truth">
            <summary>
            The value if true
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionTernary.Falsehood">
            <summary>
            The value if false
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionTernary.#ctor(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionTernary"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionTernary.#ctor(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression)">
            <summary>
            Creates a new <see cref="T:Abodit.Expressions.TokenExpressionTernary"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionTernary.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionTernary.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionTuple">
            <summary>
            A Tuple is a tuple of TokenExpressions grouped together as one unit
            e.g. Tuple (var:Name, var:Height, var:Width)
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionTuple.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionTuple.IsUnordered">
            <summary>
            Are the children unordered?
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionTuple.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionTuple.#ctor(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionTuple"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionTuple.#ctor(Abodit.Expressions.TokenExpression[])">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionTuple"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionTuple.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionTuple.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionUnion">
            <summary>
            Union of multiple ranges or sets
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionUnion.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionUnion.IsUnordered">
            <summary>
            Are the children unordered?
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionUnion.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionUnion.#ctor(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionUnion"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionUnion.#ctor(Abodit.Expressions.TokenExpression[])">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionUnion"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionUnion.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionUnion.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpression">
            <summary>
            A TokenExpression can represent a constant, a numeric expression, a temporal expression, ...
            AboditNLP handles both numeric types and types with units (km, celcius, ...), time and temporal expressions
            </summary>
            <remarks>
            Use TokenInt when you want an actual number like '3'
            Use TokenExpression when you want either a value or an expression
            All VALUES are EXPRESSIONS, just very simple ones
            TBD: Expressions that evaluate to an INT vs a DOUBLE??
            </remarks>
        </member>
        <member name="P:Abodit.Expressions.TokenExpression.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpression.Type">
            <summary>
            Get the Type that this Expression represents (if known)
            </summary>
            <remarks>
            Could this eventually become an IUnit? and have units for string, boolean etc.?
            </remarks>
        </member>
        <member name="P:Abodit.Expressions.TokenExpression.Unit">
            <summary>
            Get the unit that this field represents (if known), e.g. a Field has a TokenExpression on it of a known Unit type
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpression.Simplifier">
            <summary>
            An expression simplifier (singleton)
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpression.Serializer">
            <summary>
            An expression serializer (singleton)
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpression.UnboundVariablesVisitor">
            <summary>
            An expression serializer (singleton)
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpression.EnglishMetricVisitor">
            <summary>
            An expression to english visitor (singleton)
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpression.EnglishImperialVisitor">
            <summary>
            An expression to english visitor (singleton)
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.Evaluate``2(``0)">
            <summary>
            Evaluate the expression to get a value of type T
            If the expression does not evaluate to that type returns a Maybe not.
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.EvaluateDirect``1(``0)">
            <summary>
            Evaluate the expression to get a value of type T by evaluating the TokenExpression directly
            i.e. not using Expression and compiling it
            If the expression does not evaluate to that type returns a Maybe not.
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpression.Maybe`1">
            <summary>
            A Maybe may have a value or not, similar to Nullable (except it allows for T to be a struct or a class)
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpression.Maybe`1.Value">
            <summary>
            Gets the value
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpression.Maybe`1.HasValue">
            <summary>
            True if this has a value
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.ToDouble">
            <summary>
            Convert to a double value (or null if not one)
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.ToDouble``1(``0)">
            <summary>
            Convert to a double value (or null if not one)
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.ToBool``1(``0)">
            <summary>
            Convert to a bool value (or null if not one)
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.ToBool">
            <summary>
            Convert to a bool value (or null if not one)
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.ToString``1(``0)">
            <summary>
            Convert to a string value (or null if not one)
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.ToDateTime``1(``0)">
            <summary>
            Convert to a datetime value (or null if not one)
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.Convert``2">
            <summary>
            Try converting to an expression of a give type, or return null if wrong type
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.Invert(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpressionVariableAccess)">
            <summary>
            If y = f(x), find f'(y)
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.Simplify">
            <summary>
            Simplify this TokenExpression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.Serialize">
            <summary>
            Serialize this TokenExpression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.Describe(System.Boolean)">
            <summary>
            Returns an english version of this
            </summary>
            <returns></returns>
        </member>
        <member name="P:Abodit.Expressions.TokenExpression.UnboundVariables">
            <summary>
            Gets the unbound variables
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpression.UnboundFunctions">
            <summary>
            Gets the unbound functions
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.GetUnboundVariablesRecursive">
            <summary>
            Gets the unbound variables or functions
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.GetUnboundVariables">
            <summary>
            Gets the unbound variables or functions
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.Bind(System.String,System.Object)">
            <summary>
            Binds a variable to a value and returns a new TokenExpression with the substitution in place
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpression.Text">
            <summary>
            Gets the original text string
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpression.Null">
            <summary>
            The special Null TokenExpression
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpression.True">
            <summary>
            A True TokenExpression
            </summary>
        </member>
        <member name="F:Abodit.Expressions.TokenExpression.False">
            <summary>
            A False TokenExpression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            All TokenExpressions need to implement Equals() so that EqualityComparer can work
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.CombineAndExpressions(Abodit.Expressions.TokenExpression[])">
            <summary>
            Creates an AndExpression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.And(Abodit.Expressions.TokenExpression)">
            <summary>
            And with another expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.Or(Abodit.Expressions.TokenExpression)">
            <summary>
            Or with another expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.Add(Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new TokenExpression for Add
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.Subtract(Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new TokenExpression for Subtract
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.Multiply(Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new TokenExpression for Multiply
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.Divide(Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new TokenExpression for Divide
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.Power(Abodit.Expressions.TokenExpression)">
            <summary>
            Raise this TokenExpression to a power
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.Equal(Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new TokenExpression for Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.NotEqual(Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new TokenExpression for not equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.Greater(Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new TokenExpression for Greater
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.GreaterOrEqual(Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new TokenExpression for Greater or Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.Less(Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new TokenExpression for Less
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpression.LessOrEqual(Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new TokenExpression for Less or equals
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionEqualityComparer">
            <summary>
            A comparer for TokenExpressions (relies on TokenExpression itself being IEquatable
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionEqualityComparer.Equals(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression)">
            <summary>
            Compare two TokenExpressions for equality
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionEqualityComparer.GetHashCode(Abodit.Expressions.TokenExpression)">
            <summary>
            Get the hashcode
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionFormula">
            <summary>
            A non-constant expression
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionConvertToLocalDateTime">
            <summary>
            Converts an inner expression to a local datetime. Necessary because "on a wednesday"
            means a local datetime Wedesday. BUT this cannot work well for past events because of
            daylight savings time changes. Ick.
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionConvertToLocalDateTime.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionConvertToLocalDateTime.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConvertToLocalDateTime.#ctor(Abodit.Expressions.TokenExpression)">
            <summary>
            Creates a new <see cref="T:Abodit.Expressions.TokenExpressionConvertToLocalDateTime"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConvertToLocalDateTime.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionConvertToLocalDateTime.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionFieldAccess">
            <summary>
            Access a field on an IMetaEntity (NOT an IField (which is an expression)
            but the underlying database column name etc.(
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionFieldAccess.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionFieldAccess.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
            <remarks>
            The Type of a VariableAccess is known only for Enum fields
            all others will need to call Convert on it as necessary
            </remarks>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionFieldAccess.MetaEntity">
            <summary>
            Gets the MetaEntity (this is used to ensure that NLP matches entities to compatible expressions only)
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionFieldAccess.FullFieldName">
            <summary>
            Gets the fully qualified field name (e.g. Product.Price)
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionFieldAccess.#ctor(Abodit.Meta.IMetaEntity,System.String,System.Type)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionFieldAccess"/> class for a named field
            of a given type off a named entity
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionFieldAccess.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionFieldAccess.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionFieldAccess.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionFieldAccess.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionFieldAccess.GetHashCode">
            <summary>
            GetHashcode
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionIdentity">
            <summary>
            Identity is used to wrap parenthetical expressions
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionIdentity.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
            <remarks>
            Parenthetical expressions cannot be broken apart
            </remarks>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionIdentity.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionIdentity.#ctor(Abodit.Expressions.TokenExpression)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionIdentity"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionIdentity.ToString">
            <summary>
            Returns a string representation of this object
            </summary>
            <returns></returns>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionIdentity.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionNot">
            <summary>
            A TokenExpression for the logical Not operator
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionNot.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionNot.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionNot.#ctor(Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionNot"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionNot.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionNot.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionPropertyAccess">
            <summary>
            Access a property from a variable (or some other expression)
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionPropertyAccess.PropertyName">
            <summary>
            A string that decides how the propery is acessed, e.g. a property Name
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionPropertyAccess.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionPropertyAccess.#ctor(Abodit.Expressions.TokenExpression,System.Type,System.String)">
            <summary>
            Create a new instance of TokenExpressionPropertyAccess
            </summary>
            <param name="child">The object with the property on it</param>
            <param name="resultType">The type of the resulting expression</param>
            <param name="propertyName">The name of the property to pick</param>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionPropertyAccess.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionPropertyAccess.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionPropertyAccess.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionPropertyAccess.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionPropertyAccess.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionPropertyAccess.GetHashCode">
            <summary>
            GetHashcode
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionUnary">
            <summary>
            A unary expression has a single argument
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionUnary.Child">
            <summary>
            Get the child expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionUnary.#ctor(Abodit.Expressions.TokenExpression)">
            <summary>
            Creates a new unary expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionUnary.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionUnary.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionUnary.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionUnaryMinus">
            <summary>
            A TokenExpression for a unary minus operator
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionUnaryMinus.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionUnaryMinus.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionUnaryMinus.#ctor(Abodit.Expressions.TokenExpression)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionUnaryMinus"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionUnaryMinus.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionUnaryMinus.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenExpressionVariableAccess">
            <summary>
            Access a variable from the environment
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionVariableAccess.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionVariableAccess.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
            <remarks>
            The Type of a VariableAccess is known only for Enum fields
            all others will need to call Convert on it as necessary
            </remarks>
        </member>
        <member name="P:Abodit.Expressions.TokenExpressionVariableAccess.VariableName">
            <summary>
            Gets the variable name
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionVariableAccess.#ctor(System.String)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionVariableAccess"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionVariableAccess.#ctor(System.String,System.Type)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.TokenExpressionVariableAccess"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionVariableAccess.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts the visitor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionVariableAccess.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionVariableAccess.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionVariableAccess.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenExpressionVariableAccess.GetHashCode">
            <summary>
            Hashcode
            </summary>
        </member>
        <member name="T:Abodit.Expressions.UnboundVariableOrFunction">
            <summary>
            Structure returned from GetUnboundVariables
            </summary>
        </member>
        <member name="P:Abodit.Expressions.UnboundVariableOrFunction.Name">
            <summary>
            Get the name of this unbound variable or function
            </summary>
        </member>
        <member name="P:Abodit.Expressions.UnboundVariableOrFunction.IsFunction">
            <summary>
            Is this unbound object a function?
            </summary>
        </member>
        <member name="M:Abodit.Expressions.UnboundVariableOrFunction.#ctor(System.String,System.Boolean)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.UnboundVariableOrFunction"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.UnboundVariableOrFunction.Equals(Abodit.Expressions.UnboundVariableOrFunction)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.CanonicalizeUnitsVisitor">
            <summary>
            When the left hand side of a 'matches' expression is canonicalized we need to
            do the same for the right hand side
            </summary>
        </member>
        <member name="F:Abodit.Expressions.Visitor.CanonicalizeUnitsVisitor.Instance">
            <summary>
            Singleton instance of the <see cref="T:Abodit.Expressions.Visitor.CanonicalizeUnitsVisitor"/>
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.CanonicalizeUnitsVisitor.DoVisit(Abodit.Expressions.TokenExpressionVariableAccess)">
            <summary>
            Visitor method
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.CanonicalizeUnitsVisitor.DoVisit(Abodit.Expressions.TokenExpressionFieldAccess)">
            <summary>
            Visitor method
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.CanonicalizeUnitsVisitor.DoVisit(Abodit.Expressions.TokenExpressionUnits)">
            <summary>
            Visitor method
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.CanonicalizeUnitsVisitor.DoVisit(Abodit.Units.TimePeriod)">
            <summary>
            Visitor method
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.UndefinedResult">
            <summary>
            An undefined IConvertible result
            </summary>
        </member>
        <member name="F:Abodit.Expressions.Visitor.UndefinedResult.Undefined">
            <summary>
            An undefined IConvertible value
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.ConvertToValueVisitor`1">
            <summary>
            Evaluate an expression against type TSource (e.g. ISong, Env, ...)
            </summary>
        </member>
        <member name="P:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.TimeZoneOffset">
            <summary>
            A TimeZoneOffset for the local / UTC conversions
            </summary>
        </member>
        <member name="F:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.Undefined">
            <summary>
            A singleton Undefined value
            </summary>
        </member>
        <member name="F:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.variableGetter">
            <summary>
            Gets a field from an entity. TSource is typically a DataRow
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.#ctor(`0,System.Func{`0,System.String,System.IConvertible})">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Expressions.Visitor.ConvertToValueVisitor`1"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.ObjectGetter(`0,System.String)">
            <summary>
            A sample Getter for use against Objects (using reflection)
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.Visit(Abodit.Expressions.TokenExpression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.Visit(Abodit.Temporal.TemporalSet)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.VisitTemporal(Abodit.Temporal.TemporalSet)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.CreateCombo(Abodit.Expressions.TokenExpressionBinary,System.Func{System.IConvertible,System.IConvertible,System.IConvertible})">
            <summary>
            Create a combo from a binary expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.CreateCombo(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression,System.Func{System.IConvertible,System.IConvertible,System.IConvertible})">
            <summary>
            Create a combo from am expression 
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.CreateCombo(Abodit.Expressions.TokenExpressionNary,System.Func{System.IConvertible,System.IConvertible,System.IConvertible})">
            <summary>
            Create a combo from an Nary expression
            </summary>
        </member>
        <member name="F:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.True">
            <summary>
            The True Expression
            </summary>
        </member>
        <member name="F:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.False">
            <summary>
            The False Expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConvertToLocalDateTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAdd)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionMultiply)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionMatches)">
            <summary>
            Converts match (variable, temporal expression) into an expression returning a bool
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAnd)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionOr)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionTernary)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionTuple)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantNull)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantDateTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantString)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionArray)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionDivide)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenDouble)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionUnits)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Units.TimePeriod)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Units.TokenExpressionUnitConversion)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstant)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantBool)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantColor)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionEquals)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionGreater)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionGreaterOrEqual)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionNot)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionUnaryMinus)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionLess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionLessOrEqual)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionNotEquals)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionPower)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionSubtract)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionIdentity)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionPropertyAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionVariableAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionFieldAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionFunctionCall)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionIntersection)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionUnion)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetUnknown)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.InRange">
            <summary>
            Create a range test expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionRange)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteIntervals)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteSingleInterval)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetEvery)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteRepeatYearly)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteMonthYearList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteQuarterSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheNth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekend)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekday)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteAlways)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteQuantityOf)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetNever)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetIntersectionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetIntersectionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetUnionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetUnionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteMonthList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteShift)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteMonthSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheLast)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteAnyPeriod)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetHalfInfiniteAfter)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteAfter)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfWeekList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteHalfSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheXAfterY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfWeek)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfMonth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTimeExactInDay)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayInMonth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheXAfterY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteYear)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteYearList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheXBeforeY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteWellKnown)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteShift)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheLast)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheNth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Temporal.TemporalSetHalfInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionDataSource)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionWhere)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionSum)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionCount)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAverage)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAny)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAll)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToValueVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionSelect)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1">
            <summary>
            Evaluates the type of an expression using an environment
            </summary>
        </member>
        <member name="P:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.TimeZoneOffset">
            <summary>
            A TimeZoneOffset for the local / UTC conversions
            </summary>
        </member>
        <member name="F:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.Undefined">
            <summary>
            A singleton Undefined value
            </summary>
        </member>
        <member name="F:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.strict">
            <summary>
            Strict after all temporal sets and ranges have been converted, unstrict treats them as likely bool results
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.#ctor(System.Boolean)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.ObjectGetter(System.Type,System.String)">
            <summary>
            A sample Getter for use against Objects (using reflection)
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.Visit(Abodit.Expressions.TokenExpression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.Visit(Abodit.Temporal.TemporalSet)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.VisitTemporal(Abodit.Temporal.TemporalSet)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.CreateCombo(Abodit.Expressions.TokenExpressionBinary,System.Func{System.Type,System.Type,System.Type})">
            <summary>
            Create a combo from a binary expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.CreateCombo(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression,System.Func{System.Type,System.Type,System.Type})">
            <summary>
            Create a combo from am expression 
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.CreateCombo(Abodit.Expressions.TokenExpressionNary,System.Func{System.Type,System.Type,System.Type})">
            <summary>
            Create a combo from an Nary expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConvertToLocalDateTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAdd)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionMultiply)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionMatches)">
            <summary>
            Converts match (variable, temporal expression) into an expression returning a bool
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAnd)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionOr)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionTernary)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionTuple)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantNull)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantDateTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantString)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionArray)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionDivide)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenDouble)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionUnits)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Units.TimePeriod)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Units.TokenExpressionUnitConversion)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstant)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantBool)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantColor)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionEquals)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionGreater)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionGreaterOrEqual)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionNot)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionUnaryMinus)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionLess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionLessOrEqual)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionNotEquals)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionPower)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionSubtract)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionIdentity)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionPropertyAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionVariableAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionFieldAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionFunctionCall)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionIntersection)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionUnion)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetUnknown)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionRange)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteIntervals)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteSingleInterval)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetEvery)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteRepeatYearly)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteMonthYearList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteQuarterSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheNth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekend)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekday)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteAlways)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteQuantityOf)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetNever)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetIntersectionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetIntersectionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetUnionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetUnionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteMonthList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteShift)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteMonthSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheLast)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteAnyPeriod)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetHalfInfiniteAfter)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteAfter)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfWeekList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteHalfSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheXAfterY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfWeek)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfMonth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTimeExactInDay)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayInMonth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheXAfterY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteYear)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteYearList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheXBeforeY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteWellKnown)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteShift)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheLast)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheNth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Temporal.TemporalSetHalfInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionDataSource)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionWhere)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionSum)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionCount)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAverage)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAny)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAll)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EvaluateTypeVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionSelect)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor">
            <summary>
            Create a query expression (DateTime -> bool) against a DateTime field TSource
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.Visit(Abodit.Temporal.TemporalSet)">
            Default reference for TemporalSets is UTC NOW, i.e. in the last 3 hours works for a database call
            But yesterday needs to be calculated in LOCAL TIME and then bumped back to Utc time
            
            Should we instead have a TimeZoneOffset (TimeSpan) here?
            For relative temporal expressions it's not used: 3 hours ago is reference - 3 hours
            For Yesterday, Last week, ... the Utc database time needs to have the TimeZone offset added to it
            before comparing for the DatePart etc.
            DATEADD ("MINUTES" , tzOffset , date )
            
            Pass TimeSpan.Zero if the database stored LOCAL datetime values
            otherwise pass TimeZoneInfo....
            
            WHAT IF WE ASSUME ALL DATABASES USE DATETIMEOFFSET
            
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.CreateCombo(Abodit.Temporal.TemporalSet,Abodit.Temporal.TemporalSet,System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression},System.Func{System.Type,System.Type,System.Boolean})">
            <summary>
            Create a Lambda (or not) Expression from a create function
            </summary>
        </member>
        <member name="F:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.True">
            <summary>
            A True Expression
            </summary>
        </member>
        <member name="F:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.False">
            <summary>
            A False Expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.IsNumeric(System.Type)">
            <summary>
            Is this a numeric type
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.IsString(System.Type)">
            <summary>
            Is this a string type
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.IsBoolean(System.Type)">
            <summary>
            Is the argument a boolean type
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.IsDateTime(System.Type)">
            <summary>
            Is the argument a date time type
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.IsTemporalSet(System.Type)">
            <summary>
            Is the argument a TemporalSet type
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.IsTimeSpan(System.Type)">
            <summary>
            Is the argument a TimeSpan type
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.BothBoolean(System.Type,System.Type)">
            <summary>
            Are both arguments boolean
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.BothNumeric(System.Type,System.Type)">
            <summary>
            Are both arguments numeric
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.BothString(System.Type,System.Type)">
            <summary>
            Are both arguments string
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.CanCompare(System.Type,System.Type)">
            <summary>
            Are the arguments comparable with each other in an equality or comparison operation
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.CanMatch(System.Type,System.Type)">
            <summary>
            Are the arguments comparable with each other when converted to a Match expression?
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.LambdaOrPlain(System.Linq.Expressions.Expression,System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression})">
            <summary>
            If the input is a lambda expression, preserve the args in a new labdaexpression,
            otherwise just a body
            (a) => fn(a) becomes a => make(fn(a)) but 3 becomes make(3)
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetUnknown)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.InRange">
            <summary>
            Create a range test lambda expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.CreateConjunction(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression{System.Func{System.DateTime,System.Boolean}}},System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression})">
            <summary>
            Create a conjunction of two lambda expressions
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteIntervals)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteSingleInterval)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteSpecificDate)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteSpecificDecade)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetEvery)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteRepeatYearly)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteMonthYearList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteQuarterSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheNth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekend)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekday)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteAlways)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteQuantityOf)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetNever)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetIntersectionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetIntersectionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetUnionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetUnionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteMonthList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteShift)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteMonthSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheLast)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteAnyPeriod)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetHalfInfiniteAfter)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteAfter)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfWeekList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteHalfSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheXAfterY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfWeek)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfMonth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayInMonth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteTheXAfterY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteYear)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteYearList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteTheXBeforeY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteWellKnown)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteShift)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteTheLast)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteTheNth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetHalfInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertTemporalSetToExpressionVisitor.ChangeFirstParameter(System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.ParameterExpression)">
            <summary>
            Change the first parameter of a lambda expression
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1">
            <summary>
            Create a query expression against type TSource (e.g. ISong, Env, ...)
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.#ctor(System.Func{System.Linq.Expressions.Expression,System.String,System.Linq.Expressions.Expression})">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1"/> class
            </summary>
        </member>
        <member name="F:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.parameter">
            <summary>
            The source parameter for constructing Expressions
            </summary>
        </member>
        <member name="F:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.ItemProperty">
            Default reference for TemporalSets is UTC NOW, i.e. in the last 3 hours works for a database call
            But yesterday needs to be calculated in LOCAL TIME and then bumped back to Utc time
            
            Should we instead have a TimeZoneOffset (TimeSpan) here?
            For relative temporal expressions it's not used: 3 hours ago is reference - 3 hours
            For Yesterday, Last week, ... the Utc database time needs to have the TimeZone offset added to it
            before comparing for the DatePart etc.
            DATEADD ("MINUTES" , tzOffset , date )
            
            Pass TimeSpan.Zero if the database stored LOCAL datetime values
            otherwise pass TimeZoneInfo....
            
            WHAT IF WE ASSUME ALL DATABASES USE DATETIMEOFFSET
            
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.GetterForDataRow(System.Linq.Expressions.Expression,System.String,System.Data.DataColumnCollection)">
            <summary>
            A Getter for a DataRow that can be used in the constructor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.GetterForObjectUsingReflection(System.Linq.Expressions.Expression,System.String)">
            <summary>
            A Getter for an Object that can be used in the constructor
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.Visit(Abodit.Expressions.TokenExpression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.VisitTemporal(Abodit.Temporal.TemporalSet)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.CreateCombo(Abodit.Expressions.TokenExpressionBinary,System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression},System.Func{System.Type,System.Type,System.Boolean})">
            <summary>
            Create a Lambda (or not) Expression from a create function
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.CreateCombo(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression,System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression},System.Func{System.Type,System.Type,System.Boolean})">
            <summary>
            Create a Lambda (or not) Expression from a create function
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.CreateCombo(Abodit.Expressions.TokenExpressionNary,System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression},System.Func{System.Type,System.Boolean})">
            <summary>
            Create a Lambda (or not) Expression from a create function
            </summary>
        </member>
        <member name="F:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.True">
            <summary>
            A True Expression
            </summary>
        </member>
        <member name="F:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.False">
            <summary>
            A False Expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConvertToLocalDateTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAdd)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionMultiply)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionMatches)">
            <summary>
            Converts match (variable, temporal expression) into an expression returning a bool
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAnd)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionOr)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionTernary)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionTuple)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantNull)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantDateTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantString)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionArray)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionDivide)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenDouble)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionUnits)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Units.TimePeriod)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Units.TokenExpressionUnitConversion)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionRange)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstant)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantBool)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantColor)">
            <summary>
            Visit
            </summary>
            <remarks>
            Meaningless?
            </remarks>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionEquals)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionGreater)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionGreaterOrEqual)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionNot)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.LambdaOrPlain(System.Linq.Expressions.Expression,System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression})">
            <summary>
            If the input is a lambda expression, preserve the args in a new labdaexpression,
            otherwise just a body
            (a) => fn(a) becomes a => make(fn(a)) but 3 becomes make(3)
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.LambdaOrPlain(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            If the left or right is a lambda expression, preserve the args 
            in a new lambdaexpression, otherwise just a body
            (a) => fn(a) becomes a => make(fn(a)) but 3 becomes make(3)
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.LambdaOrPlain(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},System.Linq.Expressions.Expression)">
            <summary>
            If any of the child expressions is a lambda expression
            preserve the args in a new lambdaexpression, otherwise just a body
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionUnaryMinus)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionLess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionLessOrEqual)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionPropertyAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionVariableAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionFieldAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionFunctionCall)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionNotEquals)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionPower)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionSubtract)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionIdentity)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionIntersection)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionUnion)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetUnknown)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.InRange">
            <summary>
            Create a range test lambda expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.CreateConjunction(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression{System.Func{System.DateTime,System.Boolean}}},System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression})">
            <summary>
            Create a conjunction of two lambda expressions
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteIntervals)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteSingleInterval)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteSpecificDate)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteSpecificDecade)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetEvery)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteRepeatYearly)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteMonthYearList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteQuarterSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheNth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekend)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekday)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteAlways)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteQuantityOf)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetNever)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetIntersectionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetIntersectionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetUnionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetUnionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteMonthList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteShift)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteMonthSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheLast)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteAnyPeriod)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetHalfInfiniteAfter)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteAfter)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfWeekList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteHalfSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheXAfterY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfWeek)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfMonth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayInMonth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheXAfterY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteYear)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteYearList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheXBeforeY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteWellKnown)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteShift)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheLast)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheNth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Temporal.TemporalSetHalfInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.ChangeFirstParameter(System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.ParameterExpression)">
            <summary>
            Change the first parameter of a lambda expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionDataSource)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionWhere)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionSum)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionCount)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAverage)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAny)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAll)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ConvertToExpressionVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionSelect)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.ExpressionUndefined">
            <summary>
            An undefined Expression result
            </summary>
        </member>
        <member name="F:Abodit.Expressions.Visitor.ExpressionUndefined.Instance">
            <summary>
            A Lambda for the Undefined Expression
            </summary>
        </member>
        <member name="F:Abodit.Expressions.Visitor.ExpressionUndefined.DateTimeBoolInstance">
            <summary>
            A DateTime,bool Lambda for the Undefined Expression
            </summary>
        </member>
        <member name="P:Abodit.Expressions.Visitor.ExpressionUndefined.Type">
            <summary>
            Gets the type of this Expression
            </summary>
        </member>
        <member name="P:Abodit.Expressions.Visitor.ExpressionUndefined.NodeType">
            <summary>
            Gets the NodeType
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ExpressionUndefined.ToString">
            <summary>
            ToString
            </summary>
            <returns></returns>
        </member>
        <member name="T:Abodit.Expressions.Visitor.FieldRewriterVisitor">
            <summary>
            Rewrite field names
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.FieldRewriterVisitor.ToMongoDb(Abodit.Meta.IMetaEntity)">
            <summary>
            Clean the expression leaving just the bits MongoDB can handle
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.FieldRewriterVisitor.CleanMongoDb(Abodit.Meta.IMetaEntity)">
            <summary>
            Clean the expression removing anything MongoDB cannot handle
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.FieldRewriterVisitor.DoVisit(Abodit.Expressions.TokenExpressionVariableAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.FieldRewriterVisitor.DoVisit(Abodit.Units.TokenExpressionUnitConversion)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.FieldRewriterVisitor.DoVisit(Abodit.Expressions.TokenExpressionMatches)">
            <summary>
            Convert DateTimes to LocalDateTimes for Matched expressions against TemporalSets
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.FieldRewriterVisitor.DoVisit(Abodit.Expressions.TokenExpressionUnits)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.FieldRewriterVisitor.DoVisit(Abodit.Units.TimePeriod)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.FieldRewriterVisitor.DoVisit(Abodit.Expressions.TokenExpressionRange)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.ITemporalSetVisitor`1">
            <summary>
            A visitor for only TemporalExpressions
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.Visit(Abodit.Temporal.TemporalSet)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteSingleInterval)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetUnknown)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetEvery)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteRepeatYearly)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteMonthYearList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteQuarterSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheNth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekend)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekday)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteAlways)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteQuantityOf)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetNever)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetIntersectionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetIntersectionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetUnionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteAnyPeriod)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteMonthList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteShift)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteMonthSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheLast)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetHalfInfiniteAfter)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfWeekList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteHalfSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheXAfterY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfWeek)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfMonth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayInMonth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheXAfterY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteYear)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteYearList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheXBeforeY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteWellKnown)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteShift)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheLast)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheNth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetHalfInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetUnionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITemporalSetVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteAfter)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.ITokenExpressionVisitor`1">
            <summary>
            Interface for an expression visitor that visits both simple expressions and temporal sets
            </summary>
            <remarks>
            Considering splitting this into two separate interfaces and classes
            with a mutual interdependence.
            </remarks>
        </member>
        <member name="T:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1">
            <summary>
            Visit a TokenExpression (excluding temporal sets)
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.Visit(Abodit.Expressions.TokenExpression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.VisitTemporal(Abodit.Temporal.TemporalSet)">
            <summary>
            Visit temporal set (each solo visitor has its own way of implementing this part)
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionCount)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAverage)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAny)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionSelect)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionIdentity)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAll)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionPropertyAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionDataSource)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionVariableAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionFieldAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionFunctionCall)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionUnits)">
            <summary>
            Visit the abstract units class (concrete classes may rely on this to simplify implementation)
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionWhere)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Units.TimePeriod)">
            <summary>
            Visit a TimePeriod Set
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstant)">
            <summary>
            Visit an abstract constant, concrete constants may rely on this
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantNull)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantDateTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantString)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionArray)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantBool)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantColor)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenDouble)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConvertToLocalDateTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Units.TokenExpressionUnitConversion)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAdd)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionMatches)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionDivide)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionUnaryMinus)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionMultiply)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionPower)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionSubtract)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionNot)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAnd)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionOr)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionRange)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionTernary)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionIntersection)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionUnion)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionEquals)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionGreater)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionGreaterOrEqual)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionLess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionLessOrEqual)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionNotEquals)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionTuple)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionSum)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.TokenExpressionRebinder`1">
            <summary>
            Rebind a variable to a different TokenExpression, e.g. change a variable to a constant value
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionRebinder`1.#ctor(Abodit.Expressions.Env)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.Visitor.TokenExpressionRebinder`1"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionRebinder`1.DoVisit(Abodit.Expressions.TokenExpressionVariableAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.RegisteredFunction">
            <summary>
            A RegisteredFunction is used in two places. Firstly to instruct the parser what additional functions to recognize
            e.g. DATETPART(DatePart,DateTime,int) and secondly to generate the output (e.g. a SQL string) from a TokenExpression
            using that RegisteredFunction.
            </summary>
            <remarks>
            These registered functions may have special handling for arguments, e.g. SQL DATEPART first argument is not
            quoted.
            </remarks>
        </member>
        <member name="P:Abodit.Expressions.Visitor.RegisteredFunction.Name">
            <summary>
            Name of the function
            </summary>
        </member>
        <member name="P:Abodit.Expressions.Visitor.RegisteredFunction.ArgumentTypes">
            <summary>
            Argument types 
            </summary>
        </member>
        <member name="P:Abodit.Expressions.Visitor.RegisteredFunction.ResultType">
            <summary>
            Result Type 
            </summary>
        </member>
        <member name="P:Abodit.Expressions.Visitor.RegisteredFunction.Conversion">
            <summary>
            A function that converts an array of children into a SQL string
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.RegisteredFunction.Create``1(System.String,System.Func{Abodit.Expressions.TokenExpression[],System.String})">
            <summary>
            Create a new RegisteredFunction passing in a Func with the same signature
            </summary>
            <typeparam name="T">Must be a Func of the required signature</typeparam>
            <param name="name">Name of the function (e.g. SQL "DATEPART")</param>
            <param name="conversion">Conversion function</param>
            <returns>A new RegisteredFunction</returns>
        </member>
        <member name="T:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1">
            <summary>
            ConvertToSqlStringVisitor is similar to ConvertToExpression visitor but date expressions
            convert to DatePart where necessary and the filter is rendered as a string
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.Visit(Abodit.Temporal.TemporalSet)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteAfter)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.ChangeFirstParameter(System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.ParameterExpression)">
            <summary>
            Change the first parameter on a lambda expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteSingleInterval)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetUnknown)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetEvery)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteRepeatYearly)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteMonthYearList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteQuarterSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheNth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekend)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekday)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteAlways)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteQuantityOf)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetNever)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetIntersectionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetIntersectionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetUnionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteMonthList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteShift)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteMonthSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteAnyPeriod)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheLast)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetHalfInfiniteAfter)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfWeekList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteHalfSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheXAfterY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfWeek)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfMonth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayInMonth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheXAfterY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.InOrEquals(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Write an Equals or an In clause depending on the cardinality of the list
            </summary>
            <param name="sequence"></param>
            <returns></returns>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteYear)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteYearList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheXBeforeY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteWellKnown)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteShift)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheLast)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheNth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetHalfInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertTemporalSetToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetUnionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1">
            <summary>
            ConvertToSqlStringVisitor is similar to ConvertToExpression visitor
            but date expressions convert to DatePart where necessary and the filter
            is rendered as a string
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.Visit(Abodit.Expressions.TokenExpression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.Visit(Abodit.Temporal.TemporalSet)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.VisitTemporal(Abodit.Temporal.TemporalSet)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionIdentity)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionPropertyAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionVariableAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.BracketedNameFromDotted(System.String)">
            <summary>
            Fix table names that may have a schema name in them, e.g. dbo.table1 becomes [dbo].[table1]
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionFieldAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionFunctionCall)">
            <summary>
            Sql Function Names that can be translated to SQL Function calls
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantNull)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantDateTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantString)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionArray)">
            <summary>
            Visit array becomes just a list with no parentheses
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstant)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantBool)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConstantColor)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenDouble)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionIntersection)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionUnion)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionConvertToLocalDateTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAdd)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionMatches)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionDivide)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionUnaryMinus)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionMultiply)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionPower)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionSubtract)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionNot)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAnd)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionOr)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionTernary)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionTuple)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionRange)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionEquals)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionGreater)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionGreaterOrEqual)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionLess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionLessOrEqual)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionNotEquals)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionUnits)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Units.TimePeriod)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Units.TokenExpressionUnitConversion)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteAfter)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteSingleInterval)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetUnknown)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetEvery)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteRepeatYearly)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteMonthYearList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteQuarterSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheNth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTimeExactInDay)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekend)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekday)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteAlways)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteQuantityOf)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetNever)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetIntersectionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetIntersectionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetUnionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteMonthList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteShift)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteMonthSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheLast)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteAnyPeriod)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetHalfInfiniteAfter)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfWeekList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteHalfSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheXAfterY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfWeek)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfMonth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayInMonth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheXAfterY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteYear)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteYearList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheXBeforeY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteWellKnown)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteShift)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheLast)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetFiniteTheNth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetHalfInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Temporal.TemporalSetUnionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionDataSource)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionWhere)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionSum)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionCount)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAverage)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAny)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionAll)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitor`1.DoVisit(Abodit.Expressions.TokenExpressionSelect)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.Sql.TemporalConversionException">
            <summary>
            An exception that occurs during a temporal conversion
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.TemporalConversionException.#ctor(System.Type)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Expressions.Visitor.Sql.TemporalConversionException"/> class which is thrown for attempts to convert a TemporalExpression directly when it should be on the RHS of a matches expression
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitorBase">
            <summary>
            Base class for conversion to Sql strings, contains non-generic parts
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitorBase.DatePart">
            <summary>
            Represents the special DatePart component of SQL commands (which is a string without quotes on it)
            </summary>
        </member>
        <member name="F:Abodit.Expressions.Visitor.Sql.ConvertToSqlStringVisitorBase.RegisteredFunctions">
            <summary>
            A list of all SQL functions that can be used 
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.Sql.SqlParameter">
            <summary>
            A parameter for a call to SQL
            </summary>
        </member>
        <member name="P:Abodit.Expressions.Visitor.Sql.SqlParameter.ParameterName">
            <summary>
            Name of parameter
            </summary>
        </member>
        <member name="P:Abodit.Expressions.Visitor.Sql.SqlParameter.Type">
            <summary>
            The .NET Type of this parameter
            </summary>
        </member>
        <member name="P:Abodit.Expressions.Visitor.Sql.SqlParameter.ParameterValue">
            <summary>
            Value of the parameter
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.SqlParameter.#ctor(System.String,System.Type,System.Object)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.Visitor.Sql.SqlParameter"/> class
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.Sql.SqlQueryExpression">
            <summary>
            A Sql query created by parsing natural language with respect to a metamodel
            </summary>
        </member>
        <member name="P:Abodit.Expressions.Visitor.Sql.SqlQueryExpression.QueryString">
            <summary>
            The raw SQL command
            </summary>
        </member>
        <member name="P:Abodit.Expressions.Visitor.Sql.SqlQueryExpression.Parameters">
            <summary>
            The parameters
            </summary>
        </member>
        <member name="P:Abodit.Expressions.Visitor.Sql.SqlQueryExpression.OrderByClause">
            <summary>
            Optional order by clause
            </summary>
        </member>
        <member name="P:Abodit.Expressions.Visitor.Sql.SqlQueryExpression.Skip">
            <summary>
            How many records to skip
            </summary>
        </member>
        <member name="P:Abodit.Expressions.Visitor.Sql.SqlQueryExpression.Take">
            <summary>
            How many records to take
            </summary>
        </member>
        <member name="F:Abodit.Expressions.Visitor.Sql.SqlQueryExpression.Empty">
            <summary>
            An Empty SqlQueryExpression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.SqlQueryExpression.#ctor(System.String,Abodit.Expressions.Visitor.Sql.SqlParameter[])">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Expressions.Visitor.Sql.SqlQueryExpression"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.SqlQueryExpression.#ctor(System.String,Abodit.Expressions.Visitor.Sql.SqlParameter[],Abodit.Expressions.Visitor.Sql.SqlParameter[])">
            <summary>
            Creates a new SqlQueryExpression from a combined query string and two sets of parameters
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.SqlQueryExpression.op_Implicit(System.String)~Abodit.Expressions.Visitor.Sql.SqlQueryExpression">
            <summary>
            Implicit conversion from string to make it easier for commands without parameters
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.SqlQueryExpression.op_Addition(System.String,Abodit.Expressions.Visitor.Sql.SqlQueryExpression)">
            <summary>
            Concatenate two SqlQueryExpressions
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.SqlQueryExpression.op_Addition(Abodit.Expressions.Visitor.Sql.SqlQueryExpression,System.String)">
            <summary>
            Concatenate two SqlQueryExpressions
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.SqlQueryExpression.op_Addition(Abodit.Expressions.Visitor.Sql.SqlQueryExpression,Abodit.Expressions.Visitor.Sql.SqlQueryExpression)">
            <summary>
            Concatenate two SqlQueryExpressions
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.SqlQueryExpression.Prepend(System.String)">
            <summary>
            Prepend a string to the query expression text
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.SqlQueryExpression.Append(System.String)">
            <summary>
            Append a string to the query expression text
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.Sql.SqlQueryExpression.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.TemporalSetSimplifier">
            <summary>
            Simplifies any temporal set expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetSimplifier.DoVisit(Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetSimplifier.DoVisit(Abodit.Temporal.TemporalSetInfiniteAfter)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetSimplifier.DoVisit(Abodit.Temporal.TemporalSetInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetSimplifier.DoVisit(Abodit.Temporal.TemporalSetIntersectionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetSimplifier.DoVisit(Abodit.Temporal.TemporalSetIntersectionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetSimplifier.DoVisit(Abodit.Temporal.TemporalSetUnionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetSimplifier.DoVisit(Abodit.Temporal.TemporalSetFiniteTheNth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetSimplifier.DoVisit(Abodit.Temporal.TemporalSetFiniteTheXBeforeY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetSimplifier.DoVisit(Abodit.Temporal.TemporalSetUnionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.TemporalSetVisitor">
            <summary>
            Use this base-class visitor when you don't want to have to implement every method from the interface
            </summary>
            <remarks>
            Currently only used by <see cref="T:Abodit.Expressions.Visitor.TemporalSetSimplifier"/> 
            </remarks>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.Visit(Abodit.Temporal.TemporalSet)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteSingleInterval)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetUnknown)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetEvery)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteRepeatYearly)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteMonthYearList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteQuarterSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheNth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekend)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekday)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteAlways)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteQuantityOf)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetNever)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetIntersectionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetIntersectionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetUnionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteAnyPeriod)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteMonthList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteShift)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteMonthSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheLast)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetHalfInfiniteAfter)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfWeekList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteHalfSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheXAfterY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfWeek)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfMonth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayInMonth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteTheXAfterY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteYear)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteYearList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteTheXBeforeY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteWellKnown)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteShift)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteTheLast)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteTheNth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetHalfInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetUnionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TemporalSetVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteAfter)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor">
            <summary>
            A visitor to convert a TokenExpression to an English language form
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.#ctor(System.Boolean)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.Visit(Abodit.Expressions.TokenExpression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.Visit(Abodit.Temporal.TemporalSet)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.VisitTemporal(Abodit.Temporal.TemporalSet)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionMultiply)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionPropertyAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionVariableAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionFieldAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionFunctionCall)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionNotEquals)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionOr)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionTernary)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionTuple)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionPower)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionSubtract)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionIdentity)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetUnknown)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionIntersection)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionUnion)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetEvery)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteRepeatYearly)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteMonthYearList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteQuarterSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheNth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekend)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekday)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteAlways)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteQuantityOf)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetNever)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetIntersectionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetIntersectionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetUnionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetUnionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteMonthList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteShift)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteMonthSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheLast)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteAnyPeriod)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetHalfInfiniteAfter)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetHalfInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfWeekList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteHalfSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheXAfterY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfWeek)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfMonth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteTimeExactInDay)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayInMonth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteTheXAfterY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteYearList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteYear)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteTheXBeforeY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteShift)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteTheLast)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteTheNth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteAfter)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenDouble)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionUnits)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Units.TimePeriod)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Units.TokenExpressionUnitConversion)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionRange)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionConvertToLocalDateTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionConstantTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionConstantColor)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionArray)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionConstant)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionConstantBool)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionAdd)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionMatches)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionAnd)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionConstantNull)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionConstantDateTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionConstantString)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionDivide)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionEquals)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionGreater)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionGreaterOrEqual)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionNot)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionUnaryMinus)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteSingleInterval)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteWellKnown)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionLess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionLessOrEqual)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionDataSource)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionWhere)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionSum)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionCount)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionAverage)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionAny)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionAll)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionEnglishVisitor.DoVisit(Abodit.Expressions.TokenExpressionSelect)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.TokenExpressionFieldRewriteVisitor">
            <summary>
            Converts VariableAccess to FieldAccess annototating each access with the metaEntity
            (so that consistency can be ensured) and the type of the field so that type information
            is present.
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionFieldRewriteVisitor.#ctor(Abodit.Meta.IMetaEntity)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Expressions.Visitor.TokenExpressionFieldRewriteVisitor"/> class
            which converts VariableAccess to FieldAccess annotating each access with the MetaEntity
            so that consitency with field can be checked against IMetaEntities in parsed results
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionFieldRewriteVisitor.DoVisit(Abodit.Expressions.TokenExpressionVariableAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.TokenExpressionInvertVisitor">
            <summary>
            Invert a token expression (only works when there is a single x on the RHS)
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionInvertVisitor.#ctor(Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpressionVariableAccess)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.Visitor.TokenExpressionInvertVisitor"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionInvertVisitor.DoVisit(Abodit.Expressions.TokenExpressionMultiply)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionInvertVisitor.DoVisit(Abodit.Expressions.TokenExpressionVariableAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionInvertVisitor.DoVisit(Abodit.Expressions.TokenExpressionFunctionCall)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionInvertVisitor.DoVisit(Abodit.Expressions.TokenExpressionPower)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionInvertVisitor.DoVisit(Abodit.Expressions.TokenExpressionSubtract)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionInvertVisitor.DoVisit(Abodit.Expressions.TokenExpressionAdd)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionInvertVisitor.DoVisit(Abodit.Expressions.TokenExpressionDivide)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionInvertVisitor.DoVisit(Abodit.Expressions.TokenExpressionUnaryMinus)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.TokenExpressionSerializer">
            <summary>
            A visitor to convert a TokenExpression to a serialized form
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.Visit(Abodit.Expressions.TokenExpression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.Visit(Abodit.Temporal.TemporalSet)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.VisitTemporal(Abodit.Temporal.TemporalSet)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionMultiply)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionPropertyAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionVariableAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionFieldAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionFunctionCall)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionNotEquals)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionOr)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionTernary)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionTuple)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionPower)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionSubtract)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionIdentity)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetUnknown)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionIntersection)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionUnion)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetEvery)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetInfiniteRepeatYearly)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetFiniteMonthYearList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetInfiniteQuarterSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheNth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekend)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekday)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetInfiniteAlways)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetFiniteQuantityOf)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetNever)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetIntersectionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetIntersectionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetUnionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetInfiniteMonthList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetInfiniteShift)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetInfiniteMonthSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetInfiniteAnyPeriod)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheLast)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetHalfInfiniteAfter)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfWeek)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfWeekList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetInfiniteHalfSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheXAfterY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfMonth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetInfiniteTimeExactInDay)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayInMonth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetFiniteTheXAfterY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetFiniteYear)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetFiniteYearList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetFiniteTheXBeforeY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetFiniteWellKnown)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetFiniteShift)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetFiniteTheLast)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetFiniteTheNth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetHalfInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetInfiniteAfter)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetUnionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenDouble)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionUnits)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Units.TimePeriod)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Units.TokenExpressionUnitConversion)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionRange)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionConvertToLocalDateTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionConstantTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionArray)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionConstant)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionConstantBool)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionConstantColor)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionAdd)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionMatches)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionAnd)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionConstantNull)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionConstantDateTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionConstantString)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionDivide)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionEquals)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionGreater)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionGreaterOrEqual)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionNot)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionUnaryMinus)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Temporal.TemporalSetFiniteSingleInterval)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionLess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionLessOrEqual)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionDataSource)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionWhere)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionSum)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionCount)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionAverage)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionAny)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionAll)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSerializer.DoVisit(Abodit.Expressions.TokenExpressionSelect)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.TokenExpressionSimplifier">
            <summary>
            Simplifies any expression where it can convert math expressions into constants or
            boolean expressions that combine with true or false
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.VisitBinaryDoubleMath(Abodit.Expressions.TokenExpressionBinary,System.Func{System.Double,System.Double,System.Double},System.Func{Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression})">
            <summary>
            Visit a binary double math expression
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.VisitBinaryDoubleLogic(Abodit.Expressions.TokenExpressionBinary,System.Func{System.Double,System.Double,System.Boolean},System.Func{Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression})">
            <summary>
            Visit binary operators where constants can move from one side to another provided inverse operation is applied to other side
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.VisitBinaryStringLogic(Abodit.Expressions.TokenExpressionBinary,System.Func{System.String,System.String,System.Boolean},System.Func{Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression,Abodit.Expressions.TokenExpression})">
            <summary>
            Visit binary string logic
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.VisitCommutativeMath(Abodit.Expressions.TokenExpressionNary,System.Double,System.Func{System.Double,System.Double,System.Double},System.Func{System.Collections.Generic.IEnumerable{Abodit.Expressions.TokenExpression},Abodit.Expressions.TokenExpression})">
            <summary>
            Visit commutative math
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.VisitBoolLogic(Abodit.Expressions.TokenExpressionNary,System.Boolean,System.Func{System.Boolean,System.Boolean,System.Boolean},System.Func{System.Collections.Generic.IEnumerable{Abodit.Expressions.TokenExpression},Abodit.Expressions.TokenExpression})">
            <summary>
            Visit boolean logic
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Expressions.TokenExpressionConvertToLocalDateTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Expressions.TokenExpressionMatches)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Expressions.TokenExpressionAdd)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Expressions.TokenExpressionPower)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Expressions.TokenExpressionSubtract)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Expressions.TokenExpressionMultiply)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Expressions.TokenExpressionDivide)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Expressions.TokenExpressionUnaryMinus)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Expressions.TokenExpressionEquals)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Expressions.TokenExpressionUnion)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Expressions.TokenExpressionIntersection)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Temporal.TemporalSetInfiniteAfter)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Temporal.TemporalSetInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Temporal.TemporalSetIntersectionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Temporal.TemporalSetIntersectionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Temporal.TemporalSetUnionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Temporal.TemporalSetFiniteTheNth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Temporal.TemporalSetFiniteTheXBeforeY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Temporal.TemporalSetHalfInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Temporal.TemporalSetUnionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Expressions.TokenExpressionNotEquals)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Expressions.TokenExpressionGreater)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Expressions.TokenExpressionGreaterOrEqual)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Expressions.TokenExpressionLess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Expressions.TokenExpressionLessOrEqual)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Expressions.TokenExpressionNot)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Expressions.TokenExpressionAnd)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Expressions.TokenExpressionOr)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionSimplifier.DoVisit(Abodit.Expressions.TokenExpressionIdentity)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.EnumerableExtensions">
            <summary>
            Enumerable extension for enumerating a sequence except for a value
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.EnumerableExtensions.ExceptFirst``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Enumerate a sequence skipping the first instance of a given item
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.PowerGroup">
            <summary>
            A power group expression
            </summary>
        </member>
        <member name="P:Abodit.Expressions.Visitor.PowerGroup.TokenExpression">
            <summary>
            The TokenExpression
            </summary>
        </member>
        <member name="P:Abodit.Expressions.Visitor.PowerGroup.Exponent">
            <summary>
            The Exponent
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.QuadraticOrHigher">
            <summary>
            A Quadratic or higher expression
            </summary>
            <remarks>
            NOT CURRENTLY IN USE
            Simplifies abac to a^2 b c
            </remarks>
        </member>
        <member name="M:Abodit.Expressions.Visitor.QuadraticOrHigher.#ctor(Abodit.Expressions.TokenExpressionMultiply)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Expressions.Visitor.QuadraticOrHigher"/> class
            </summary>
        </member>
        <member name="T:Abodit.Expressions.Visitor.TokenExpressionVisitor">
            <summary>
            Use this base-class visitor when you don't want to have to implement every method from the interface
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Expressions.Visitor.TokenExpressionVisitor"/> class
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.Visit(Abodit.Expressions.TokenExpression)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.Visit(Abodit.Temporal.TemporalSet)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.VisitTemporal(Abodit.Temporal.TemporalSet)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionMultiply)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionPropertyAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionVariableAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionFieldAccess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Units.TokenExpressionUnitConversion)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionFunctionCall)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionNotEquals)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionOr)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionTernary)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionTuple)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionPower)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionSubtract)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionIdentity)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetUnknown)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetEvery)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionUnion)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionIntersection)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteRepeatYearly)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteMonthYearList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteQuarterSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheNth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekend)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekday)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteAlways)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteQuantityOf)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetNever)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetIntersectionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetIntersectionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetUnionFinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteMonthList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteShift)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteMonthSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheLast)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetHalfInfiniteAfter)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfWeekList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteHalfSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteWeekSpecific)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteAnyPeriod)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteTheXAfterY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfWeek)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayOfMonth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteTimeExactInDay)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteDayInMonth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteTheXAfterY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteYear)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteYearList)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteTheXBeforeY)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteWellKnown)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteShift)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteTheLast)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteTheNth)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetHalfInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteAfter)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetInfiniteBefore)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetUnionInfinite)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionConstant)">
            <summary>
            Visit an abstract constant
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionUnits)">
            <summary>
            Visit TokenExpressionUnits (an abstract class but all concretes call through here)
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenDouble)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Units.TimePeriod)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionRange)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionConvertToLocalDateTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionAdd)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionMatches)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionAnd)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionConstantNull)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionConstantDateTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionConstantTime)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionConstantString)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionDivide)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionConstantBool)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionConstantColor)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionEquals)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionGreater)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionGreaterOrEqual)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionNot)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionUnaryMinus)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Temporal.TemporalSetFiniteSingleInterval)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionLess)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionLessOrEqual)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionArray)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionSum)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionCount)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionAverage)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionAny)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionAll)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionDataSource)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionWhere)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="M:Abodit.Expressions.Visitor.TokenExpressionVisitor.DoVisit(Abodit.Expressions.TokenExpressionSelect)">
            <summary>
            Visit
            </summary>
        </member>
        <member name="T:Abodit.Graph.Graph`2">
            <summary>
            An in-memory graph of statements (subject, predicate, object)
            </summary>
        </member>
        <member name="T:Abodit.Graph.Graph`2.Edge">
            <summary>
            A relationship between two objects
            </summary>
        </member>
        <member name="F:Abodit.Graph.Graph`2.Edge.Start">
            <summary>
            The start node
            </summary>
        </member>
        <member name="F:Abodit.Graph.Graph`2.Edge.Predicate">
            <summary>
            The edge predicate (relation)
            </summary>
        </member>
        <member name="F:Abodit.Graph.Graph`2.Edge.End">
            <summary>
            The end node
            </summary>
        </member>
        <member name="M:Abodit.Graph.Graph`2.Edge.#ctor(`0,`1,`0)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Graph.Graph`2.Edge"/> class
            </summary>
        </member>
        <member name="M:Abodit.Graph.Graph`2.Edge.Equals(System.Object)">
            <summary>
            Compare an Edge with some other object
            </summary>
        </member>
        <member name="M:Abodit.Graph.Graph`2.Edge.GetHashCode">
            <summary>
            Get a hashcode for this object
            </summary>
        </member>
        <member name="P:Abodit.Graph.Graph`2.Limit">
            <summary>
            Limit the number of edges that can be attached to any node
            </summary>
        </member>
        <member name="F:Abodit.Graph.Graph`2.StartIndexedEdges">
            <summary>
            Edges arranged by start node
            </summary>
        </member>
        <member name="F:Abodit.Graph.Graph`2.EndIndexedEdges">
            <summary>
            Edges arrange by end node
            </summary>
        </member>
        <member name="M:Abodit.Graph.Graph`2.AddStatement(`0,`1,`0)">
            <summary>
            Add a statement, returns true if it was added, false if already there
            </summary>
            <remarks>
            Direct loops back to self are not allowed
            </remarks>
        </member>
        <member name="M:Abodit.Graph.Graph`2.AddStatement(Abodit.Graph.Graph{`0,`1}.Edge)">
            <summary>
            Add a statement, returns true if it was added, false if already there
            </summary>
        </member>
        <member name="P:Abodit.Graph.Graph`2.Nodes">
            <summary>
            Enumerate all the nodes
            </summary>
        </member>
        <member name="M:Abodit.Graph.Graph`2.GetNodes``1">
            <summary>
            Examine every node in the graph for ones of type T
            </summary>
        </member>
        <member name="P:Abodit.Graph.Graph`2.Edges">
            <summary>
            Get all the edges of the graph
            </summary>
        </member>
        <member name="M:Abodit.Graph.Graph`2.Follow(`0,`1)">
            <summary>
            Find all the outgoing edges from a vertex with a given predicate (or null)
            </summary>
            <remarks>
            A single step in the graph away from a node
            </remarks>
        </member>
        <member name="M:Abodit.Graph.Graph`2.Back(`0,`1)">
            <summary>
            Find all the outgoing edges from a vertex with a given predicate (or null)
            </summary>
        </member>
        <member name="M:Abodit.Graph.Graph`2.Successors``1(`0,`1)">
            <summary>
            Find all the outgoing edges from a vertex with a given predicate (or null) and keep following edges of that type
            match only nodes of type T. Return the results as a tree (can be flattened using SelectMany).
            </summary>
        </member>
        <member name="M:Abodit.Graph.Graph`2.Predecessors``1(`0,`1)">
            <summary>
            Find all the incoming edges from a vertex with a given predicate (or null) and keep following edges of that type
            match only nodes of type T. Return the results as a tree (can be flattened using SelectMany).
            </summary>
        </member>
        <member name="M:Abodit.Graph.Graph`2.DistanceToEverywhere(`0,System.Boolean,`1)">
            <summary>
            Get all the nodes that can be reached by following relationships of a given type
            returns them in sorted order according to how close they are
            so shortest path is returned first.  Tuple includes the distance.
            </summary>
            <remarks>
            Handles circular graphs too ...
            </remarks>
        </member>
        <member name="M:Abodit.Graph.Graph`2.ShortestPath(`0,`1,`0)">
            <summary>
            Get all the nodes on the shortest path from A to B by following relationships of type T
            </summary>
            <remarks>
            Handles circular graphs too ...
            </remarks>
        </member>
        <member name="M:Abodit.Graph.Graph`2.Search``1(`0,`1,Abodit.Graph.ISearchOrder{`0})">
            <summary>
            Perform a search of the graph following a given predicate looking for nodes of type T
            </summary>
        </member>
        <member name="M:Abodit.Graph.Graph`2.Union(Abodit.Graph.Graph{`0,`1})">
            <summary>
            Union two graphs
            </summary>
        </member>
        <member name="M:Abodit.Graph.Graph`2.Intersect(Abodit.Graph.Graph{`0,`1})">
            <summary>
            Intersect two graphs
            </summary>
        </member>
        <member name="M:Abodit.Graph.Graph`2.TopologicalSortApprox">
            <summary>
            Topological sort approx
            </summary>
        </member>
        <member name="M:Abodit.Graph.Graph`2.GetEnumerator">
            <summary>
            IEnumerable implementation
            </summary>
        </member>
        <member name="T:Abodit.Graph.Graph`2.PredicateNext">
            <summary>
            A predicate, object pair pointing forwards (stored in a linked list)
            </summary>
        </member>
        <member name="F:Abodit.Graph.Graph`2.PredicateNext.Predicate">
            <summary>
            The predicate on the edge
            </summary>
        </member>
        <member name="F:Abodit.Graph.Graph`2.PredicateNext.End">
            <summary>
            The node at the far end
            </summary>
        </member>
        <member name="P:Abodit.Graph.Graph`2.PredicateNext.Next">
            <summary>
            Linked next object
            </summary>
        </member>
        <member name="M:Abodit.Graph.Graph`2.PredicateNext.#ctor(`1,`0)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Graph.Graph`2.PredicateNext"/> class
            </summary>
        </member>
        <member name="M:Abodit.Graph.Graph`2.PredicateNext.Chain">
            <summary>
            Enumerates a chain of PredicateNext objects
            </summary>
            <returns></returns>
        </member>
        <member name="M:Abodit.Graph.Graph`2.PredicateNext.GetEnumerator">
            <summary>
            IEnumerable implementation
            </summary>
        </member>
        <member name="T:Abodit.Graph.Graph`2.PredicatePrevious">
            <summary>
            A predicate, object pair pointing backwards (stored in a linked list)
            </summary>
        </member>
        <member name="F:Abodit.Graph.Graph`2.PredicatePrevious.Predicate">
            <summary>
            The predicate (Edge type)
            </summary>
        </member>
        <member name="F:Abodit.Graph.Graph`2.PredicatePrevious.Start">
            <summary>
            The start node
            </summary>
        </member>
        <member name="F:Abodit.Graph.Graph`2.PredicatePrevious.Next">
            <summary>
            A linked list of further items
            </summary>
        </member>
        <member name="M:Abodit.Graph.Graph`2.PredicatePrevious.#ctor(`1,`0)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Graph.Graph`2.PredicatePrevious"/> class
            </summary>
        </member>
        <member name="M:Abodit.Graph.Graph`2.PredicatePrevious.Chain">
            <summary>
            Enumerates the chain
            </summary>
        </member>
        <member name="M:Abodit.Graph.Graph`2.PredicatePrevious.GetEnumerator">
            <summary>
            IEnumerable implementation
            </summary>
        </member>
        <member name="T:Abodit.Graph.IRelation">
            <summary>
            An interface that Relations in Graphs may implement to indicate reflexive relationships
            </summary>
        </member>
        <member name="P:Abodit.Graph.IRelation.IsReflexive">
            <summary>
            Is this relationship two-way?
            </summary>
        </member>
        <member name="T:Abodit.Graph.ISearchOrder`1">
            <summary>
            Interface for a search strategy
            </summary>
        </member>
        <member name="P:Abodit.Graph.ISearchOrder`1.Count">
            <summary>
            Count of how many items waiting
            </summary>
        </member>
        <member name="M:Abodit.Graph.ISearchOrder`1.Dequeue">
            <summary>
            Dequeue a value
            </summary>
        </member>
        <member name="M:Abodit.Graph.ISearchOrder`1.Enqueue(`0)">
            <summary>
            Enque a value
            </summary>
        </member>
        <member name="T:Abodit.Graph.BreadthFirstSearch`1">
            <summary>
            Breadth first strategy for queuing (i.e. use a Queue)
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Abodit.Graph.BreadthFirstSearch`1.Count">
            <summary>
            Count of items queued
            </summary>
        </member>
        <member name="M:Abodit.Graph.BreadthFirstSearch`1.Dequeue">
            <summary>
            Dequeue an item
            </summary>
        </member>
        <member name="M:Abodit.Graph.BreadthFirstSearch`1.Enqueue(`0)">
            <summary>
            Enqueue an item
            </summary>
        </member>
        <member name="T:Abodit.Graph.DepthFirstSearch`1">
            <summary>
            Depth first strategy for queuing (i.e. use a Stack)
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Abodit.Graph.DepthFirstSearch`1.Count">
            <summary>
            Count of items queued
            </summary>
        </member>
        <member name="M:Abodit.Graph.DepthFirstSearch`1.Dequeue">
            <summary>
            Dequeue an item
            </summary>
        </member>
        <member name="M:Abodit.Graph.DepthFirstSearch`1.Enqueue(`0)">
            <summary>
            Enqueue an item
            </summary>
        </member>
        <member name="T:Abodit.Graph.RandomFirstSearch`1">
            <summary>
            Random first search strategy (neither a queue nor a stack)
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Abodit.Graph.RandomFirstSearch`1.Count">
            <summary>
            Count of items queued
            </summary>
        </member>
        <member name="M:Abodit.Graph.RandomFirstSearch`1.Dequeue">
            <summary>
            Dequeue an item
            </summary>
        </member>
        <member name="M:Abodit.Graph.RandomFirstSearch`1.Enqueue(`0)">
            <summary>
            Enqueue an item
            </summary>
        </member>
        <member name="T:Abodit.Graph.Relation">
            <summary>
            A relationship between two nodes in a graph, e.g. parent, child, antonym, synonym, ...
            </summary>
        </member>
        <member name="P:Abodit.Graph.Relation.Name">
            <summary>
            Name of relation
            </summary>
        </member>
        <member name="P:Abodit.Graph.Relation.IsReflexive">
            <summary>
            Relation is reflexive
            </summary>
        </member>
        <member name="M:Abodit.Graph.Relation.GetByName(System.String,System.Boolean)">
            <summary>
            Get an identity-mapped relation by name
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.Antonym">
            <summary>
            The Antonym relation
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.Synonym">
            <summary>
            The synonym relation
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.MemberMeronymOf">
            <summary>
            The Member Meronym Of relation
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.PartMeronymOf">
            <summary>
            The PartMeronymOf relation
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.HolonymOf">
            <summary>
            The HolynymOf relation
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.SimilarTo">
            <summary>
            The SimilarTo relation
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.ClassifiedByTopic">
            <summary>
            Classified by topic: points to another Noun
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.ClassifiedByRegion">
            <summary>
            Classified by region (points to a geographic region)
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.ClassifiedByUsage">
            <summary>
            Classified by usage
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.PertainsTo">
            <summary>
            PertainsTo
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.DerivationallyRelated">
            <summary>
            Derivationally related, e.g. China, chinese
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.Related">
            <summary>
            Related (but not derivationally), e.g. knives and forks
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.Domain">
            <summary>
            Domain is used to describe another predicate, i.e. what can go on its left hand side
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.Range">
            <summary>
            Range is used to describe another predicate, i.e. what can go on its right hand side
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.WordFor">
            <summary>
            Points to a word node for a synset
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.NounForm">
            <summary>
            Points to a noun form
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.VerbForm">
            <summary>
            Points to a verb form
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.AdjectiveForm">
            <summary>
            Points to an adjective form
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.AdjectivePositive">
            <summary>
            Points to a positive adjective form (obsolete - positive and negative are context dependent)
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.AdjectiveNegative">
            <summary>
            Points to a negative adjective form (obsolete - positive and negative are context dependent)
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.SuperlativeForm">
            <summary>
            Points to a superlative form
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.ComparativeForm">
            <summary>
            Points to a comparative form
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.AdverbForm">
            <summary>
            Points to an adverb form
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.PastTense">
            <summary>
            Points to a past tense
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.FutureTense">
            <summary>
            Points to a future tense
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.PastParticiple">
            <summary>
            Points to a past participle
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.PresentParticiple">
            <summary>
            Points to a present participle (gerund)
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.FirstPersonSingular">
            <summary>
            Points to a fisrt person singular word form
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.FirstPersonPlural">
            <summary>
            Points to a fisrt person plural word form
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.SingularForm">
            <summary>
            Points to a singular word form
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.PluralForm">
            <summary>
            Points to a plural word form
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.CollectiveNoun">
            <summary>
            Points to a collective noun word form
            </summary>
        </member>
        <member name="F:Abodit.Graph.Relation.RDFSType">
            <summary>
            Points to a parent type (e.g. lion is a mammal)
            </summary>
        </member>
        <member name="M:Abodit.Graph.Relation.Equals(Abodit.Graph.Relation)">
            <summary>
            Compares two Relations for equality (reference equals)
            </summary>
        </member>
        <member name="M:Abodit.Graph.Relation.ToString">
            <summary>
            Returns the name of this relation as an arrow text
            </summary>
        </member>
        <member name="T:Abodit.Meta.BoolFormatter">
            <summary>
            An IFormatProvider and ICustomProvider for formatting a bool value to one of two strings
            </summary>
        </member>
        <member name="P:Abodit.Meta.BoolFormatter.On">
            <summary>
            Get the On value
            </summary>
        </member>
        <member name="P:Abodit.Meta.BoolFormatter.Off">
            <summary>
            Get the Off value
            </summary>
        </member>
        <member name="M:Abodit.Meta.BoolFormatter.#ctor(System.String,System.String)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Meta.BoolFormatter"/> class
            </summary>
        </member>
        <member name="M:Abodit.Meta.BoolFormatter.GetFormat(System.Type)">
            <summary>
            IConvertible implementation
            </summary>
        </member>
        <member name="M:Abodit.Meta.BoolFormatter.Format(System.String,System.Object,System.IFormatProvider)">
            <summary>
            IConvertible implementation
            </summary>
        </member>
        <member name="T:Abodit.Meta.Cardinality">
            <summary>
            Cardinality of a relationship (1:1, 1:many, ...)
            </summary>
        </member>
        <member name="P:Abodit.Meta.Cardinality.Name">
            <summary>
            Gets the name of this <see cref="T:Abodit.Meta.Cardinality"/>
            </summary>
        </member>
        <member name="P:Abodit.Meta.Cardinality.In">
            <summary>
            Gets the In count
            </summary>
        </member>
        <member name="P:Abodit.Meta.Cardinality.Out">
            <summary>
            Gets the Out count
            </summary>
        </member>
        <member name="M:Abodit.Meta.Cardinality.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Meta.Cardinality"/> class
            </summary>
        </member>
        <member name="F:Abodit.Meta.Cardinality.OneToOne">
            <summary>
            A Cardinality of 1:1
            </summary>
        </member>
        <member name="F:Abodit.Meta.Cardinality.OneToTwo">
            <summary>
            A Cardinality of 1:2
            </summary>
        </member>
        <member name="F:Abodit.Meta.Cardinality.OneToMany">
            <summary>
            A Cardinality of 1:Many
            </summary>
        </member>
        <member name="F:Abodit.Meta.Cardinality.ManyToOne">
            <summary>
            A Cardinality of Many:1
            </summary>
        </member>
        <member name="F:Abodit.Meta.Cardinality.ManyToMany">
            <summary>
            A Cardinality of Many:Many
            </summary>
        </member>
        <member name="T:Abodit.Meta.Cell">
            <summary>
            A Cell containing data within a Row within a PagedTable returned from a natural language query
            </summary>
        </member>
        <member name="P:Abodit.Meta.Cell.Index">
            <summary>
            Gets the index of the cell
            </summary>
        </member>
        <member name="P:Abodit.Meta.Cell.Field">
            <summary>
            Gets the field this cell belongs to
            </summary>
        </member>
        <member name="P:Abodit.Meta.Cell.Value">
            <summary>
            Gets the cell value
            </summary>
        </member>
        <member name="M:Abodit.Meta.Cell.#ctor(System.Int32,Abodit.Meta.IField,System.Object)">
            <summary>
            Creates a new <see cref="T:Abodit.Meta.Cell"/>
            </summary>
        </member>
        <member name="M:Abodit.Meta.Cell.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Meta.DateTimeAgoFormatter">
            <summary>
            An IFormatProvider and ICustomFormatter for DateTimeAgo values
            </summary>
        </member>
        <member name="M:Abodit.Meta.DateTimeAgoFormatter.GetFormat(System.Type)">
            <summary>
            Gets this when the formatType is ICustomFormatter
            </summary>
        </member>
        <member name="M:Abodit.Meta.DateTimeAgoFormatter.Format(System.String,System.Object,System.IFormatProvider)">
            <summary>
            Format a DateTime as a time ago string
            </summary>
        </member>
        <member name="T:Abodit.Meta.DurationFormatter">
            <summary>
            An IFormatProvider and ICustomProvider for durayions
            </summary>
        </member>
        <member name="M:Abodit.Meta.DurationFormatter.GetFormat(System.Type)">
            <summary>
            Get the format if it's an ICustomFormatter
            </summary>
        </member>
        <member name="M:Abodit.Meta.DurationFormatter.Format(System.String,System.Object,System.IFormatProvider)">
            <summary>
            Return the formatted string
            </summary>
        </member>
        <member name="T:Abodit.Meta.EntityExpression">
            <summary>
            An EntityExpression is a wrapper around a TokenExpression that maintains the MetaEntity
            from which the TokenExpression was derived and ensures that it is not possible to
            mix IField expressions from different IMetaEntities
            </summary>
        </member>
        <member name="P:Abodit.Meta.EntityExpression.TokenExpression">
            <summary>
            The expression tied to this meta field
            </summary>
        </member>
        <member name="P:Abodit.Meta.EntityExpression.MetaEntity">
            <summary>
            The MetaEntity to which this expression belongs
            </summary>
        </member>
        <member name="M:Abodit.Meta.EntityExpression.#ctor(Abodit.Expressions.TokenExpression,Abodit.Meta.IMetaEntity)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Meta.EntityExpression"/> class
            </summary>
        </member>
        <member name="T:Abodit.Meta.IEnumValue">
            <summary>
            A value that is allowed for some field, e.g. a country name
            </summary>
        </member>
        <member name="P:Abodit.Meta.IEnumValue.Value">
            <summary>
            The value associated with this enum instance
            </summary>
        </member>
        <member name="P:Abodit.Meta.IEnumValue.Parent">
            <summary>
            The field that this Enum belongs to
            </summary>
        </member>
        <member name="T:Abodit.Meta.EnumValue">
            <summary>
            An EnumValue that belongs to an IField
            </summary>
        </member>
        <member name="P:Abodit.Meta.EnumValue.Name">
            <summary>
            Gets the name
            </summary>
        </member>
        <member name="P:Abodit.Meta.EnumValue.Parent">
            <summary>
            Get the parent field
            </summary>
        </member>
        <member name="P:Abodit.Meta.EnumValue.MetaSynSets">
            <summary>
            The MetaSynsets
            </summary>
        </member>
        <member name="P:Abodit.Meta.EnumValue.Value">
            <summary>
            The value
            </summary>
        </member>
        <member name="M:Abodit.Meta.EnumValue.#ctor(System.String,System.Object,Abodit.Meta.MetaSynset[])">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Meta.EnumValue"/> class
            </summary>
        </member>
        <member name="M:Abodit.Meta.EnumValue.Equals(Abodit.Meta.IMeta)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Meta.EnumValue.SetParent(Abodit.Meta.IFieldEnum)">
            <summary>
            Set the Parent field
            </summary>
        </member>
        <member name="M:Abodit.Meta.EnumValue.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Meta.EnumValue`1">
            <summary>
            A typed EnumValue
            </summary>
        </member>
        <member name="P:Abodit.Meta.EnumValue`1.ValueAsT">
            <summary>
            Gets the value
            </summary>
        </member>
        <member name="M:Abodit.Meta.EnumValue`1.#ctor(System.String,`0,Abodit.Meta.MetaSynset[])">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Meta.EnumValue`1"/> class
            </summary>
        </member>
        <member name="T:Abodit.Meta.FieldBooleanExpression">
            <summary>
            A field representing an TokenExpression that returns a boolean result
            </summary>
        </member>
        <member name="M:Abodit.Meta.FieldBooleanExpression.#ctor(Abodit.Meta.IMetaEntity,Abodit.Expressions.TokenExpression,Abodit.Meta.MetaSynset,System.IFormatProvider,Abodit.Meta.FieldQualifier[])">
            <summary>
            Creates a new <see cref="T:Abodit.Meta.FieldBooleanExpression"/>
            </summary>
        </member>
        <member name="M:Abodit.Meta.FieldBooleanExpression.#ctor(Abodit.Meta.IMetaEntity,Abodit.Expressions.TokenExpression,Abodit.Meta.MetaSynset[],System.IFormatProvider,Abodit.Meta.FieldQualifier[])">
            <summary>
            Creates a new <see cref="T:Abodit.Meta.FieldBooleanExpression"/>
            </summary>
        </member>
        <member name="T:Abodit.Meta.FieldDate">
            <summary>
            A field representing an TokenExpression that returns a DateTime result
            </summary>
        </member>
        <member name="M:Abodit.Meta.FieldDate.#ctor(Abodit.Meta.IMetaEntity,System.String,Abodit.Units.IUnit,Abodit.Meta.MetaSynset[],Abodit.Units.Dimensions.Qualifier[],System.IFormatProvider,Abodit.Meta.FieldQualifier[])">
            <summary>
            Creates a new <see cref="T:Abodit.Meta.FieldDate"/>
            </summary>
        </member>
        <member name="M:Abodit.Meta.FieldDate.#ctor(Abodit.Meta.IMetaEntity,Abodit.Expressions.TokenExpression,Abodit.Units.IUnit,Abodit.Meta.MetaSynset[],Abodit.Units.Dimensions.Qualifier[],System.IFormatProvider,Abodit.Meta.FieldQualifier[])">
            <summary>
            Creates a new <see cref="T:Abodit.Meta.FieldDate"/>
            </summary>
        </member>
        <member name="T:Abodit.Meta.FieldEnum">
            <summary>
            A field that is an FieldEnum has specific set values that are themselves
            words that can be used in a query, e.g. "open", "closed"
            </summary>
        </member>
        <member name="P:Abodit.Meta.FieldEnum.EnumValues">
            <summary>
            Gets the possible EnumValues
            </summary>
        </member>
        <member name="M:Abodit.Meta.FieldEnum.#ctor(Abodit.Meta.IMetaEntity,System.String,Abodit.Meta.EnumValue[],System.Type,System.IFormatProvider,Abodit.Meta.FieldQualifier[])">
            <summary>
            Creates a new <see cref="T:Abodit.Meta.FieldEnum"/>
            </summary>
        </member>
        <member name="T:Abodit.Meta.FieldEnumBool">
            <summary>
            A field that is true or false
            </summary>
        </member>
        <member name="P:Abodit.Meta.FieldEnumBool.ValueTrue">
            <summary>
            The EnumValue representing a true value
            </summary>
        </member>
        <member name="P:Abodit.Meta.FieldEnumBool.ValueFalse">
            <summary>
            The EnumValue representing a false value
            </summary>
        </member>
        <member name="M:Abodit.Meta.FieldEnumBool.#ctor(Abodit.Meta.IMetaEntity,System.String,Abodit.Meta.EnumValue,Abodit.Meta.EnumValue,System.IFormatProvider,Abodit.Meta.FieldQualifier[])">
            <summary>
            Creates a new <see cref="T:Abodit.Meta.FieldEnumBool"/>
            </summary>
        </member>
        <member name="T:Abodit.Meta.FieldNumeric">
            <summary>
            A field representing a TokenExpression that returns a numeric
            </summary>
        </member>
        <member name="M:Abodit.Meta.FieldNumeric.#ctor(Abodit.Meta.IMetaEntity,Abodit.Expressions.TokenExpression,Abodit.Units.IUnit,Abodit.Meta.MetaSynset[],Abodit.Units.Dimensions.Qualifier[],System.IFormatProvider,Abodit.Meta.FieldQualifier[])">
            <summary>
            Creates a new <see cref="T:Abodit.Meta.FieldNumeric"/>
            </summary>
        </member>
        <member name="M:Abodit.Meta.FieldNumeric.#ctor(Abodit.Meta.IMetaEntity,System.String,Abodit.Units.IUnit,Abodit.Meta.MetaSynset[],Abodit.Units.Dimensions.Qualifier[],System.IFormatProvider,Abodit.Meta.FieldQualifier[])">
            <summary>
            Creates a new <see cref="T:Abodit.Meta.FieldNumeric"/> for a named property
            </summary>
        </member>
        <member name="T:Abodit.Meta.FieldNumericOrDate">
            <summary>
            A field representing a TokenExpression that returns a double or DateTime result
            </summary>
        </member>
        <member name="P:Abodit.Meta.FieldNumericOrDate.Qualifiers">
            <summary>
            Dimension qualifier (e.g. width vs length, internal vs external, ...)
            TODO: Can this be merged with the other qualifiers?
            </summary>
        </member>
        <member name="M:Abodit.Meta.FieldNumericOrDate.#ctor(Abodit.Meta.IMetaEntity,Abodit.Expressions.TokenExpression,Abodit.Units.IUnit,Abodit.Meta.MetaSynset[],Abodit.Units.Dimensions.Qualifier[],System.IFormatProvider,Abodit.Meta.FieldQualifier[])">
            <summary>
            Creates a new <see cref="T:Abodit.Meta.FieldNumericOrDate"/>
            </summary>
        </member>
        <member name="T:Abodit.Meta.IFieldQualifier">
            <summary>
            A field qualifier (e.g. average vs maximum)
            </summary>
        </member>
        <member name="T:Abodit.Meta.FieldQualifier">
            <summary>
            FieldQualifiers appear on fields to 'qualify' them, e.g. (important), (encrypted), ...
            </summary>
        </member>
        <member name="P:Abodit.Meta.FieldQualifier.Name">
            <summary>
            Gets the name
            </summary>
        </member>
        <member name="P:Abodit.Meta.FieldQualifier.MetaSynSets">
            <summary>
            Gets the metasynsets
            </summary>
        </member>
        <member name="P:Abodit.Meta.FieldQualifier.SynsetNames">
            <summary>
            Gets the synset names
            </summary>
        </member>
        <member name="F:Abodit.Meta.FieldQualifier.All">
            <summary>
            Gets all possible FieldQualifiers that have been instantiated
            </summary>
        </member>
        <member name="F:Abodit.Meta.FieldQualifier.Important">
            <summary>
            Important fields show in list results
            </summary>
        </member>
        <member name="F:Abodit.Meta.FieldQualifier.Metric">
            <summary>
            A field containing a metric value
            </summary>
            <remarks>
            TODO: Do we need this when we have Units?
            </remarks>
        </member>
        <member name="F:Abodit.Meta.FieldQualifier.Imperial">
            <summary>
            A field containing a non-metric value
            </summary>
            <remarks>
            TODO: Do we need this when we have Units?
            </remarks>
        </member>
        <member name="F:Abodit.Meta.FieldQualifier.UtcDateTime">
            <summary>
            A field containing a Utc DateTime
            </summary>
        </member>
        <member name="F:Abodit.Meta.FieldQualifier.LocalDateTime">
            <summary>
            A field containing a local date time
            </summary>
        </member>
        <member name="F:Abodit.Meta.FieldQualifier.Normal">
            <summary>
            A field containing a 'normal' value
            </summary>
        </member>
        <member name="F:Abodit.Meta.FieldQualifier.Minimum">
            <summary>
            A field containing a minimum value
            </summary>
        </member>
        <member name="F:Abodit.Meta.FieldQualifier.Maximum">
            <summary>
            A field containing a maximum value
            </summary>
        </member>
        <member name="F:Abodit.Meta.FieldQualifier.Average">
            <summary>
            A field containing an average value
            </summary>
        </member>
        <member name="M:Abodit.Meta.FieldQualifier.Equals(Abodit.Meta.IMeta)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Meta.FieldQualifier.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Meta.FieldText">
            <summary>
            A meta field for a string value
            </summary>
        </member>
        <member name="M:Abodit.Meta.FieldText.#ctor(Abodit.Meta.IMetaEntity,System.String,Abodit.Meta.MetaSynset[],Abodit.Meta.FieldQualifier[])">
            <summary>
            Creates a new <see cref="T:Abodit.Meta.FieldText"/>
            </summary>
        </member>
        <member name="M:Abodit.Meta.FieldText.#ctor(Abodit.Meta.IMetaEntity,Abodit.Expressions.TokenExpression,Abodit.Meta.MetaSynset[],Abodit.Meta.FieldQualifier[])">
            <summary>
            Creates a new <see cref="T:Abodit.Meta.FieldText"/>
            </summary>
        </member>
        <member name="M:Abodit.Meta.FieldText.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Meta.IField">
            <summary>
            A meta field (really an expression referencing one or more fields), part of a <see cref="T:Abodit.Meta.IMetaEntity"/>
            </summary>
        </member>
        <member name="P:Abodit.Meta.IField.TokenExpression">
            <summary>
            An expression giving access to the property (or a calculated expression using more than one property)
            </summary>
            <remarks>
            This expression should use <see cref="T:Abodit.Expressions.TokenExpressionVariableAccess"/> to get to entities (e.g. Product, Person, ...)
            and <see cref="T:Abodit.Expressions.TokenExpressionPropertyAccess"/> to get to the fields on that table or object.
            </remarks>
        </member>
        <member name="P:Abodit.Meta.IField.Unit">
            <summary>
            The Unit of this IFIeld
            </summary>
        </member>
        <member name="P:Abodit.Meta.IField.FieldQualifiers">
            <summary>
            Any FieldQualifiers
            </summary>
        </member>
        <member name="P:Abodit.Meta.IField.FormatProvider">
            <summary>
            A format provider for formatting the field
            </summary>
        </member>
        <member name="T:Abodit.Meta.IFieldText">
            <summary>
            A text field has just a field name and matching words
            </summary>
        </member>
        <member name="T:Abodit.Meta.IFieldNumericOrDate">
            <summary>
            A numeric or date field
            </summary>
        </member>
        <member name="P:Abodit.Meta.IFieldNumericOrDate.Qualifiers">
            <summary>
            Dimension qualifiers - qualify the Dimension (which is on the Unit)
            </summary>
        </member>
        <member name="T:Abodit.Meta.IFieldNumeric">
            <summary>
            A numeric field
            </summary>
        </member>
        <member name="T:Abodit.Meta.IFieldBooleanExpression">
            <summary>
            A field for a boolean expression
            </summary>
        </member>
        <member name="T:Abodit.Meta.IFieldDate">
            <summary>
            A field for a DateTime value
            </summary>
        </member>
        <member name="T:Abodit.Meta.IFieldEnum">
            <summary>
            A field for an Enum
            </summary>
        </member>
        <member name="P:Abodit.Meta.IFieldEnum.EnumValues">
            <summary>
            Gets the EnumValues
            </summary>
        </member>
        <member name="T:Abodit.Meta.IFieldEnumBool">
            <summary>
            A field for a true/false enum 
            </summary>
        </member>
        <member name="P:Abodit.Meta.IFieldEnumBool.ValueTrue">
            <summary>
            Gets the EnumValue for a true value
            </summary>
        </member>
        <member name="P:Abodit.Meta.IFieldEnumBool.ValueFalse">
            <summary>
            Gets the EnumValue for a false value
            </summary>
        </member>
        <member name="T:Abodit.Meta.IMeta">
            <summary>
            An interface for all meta objects (entities and fields - they all have a name and words)
            </summary>
        </member>
        <member name="P:Abodit.Meta.IMeta.Name">
            <summary>
            Name, used in UI to refer to this meta object, for a MetaEntity in SQL this MUST be table name or alias
            </summary>
        </member>
        <member name="P:Abodit.Meta.IMeta.MetaSynSets">
            <summary>
            Words, (optional if synset is already in dictionary)
            </summary>
        </member>
        <member name="T:Abodit.Meta.Meta">
            <summary>
            Base class for all Meta objects (objects that describe other objects)
            </summary>
        </member>
        <member name="P:Abodit.Meta.Meta.Name">
            <summary>
            Gets the name
            </summary>
        </member>
        <member name="P:Abodit.Meta.Meta.MetaSynSets">
            <summary>
            Get all of the <see cref="T:Abodit.Meta.MetaSynset"/>s for this meta object
            </summary>
        </member>
        <member name="M:Abodit.Meta.Meta.#ctor(System.String,System.Collections.Generic.IEnumerable{Abodit.Meta.MetaSynset})">
            <summary>
            Create a new instance of the abstract <see cref="T:Abodit.Meta.Meta"/> class
            </summary>
        </member>
        <member name="M:Abodit.Meta.Meta.AddAlias(System.String,System.String)">
            <summary>
            Add an alias for this Meta object
            </summary>
        </member>
        <member name="M:Abodit.Meta.Meta.Equals(Abodit.Meta.IMeta)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="T:Abodit.Meta.MetaSynset">
            <summary>
            A Synset with words that need to be added
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaSynset.SynSetName">
            <summary>
            Gets the Synset name
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaSynset.Words">
            <summary>
            Gets the words
            </summary>
        </member>
        <member name="F:Abodit.Meta.MetaSynset.None">
            <summary>
            No metasynset (empty array)
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaSynset.#ctor(System.String,System.String[])">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Meta.MetaSynset"/> class
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaSynset.ToString">
            <summary>
            Returns a string representation of this object
            </summary>
            <returns></returns>
        </member>
        <member name="T:Abodit.Meta.IMetaEntity">
            <summary>
            Information about an Entity (its schema)
            </summary>
        </member>
        <member name="P:Abodit.Meta.IMetaEntity.TableName">
            <summary>
            The table name or alias used to prefix any unadorned field names (i.e. ones without a dot)
            </summary>
        </member>
        <member name="P:Abodit.Meta.IMetaEntity.EntityType">
            <summary>
            The Type of this Entity
            </summary>
        </member>
        <member name="P:Abodit.Meta.IMetaEntity.Fields">
            <summary>
            The fields
            </summary>
        </member>
        <member name="M:Abodit.Meta.IMetaEntity.Get(Abodit.Meta.IField,System.Object)">
            <summary>
            Access a given field on an entity of this type
            </summary>
        </member>
        <member name="M:Abodit.Meta.IMetaEntity.AddField(Abodit.Meta.IField)">
            <summary>
            Add a field
            </summary>
        </member>
        <member name="P:Abodit.Meta.IMetaEntity.FilterExpression">
            <summary>
            An optional filter expression that should always be applied (e.g. !Deleted)
            </summary>
        </member>
        <member name="P:Abodit.Meta.IMetaEntity.SortOrders">
            <summary>
            Optional default sort orders that should always be applied (e.g. Name ascending)
            </summary>
        </member>
        <member name="T:Abodit.Meta.IMetaEntity`1">
            <summary>
            A MetaEntity for a given type of data source
            </summary>
            <typeparam name="TSource"></typeparam>
        </member>
        <member name="P:Abodit.Meta.IMetaEntity`1.Source">
            <summary>
            An object related to this metaentity, maybe an Id, or a source object
            </summary>
        </member>
        <member name="T:Abodit.Meta.MetaEntity`2">
            <summary>
            Base class for an Entity. TSourceMoniker stores a reference to a data source (typically just an Id),
            TEntity could be a DataRow or some specific entity you are modelling.
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaEntity`2.Source">
            <summary>
            The source moniker, e.g. table name
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaEntity`2.EntityType">
            <summary>
            Get the entity type
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaEntity`2.Get(Abodit.Meta.IField,`1)">
            <summary>
            Get the value of a field from an entity
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaEntity`2.Get(Abodit.Meta.IField,System.Object)">
            <summary>
            Gets the value of a Field from a MetaEntity
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaEntity`2.#ctor(`0,System.String,System.String,Abodit.Meta.MetaSynset[])">
            <summary>
            Create a new <see cref="T:Abodit.Meta.MetaEntity`2"/>
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaEntity`2.Equals(Abodit.Meta.IMeta)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaEntity`2.Equals(Abodit.Meta.MetaEntity{`0,`1})">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaEntity`2.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaEntity`2.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Meta.MetaEntityBase">
            <summary>
            Base class for MetaEntities
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaEntityBase.TableName">
            <summary>
            The table name or alias used to prefix any unadorned field names (i.e. ones without a dot)
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaEntityBase.Fields">
            <summary>
            Gets the fields
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaEntityBase.EntityType">
            <summary>
            Gets the EntityType, e.g. DataRow
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaEntityBase.FilterExpression">
            <summary>
            An optional filter expression that should always be applied to this entity
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaEntityBase.SortOrders">
            <summary>
            Optional sort orders that should always be applied to this entity
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaEntityBase.#ctor(System.String,System.String,Abodit.Meta.MetaSynset[])">
            <summary>
            Creates a new <see cref="T:Abodit.Meta.MetaEntityBase"/>
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaEntityBase.AddField(Abodit.Meta.IField)">
            <summary>
            Add a field
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaEntityBase.Get(Abodit.Meta.IField,System.Object)">
            <summary>
            Gets the value of a given field from the item
            </summary>
        </member>
        <member name="T:Abodit.Meta.IMetaEntityStore">
            <summary>
            A store for loading entities based on entity meta data
            </summary>
            <remarks>
            This could be implemented using CSV files, SQL, MongoDB, in memory objects, ...
            </remarks>
        </member>
        <member name="M:Abodit.Meta.IMetaEntityStore.Count(Abodit.Meta.IMetaEntity)">
            <summary>
            Gets a count of records for metaEntity, i.e. a whole table
            </summary>
        </member>
        <member name="M:Abodit.Meta.IMetaEntityStore.Count(Abodit.Meta.IMetaEntity,Abodit.Expressions.TokenExpression)">
            <summary>
            Gets a count of records for a metaEntity (table or collection) matching an expression
            </summary>
        </member>
        <member name="M:Abodit.Meta.IMetaEntityStore.GetPaged(Abodit.Meta.IMetaEntity,Abodit.Expressions.TokenExpression,Abodit.Meta.MetaSortOrder[],Abodit.Expressions.TokenExpression,System.Int32,System.Int32)">
            <summary>
            Gets records for a metaEntity (table or collection) matching an expression
            </summary>
        </member>
        <member name="T:Abodit.Meta.MetaField">
            <summary>
            An expression using one or more fields from a given <see cref="P:Abodit.Meta.MetaField.MetaEntity"/>
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaField.MetaEntity">
            <summary>
            The MetaEntity that owns this field
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaField.TokenExpression">
            <summary>
            An expression for the field (or more complex expression like an area)
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaField.Unit">
            <summary>
            Unit of measurement applied to this field, e.g. meters, miles, kg, ...
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaField.FieldQualifiers">
            <summary>
            FieldQualifiers like "important", "UTC", ...
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaField.FormatProvider">
            <summary>
            A format provider for formatting the value in this field
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaField.#ctor(Abodit.Meta.IMetaEntity,Abodit.Expressions.TokenExpression,Abodit.Meta.MetaSynset[],Abodit.Units.IUnit,System.IFormatProvider,Abodit.Meta.FieldQualifier[])">
            <summary>
            Create a new instance of a Field (or Field-based expression) for a MetaEntity
            </summary>
            <param name="metaEntity">the parent metaEntity that owns this field (cannot share fields)</param>
            <param name="tokenExpression">eg PLength or PWidth * PLength</param>
            <param name="metaSynsets">words and meanings for this field</param>
            <param name="unit">The unit of measure</param>
            <param name="formatProvider">An optional format provider</param>
            <param name="fieldQualifiers">Qualifiers (not used yet, TBD)</param>
        </member>
        <member name="M:Abodit.Meta.MetaField.Rewrite(Abodit.Meta.IMetaEntity,Abodit.Expressions.TokenExpression)">
            <summary>
            Rewrite VariableAccess to FieldAccess, prefixing fields as necessary
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaField.Equals(Abodit.Meta.IMeta)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaField.Equals(Abodit.Meta.MetaField)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaField.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaField.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaField.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaField.CreateMetaSynset(Abodit.Meta.MetaSynset[],Abodit.Expressions.TokenExpression)">
            <summary>
            Append a metaSynset for a TokenExpression to an existing list of MetaSynsets
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaField.CreateMetaSynset(Abodit.Expressions.TokenExpression)">
            <summary>
            Create a metaSynset for a TokenExpression
            </summary>
        </member>
        <member name="T:Abodit.Meta.IMetaModel">
            <summary>
            A meta model for an application contains a graph of meta entities
            </summary>
        </member>
        <member name="P:Abodit.Meta.IMetaModel.Graph">
            <summary>
            Gets the graph
            </summary>
        </member>
        <member name="T:Abodit.Meta.Metamodel">
            <summary>
            A meta model for an application contains a graph of meta entities
            </summary>
        </member>
        <member name="M:Abodit.Meta.Metamodel.AddAllEntities(System.Collections.Generic.IEnumerable{Abodit.Meta.IMetaEntity})">
            <summary>
            Add meta entities to the graph
            </summary>
        </member>
        <member name="P:Abodit.Meta.Metamodel.Graph">
            <summary>
            Gets the graph
            </summary>
        </member>
        <member name="T:Abodit.Meta.MetaQuery">
            <summary>
            A complete query with meta entities and filters
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaQuery.Filter">
            <summary>
            The filter expression for the query (after mapping any ranges to actual field queries)
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaQuery.Sorts">
            <summary>
            The sort orders for the query (never null)
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaQuery.MetaEntity">
            <summary>
            The meta entity
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaQuery.Skip">
            <summary>
            Skip can be set for a query like "the 25 longest products skip 20"
            (but normally not used as Grid control would do this)
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaQuery.Take">
            <summary>
            Take can be set for a query like "The 25 longest products"
            Zero if no Take has been set
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaQuery.Suffix">
            <summary>
            Optionally a suffix that was used in the question e.g. "were there", "are there", ...
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaQuery.#ctor(Abodit.Meta.MetaSortOrder,Abodit.Expressions.TokenExpression,Abodit.Meta.IMetaEntity,Abodit.Meta.MetaQuestionSuffix,System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Meta.MetaQuery"/> class
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaQuery.#ctor(Abodit.Expressions.TokenExpression,Abodit.Meta.MetaSortOrder,Abodit.Expressions.TokenExpression,Abodit.Meta.IMetaEntity,Abodit.Meta.MetaQuestionSuffix,System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Meta.MetaQuery"/> class
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaQuery.ToString">
            <summary>
            Returns a string description of this object
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaQuery.ToStringSql">
            <summary>
            Returns a string description of this object using SQL syntax
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaQuery.Equals(Abodit.Meta.MetaQuery)">
            <summary>
            Equals implementation
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaQuery.GetHashCode">
            <summary>
            Hashcode
            </summary>
        </member>
        <member name="T:Abodit.Meta.MetaQuestionSuffix">
            <summary>
            The suffix on a meta entity query, e.g. "are there" or "do we have"
            This adds nothing to the query and can safely be ignored, except that it may help the response
            as it can be conjugated and reused, e.g. "you have ..."
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaQuestionSuffix.ResponseTextSingular">
            <summary>
            A singular form of the response text
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaQuestionSuffix.ResponseTextPlural">
            <summary>
            A plural form of the response text
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaQuestionSuffix.#ctor(System.String,System.String)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Meta.MetaQuestionSuffix"/> class
            </summary>
        </member>
        <member name="T:Abodit.Meta.MetaRelationship">
            <summary>
            A MetaRelationship links two MetaEntities, modelling a foreign key relationship in SQL
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaRelationship.FromEntity">
            <summary>
            Gets the From end of the relationship
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaRelationship.ToEntity">
            <summary>
            Gets the To end of the relationship
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaRelationship.Arity">
            <summary>
            Gets the 'artity' of the meta relationship
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaRelationship.FromFieldName">
            <summary>
            Gets the From field name
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaRelationship.ToFieldName">
            <summary>
            Gets the To field name
            </summary>
        </member>
        <member name="T:Abodit.Meta.MetaSortOrder">
            <summary>
            Sort by a given property of an entity (usually a simple variable access expression)
            </summary>
        </member>
        <member name="T:Abodit.Meta.MetaSortOrder.SortOrderRewriter">
            <summary>
            Rewrites a MetaSortOrder expression to simplify it
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaSortOrder.SortOrderRewriter.Ascending">
            <summary>
            Sort is in ascending order
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaSortOrder.SortOrderRewriter.#ctor(System.Boolean)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Meta.MetaSortOrder.SortOrderRewriter"/>
            </summary>
        </member>
        <member name="F:Abodit.Meta.MetaSortOrder.SortOrderRewriter.None">
            <summary>
            An empty array with no meta sort orders in it
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaSortOrder.SortOrderRewriter.Rewrite(Abodit.Expressions.TokenExpression)">
            <summary>
            Rewrite the input expression
            </summary>
        </member>
        <member name="F:Abodit.Meta.MetaSortOrder.SortExpression">
            <summary>
            Get the TokenExpression for the sort
            </summary>
        </member>
        <member name="P:Abodit.Meta.MetaSortOrder.Ascending">
            <summary>
            Is the sort in ascending order?
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaSortOrder.#ctor(Abodit.Expressions.TokenExpression,System.Boolean)">
            <summary>
            Create a new instance of the <see cref="T:Abodit.Meta.MetaSortOrder"/> class
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaSortOrder.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaSortOrder.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaSortOrder.Equals(Abodit.Meta.MetaSortOrder)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaSortOrder.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaSortOrder.Serialize(Abodit.Meta.MetaSortOrder[])">
            <summary>
            Dump an array of meta sort orders to a string
            </summary>
        </member>
        <member name="M:Abodit.Meta.MetaSortOrder.Serialize">
            <summary>
            Dump a meta sort order to a string
            </summary>
        </member>
        <member name="T:Abodit.Meta.PagedTable">
            <summary>
            A generic way of returning a table from an NLP query with metadata about each column
            </summary>
        </member>
        <member name="P:Abodit.Meta.PagedTable.Total">
            <summary>
            Gets the total number of records with no filter applied
            </summary>
        </member>
        <member name="P:Abodit.Meta.PagedTable.ColumnTypes">
            <summary>
            Gets the column types
            </summary>
        </member>
        <member name="P:Abodit.Meta.PagedTable.Items">
            <summary>
            Gets the rows
            </summary>
        </member>
        <member name="P:Abodit.Meta.PagedTable.VariablesUsed">
            <summary>
            Which variables were used (check these against fields for importance)
            </summary>
        </member>
        <member name="M:Abodit.Meta.PagedTable.#ctor(System.Int64,System.Collections.Generic.IEnumerable{Abodit.Meta.IField},System.Collections.Generic.IEnumerable{Abodit.Meta.Row},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new <see cref="T:Abodit.Meta.PagedTable"/>
            </summary>
        </member>
        <member name="M:Abodit.Meta.PagedTable.FilterToImportantColumns">
            <summary>
            Gets a new paged table filtering this one to just the columns marked important (or referenced in the filter)
            </summary>
            <returns></returns>
        </member>
        <member name="T:Abodit.Meta.Relationship">
            <summary>
            Models a relationship between two entities
            </summary>
        </member>
        <member name="P:Abodit.Meta.Relationship.RelationshipTypes">
            <summary>
            Get the relationship types for this relationship
            </summary>
        </member>
        <member name="M:Abodit.Meta.Relationship.#ctor(System.String,Abodit.Meta.RelationshipType[])">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Meta.Relationship"/> class
            </summary>
            <param name="alias"></param>
            <param name="relationshipTypes"></param>
        </member>
        <member name="M:Abodit.Meta.Relationship.Equals(Abodit.Meta.IMeta)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Meta.Relationship.Equals(Abodit.Meta.Relationship)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Meta.Relationship.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Meta.Relationship.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Meta.RelationshipType">
            <summary>
            RelationshipType describes a connection between two Entities
            Typically this is an FK relationship in SQL
            </summary>
        </member>
        <member name="P:Abodit.Meta.RelationshipType.RelationshipName">
            <summary>
            The relatonship name
            </summary>
        </member>
        <member name="P:Abodit.Meta.RelationshipType.Cardinality">
            <summary>
            Gets the Cardinality of the relationship
            </summary>
        </member>
        <member name="M:Abodit.Meta.RelationshipType.#ctor(System.String,System.String,Abodit.Meta.Cardinality)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Meta.RelationshipType"/> class
            </summary>
        </member>
        <member name="F:Abodit.Meta.RelationshipType.By">
            <summary>
            By
            </summary>
        </member>
        <member name="F:Abodit.Meta.RelationshipType.Has">
            <summary>
            Has
            </summary>
        </member>
        <member name="F:Abodit.Meta.RelationshipType.Contains">
            <summary>
            Contains
            </summary>
        </member>
        <member name="F:Abodit.Meta.RelationshipType.Is">
            <summary>
            Is
            </summary>
        </member>
        <member name="M:Abodit.Meta.RelationshipType.Equals(Abodit.Meta.IMeta)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Meta.RelationshipType.Equals(Abodit.Meta.RelationshipType)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Meta.RelationshipType.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Meta.RelationshipType.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Meta.Row">
            <summary>
            A Row of cells returned from a natural language query
            </summary>
        </member>
        <member name="P:Abodit.Meta.Row.Cells">
            <summary>
            Gets the cells
            </summary>
        </member>
        <member name="M:Abodit.Meta.Row.#ctor(System.Collections.Generic.IEnumerable{Abodit.Meta.Cell})">
            <summary>
            Creates a new <see cref="T:Abodit.Meta.Row"/>
            </summary>
        </member>
        <member name="M:Abodit.Meta.Row.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.StateMachine.CompoundStateMachine`6">
            <summary>
            A compound state machine is essentially a cross product of two state machines sharing the same event type.
            </summary>
            <remarks>
            See: http://en.wikipedia.org/wiki/UML_state_machine#Orthogonal_regions
            
            Wikipedia: In most real-life situations, however, orthogonal regions are only approximately orthogonal (i.e., they are not independent). 
            Therefore, UML statecharts provide a number of ways for orthogonal regions to communicate and synchronize their behaviors. 
            From these rich sets of (sometimes complex) mechanisms, perhaps the most important is that orthogonal regions can coordinate 
            their behaviors by sending event instances to each other.
            </remarks>
        </member>
        <member name="F:Abodit.StateMachine.CompoundStateMachine`6.firstStateMachine">
            <summary>
            Gets the first state machine
            </summary>
        </member>
        <member name="F:Abodit.StateMachine.CompoundStateMachine`6.secondStateMachine">
            <summary>
            Gets the second state machine
            </summary>
        </member>
        <member name="T:Abodit.StateMachine.CompoundStateMachine`6.State">
            <summary>
            Represents the State for a StateMachine
            </summary>
        </member>
        <member name="P:Abodit.StateMachine.CompoundStateMachine`6.State.FirstState">
            <summary>
            Gets the first state machine's state
            </summary>
        </member>
        <member name="P:Abodit.StateMachine.CompoundStateMachine`6.State.SecondState">
            <summary>
            Gets the second state machine's state
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.CompoundStateMachine`6.State.#ctor(`2,`3)">
            <summary>
            Creates a new compound state
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.CompoundStateMachine`6.State.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.CompoundStateMachine`6.#ctor">
            <summary>
            Creates a new empty CompoundStateMachine
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.CompoundStateMachine`6.#ctor(`0,`1)">
            <summary>
            Creates a new <see cref="T:Abodit.StateMachine.CompoundStateMachine`6"/>
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.CompoundStateMachine`6.Tick(System.DateTime,`5,System.Int32)">
            <summary>
            Tick on both state machines
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.CompoundStateMachine`6.Start">
            <summary>
            Start both state machines
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.CompoundStateMachine`6.EventHappens(`4,`5)">
            <summary>
            An event happens, transition both state machines
            </summary>
        </member>
        <member name="T:Abodit.StateMachine.Event">
            <summary>
            An event that causes the state machine to transition to a new state - you can use any object
            that implements IEquatable of T.  You might also want to mark it Serializable.
            </summary>
            <remarks>
            Using this class you can create simple named events that have all of the required properties to work in the State Machine
            </remarks>
        </member>
        <member name="P:Abodit.StateMachine.Event.Name">
            <summary>
            Events with the same name (within a state machine) are considered to be the same event
            so you don't need the specific same Event in order to fire it
            Unlike States where we do extra work to get a consistent stateDefinition
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.Event.#ctor(System.String)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.StateMachine.Event"/> class
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.Event.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.Event.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.Event.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.Event.op_Equality(Abodit.StateMachine.Event,Abodit.StateMachine.Event)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.Event.op_Inequality(Abodit.StateMachine.Event,Abodit.StateMachine.Event)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.Event.Equals(Abodit.StateMachine.Event)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="T:Abodit.StateMachine.IStateMachine`3">
            <summary>
            Interface for a StateMachine
            </summary>
        </member>
        <member name="P:Abodit.StateMachine.IStateMachine`3.CurrentState">
            <summary>
            Get the current state
            </summary>
        </member>
        <member name="E:Abodit.StateMachine.IStateMachine`3.EventHappened">
            <summary>
            An event has happened
            </summary>
        </member>
        <member name="E:Abodit.StateMachine.IStateMachine`3.StateChanges">
            <summary>
            The State has changed
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.IStateMachine`3.SetTimedEvents(System.Collections.Generic.IEnumerable{Abodit.StateMachine.TimedEvent{`1}})">
            <summary>
            Sets the TimedEvents on the state machine (used only during loading from persistence)
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.IStateMachine`3.Start">
            <summary>
            Start the state machine
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.IStateMachine`3.Tick(System.DateTime,`2,System.Int32)">
            <summary>
            The Tick method must be called regularly if you want timed events to work
            </summary>
            <param name="utcNow"></param>
            <param name="context"></param>
            <param name="limitOnNumberExecuted"></param>
        </member>
        <member name="M:Abodit.StateMachine.IStateMachine`3.EventHappens(`1,`2)">
            <summary>
            An external event happens, trigger the state machine
            </summary>
            <param name="event"></param>
            <param name="context"></param>
        </member>
        <member name="T:Abodit.StateMachine.StateMachine`3">
            <summary>
            A state machine allows you to track state and to take actions when states change
            This state machine provides a fluent interface for defining states and transitions
            When you inherit from this abstract base class you can add variables to your state machine
            which makes it an "Extended State Machine"
            
            NB This is a 'curiously self-referencing generic'. This ensures that State objects are not
            shared across two StateMachines even if they have the same generic arguments. It also
            makes some syntax nicer and eliminates casting on the consumption side.
            
            NB No state should be stored in the state machine, that is now all stored in the context object.
            
            </summary>
            <remarks>
            Also has timed events set to fire at some point in the future but provides no Timer internally because
            that will be implementation dependent.  For example the State may exist in a serialized form
            in a database with the NextTimedEventAt property exposed for indexing and some external timer fecthing
            records and calling the Tick() method.
            </remarks>
        </member>
        <member name="T:Abodit.StateMachine.StateMachine`3.State">
            <summary>
            A state that the state machine can be in
            </summary>
            <remarks>
            This is defined as a nested class to ensure each state machine has only the states that were defined for it
            and not for some other state machine. The State class delegates almost everything to the StateDefinition that
            is stored statically for each StateMachine.
            </remarks>
        </member>
        <member name="P:Abodit.StateMachine.StateMachine`3.State.Name">
            <summary>
            The Name of this state (all states with the same Name are considered equal even if they are different objects)
            </summary>
            <remarks>
            This makes serialization and deserialization easier
            </remarks>
        </member>
        <member name="F:Abodit.StateMachine.StateMachine`3.State.stateDefinition">
            <summary>
            Our state definition stores everything we need to know - our entry and exit actions, our parentage, ...
            Every state with the same name within a StateMachine has the same definition
            </summary>
        </member>
        <member name="P:Abodit.StateMachine.StateMachine`3.State.ParentState">
            <summary>
            States can optionally be organized hierarchically
            The hierarchy is set by the initial static creation of States
            not by some later states that are loaded from serialized versions
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachine`3.State.#ctor">
            <summary>
            Empty constuctor for serialization only
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachine`3.State.#ctor(System.String)">
            <summary>
            Create a new State with a name
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachine`3.State.TryGet(System.String,Abodit.StateMachine.StateMachine{`0,`1,`2}.State@)">
            <summary>
            Get a state by name, if it exists (suitable for use during deserialization from a string)
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachine`3.State.OnEvent(`0,`1,`2)">
            <summary>
            Act on an event, return the new state or null if there are no transitions possible (even inherited)
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachine`3.State.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachine`3.State.When(`1,System.Func{`0,Abodit.StateMachine.StateMachine{`0,`1,`2}.State,`1,`2,Abodit.StateMachine.StateMachine{`0,`1,`2}.State})">
            <summary>
            Define what happens 'When' an event happens while in this state.
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachine`3.State.When(`1,Abodit.StateMachine.StateMachine{`0,`1,`2}.State)">
            <summary>
            A simple form of When with no action (unless you defined actions for entering or leaving states)
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachine`3.State.OnEnter(System.Action{Abodit.StateMachine.StateMachine{`0,`1,`2},`1,Abodit.StateMachine.StateMachine{`0,`1,`2}.State,`2})">
            <summary>
            Add an action that happens when this state is entered
            </summary>
            <remarks>
            This is an alternative to setting it in the state constructor
            </remarks>
        </member>
        <member name="M:Abodit.StateMachine.StateMachine`3.State.OnExit(System.Action{Abodit.StateMachine.StateMachine{`0,`1,`2},Abodit.StateMachine.StateMachine{`0,`1,`2}.State,`1,`2})">
            <summary>
            Add an action that happens when this state exits
            </summary>
            <remarks>
            This is an alternative to setting it in the state constructor
            </remarks>
        </member>
        <member name="M:Abodit.StateMachine.StateMachine`3.State.Is(Abodit.StateMachine.StateMachine{`0,`1,`2}.State)">
            <summary>
            Test this state to see if it 'is' the other state, i.e. if it is the same or inherits from it
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachine`3.State.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Gets the ObkectData for serialization
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachine`3.State.Equals(Abodit.StateMachine.StateMachine{`0,`1,`2}.State)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachine`3.State.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachine`3.State.op_Equality(Abodit.StateMachine.StateMachine{`0,`1,`2}.State,Abodit.StateMachine.StateMachine{`0,`1,`2}.State)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachine`3.State.op_Inequality(Abodit.StateMachine.StateMachine{`0,`1,`2}.State,Abodit.StateMachine.StateMachine{`0,`1,`2}.State)">
            <summary>
            Not Equals
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachine`3.State.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.StateMachine.StateMachine`3.StateDefinition">
            <summary>
            The static State Definitions that are created for a StateMachine
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachine`3.StateDefinition.op_Implicit(Abodit.StateMachine.StateMachine{`0,`1,`2}.StateDefinition)~Abodit.StateMachine.StateMachine{`0,`1,`2}.State">
            <summary>
            A StateDef spawns State objects
            </summary>
            <param name="stateDef"></param>
            <returns></returns>
        </member>
        <member name="P:Abodit.StateMachine.StateMachine`3.StateDefinition.Name">
            <summary>
            The Name of this state definition
            </summary>
            <remarks>
            Used for serialization of the state machine, also handy for debugging
            </remarks>
        </member>
        <member name="P:Abodit.StateMachine.StateMachine`3.StateDefinition.SelfAndAncestorsInAscendingOrder">
            <summary>
            Get the ancestor states in ascending order, top-most state last
            </summary>
        </member>
        <member name="P:Abodit.StateMachine.StateMachine`3.StateDefinition.AncestorsInAscendingOrder">
            <summary>
            Get the ancestor states in ascending order, top-most state last
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachine`3.StateDefinition.#ctor(System.String,System.Action{`0,`1,Abodit.StateMachine.StateMachine{`0,`1,`2}.State,`2},System.Action{`0,Abodit.StateMachine.StateMachine{`0,`1,`2}.State,`1,`2},Abodit.StateMachine.StateMachine{`0,`1,`2}.State)">
            <summary>
            Create a new State with a name and an optional entry and exit action
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachine`3.#ctor">
            <summary>
            Empty constructor for serialization only
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachine`3.#ctor(Abodit.StateMachine.StateMachine{`0,`1,`2}.State)">
            <summary>
            Construct a state machine with an initial state
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachine`3.EventHappens(`1,`2)">
            <summary>
            An event has happened, transition to next state
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachine`3.AddState(System.String,System.Action{`0,`1,Abodit.StateMachine.StateMachine{`0,`1,`2}.State,`2},System.Action{`0,Abodit.StateMachine.StateMachine{`0,`1,`2}.State,`1,`2},Abodit.StateMachine.StateMachine{`0,`1,`2}.State)">
            <summary>
            Add a new state definition
            </summary>
        </member>
        <member name="T:Abodit.StateMachine.StateTransitionArgs`2">
            <summary>
            Arguments for an event that is fired when the state transitions
            </summary>
        </member>
        <member name="P:Abodit.StateMachine.StateTransitionArgs`2.DateTimeOffset">
            <summary>
            The DateTimeOffset when the state transition happened
            </summary>
        </member>
        <member name="P:Abodit.StateMachine.StateTransitionArgs`2.Context">
            <summary>
            The context object
            </summary>
        </member>
        <member name="P:Abodit.StateMachine.StateTransitionArgs`2.OldState">
            <summary>
            The old state
            </summary>
        </member>
        <member name="P:Abodit.StateMachine.StateTransitionArgs`2.NewState">
            <summary>
            The new state
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateTransitionArgs`2.#ctor(`0,`1,`1,System.DateTimeOffset)">
            <summary>
            Creates a new <see cref="T:Abodit.StateMachine.StateTransitionArgs`2"/>
            </summary>
        </member>
        <member name="T:Abodit.StateMachine.EventHappensArgs`2">
            <summary>
            Arguments for an event that is fired when an Event happens
            </summary>
        </member>
        <member name="P:Abodit.StateMachine.EventHappensArgs`2.DateTimeOffset">
            <summary>
            The DateTimeOffset of the Event
            </summary>
        </member>
        <member name="P:Abodit.StateMachine.EventHappensArgs`2.Context">
            <summary>
            The context
            </summary>
        </member>
        <member name="P:Abodit.StateMachine.EventHappensArgs`2.Event">
            <summary>
            The event
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.EventHappensArgs`2.#ctor(`0,`1,System.DateTimeOffset)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.StateMachine.EventHappensArgs`2"/> class
            </summary>
        </member>
        <member name="T:Abodit.StateMachine.StateMachineBase`3">
            <summary>
            The base StateMachine
            </summary>
        </member>
        <member name="P:Abodit.StateMachine.StateMachineBase`3.CurrentState">
            <summary>
            The current state of this State machine
            </summary>
        </member>
        <member name="P:Abodit.StateMachine.StateMachineBase`3.NextTimedEventAt">
            <summary>
            The UTC time at which this state machine needs to receive a wake up from an external timing component
            </summary>
        </member>
        <member name="E:Abodit.StateMachine.StateMachineBase`3.StateChanges">
            <summary>
            A public Event that advises of any changes in state that actually happen
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachineBase`3.OnStateChanging(`2,`0,`0)">
            <summary>
            Called prior to the state actually changing
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachineBase`3.OnStateChanged(`2,`0,`0)">
            <summary>
            Called after the state has changed
            </summary>
        </member>
        <member name="E:Abodit.StateMachine.StateMachineBase`3.EventHappened">
            <summary>
            A public Event that advises of any events that have happened
            </summary>
            <remarks>
            Can thus expose timer events to the outside world without changing state
            </remarks>
        </member>
        <member name="M:Abodit.StateMachine.StateMachineBase`3.OnEventHappens(`2,`1)">
            <summary>
            Fires when this event happens
            </summary>
        </member>
        <member name="P:Abodit.StateMachine.StateMachineBase`3.TimedEvents">
            <summary>
            Future events set on this StateMachine (Serializable, so public and settable, but use it only for serialization)
            </summary>
            <remarks>
            Each StateMachine has its own small set of future events.  Typically this list will be very small; when an event fires
            it might record a future event that needs to be executed
            </remarks>
        </member>
        <member name="M:Abodit.StateMachine.StateMachineBase`3.SetTimedEvents(System.Collections.Generic.IEnumerable{Abodit.StateMachine.TimedEvent{`1}})">
            <summary>
            Set the timed events
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Abodit.StateMachine.StateMachineBase`3.RecalculateNextTimedEvent">
            <summary>
            Recalculate the next timed event
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachineBase`3.Start">
            <summary>
            Most State machines have a Start() method that moves them to their initial state
            </summary>
            <remarks>
            Not really needed, use constructor with State value, depracate?
            </remarks>
        </member>
        <member name="M:Abodit.StateMachine.StateMachineBase`3.Tick(System.DateTime,`2,System.Int32)">
            <summary>
            Find any events that should have fired by now and execute up to a maximum set number of them
            (e.g. use the number to limit how long this method can run for in worst case before you persist the state
             machine to disk)
            </summary>
            <param name="utcNow">The current utc time (passed as a parameter to make this method testable)</param>
            <param name="context">A context object</param>
            <param name="limitOnNumberExecuted">In order to prevent runaway execution of a misconfigured recurring event set a maximum number of executions</param>
            <remarks>
            Note: These events are executed synchronously on the calling thread
            Caller should persist this object (if necessary) after all timedEvents have been processed
            Timed events may themselves add new events to the event queue.  These new events will happen
            immediately in this method if they themselves are already past due
            </remarks>
        </member>
        <member name="M:Abodit.StateMachine.StateMachineBase`3.At(System.DateTimeOffset,`1)">
            <summary>
            At a certain time, cause a certain event to happen
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachineBase`3.At(System.DateTime,`1)">
            <summary>
            At a certain time Utc, cause a certain event to happen
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachineBase`3.After(System.TimeSpan,`1)">
            <summary>
            After a certain period, cause a certain event to happen
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachineBase`3.Bump(System.TimeSpan,`1)">
            <summary>
            After a certain period, cause a certain event to happen, but only if that event
            is already present in the queue
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachineBase`3.Every(System.TimeSpan,`1)">
            <summary>
            Every time interval, cause a certain event to happen
            </summary>
            <remarks>
            Uses TimePeriod not timespan because TimePeriod is more flexible (e.g. weeks, months, ...)
            Use CancelScheduledEvent() to remove a repeated event
            </remarks>
        </member>
        <member name="M:Abodit.StateMachine.StateMachineBase`3.CancelScheduledEvent(`1)">
            <summary>
            Removes any scheduled or recurring events that would fire the given event
            </summary>
        </member>
        <member name="M:Abodit.StateMachine.StateMachineBase`3.EventHappens(`1,`2)">
            <summary>
            An event has happened, transition to next state
            </summary>
        </member>
        <member name="T:Abodit.StateMachine.TimedEvent`1">
            <summary>
            A event that should fire at a particular time, used inside a StateMachine
            </summary>
            <remarks>
            Serializable so you can persist a state machine to disk if necessary
            TEvent must be IEquatable also
            </remarks>
        </member>
        <member name="P:Abodit.StateMachine.TimedEvent`1.AtUtc">
            <summary>
            The time at which the event should happen
            </summary>
        </member>
        <member name="P:Abodit.StateMachine.TimedEvent`1.Event">
            <summary>
            The event that happens
            </summary>
        </member>
        <member name="P:Abodit.StateMachine.TimedEvent`1.AutoRepeatTicks">
            <summary>
            Autorepeat after this many ticks
            </summary>
            <remarks>
            Would have used a TimeSpan but they don't XML Serialize 
            </remarks>
        </member>
        <member name="M:Abodit.StateMachine.TimedEvent`1.NextOccurrence">
            <summary>
            Get the next occurrence (after autorepeat)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Abodit.StateMachine.TimedEvent`1.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Temporal.Simplifiers.SimplifyInfiniteTimeInDayFinite">
            <summary>
            A TimeRange in a Day may be anchored at midnight or some other time. When it's midnight it has different
            semantics as a user might be looking for either end of the day
            </summary>
        </member>
        <member name="T:Abodit.Temporal.Simplifiers.SimplifyInfiniteTimeInDayFiniteReverse">
            <summary>
            A TimeRange in a Day may be anchored at midnight or some other time. When it's midnight it has different
            semantics as a user might be looking for either end of the day
            </summary>
        </member>
        <member name="T:Abodit.Temporal.Simplifiers.TemporalSetSimplifierBase">
            <summary>
            Base class for writing TemporalSet simplifiers that take a union or intersection and simplify it
            </summary>
        </member>
        <member name="M:Abodit.Temporal.Simplifiers.TemporalSetSimplifierBase.SimplifyIntersection(Abodit.Temporal.TemporalSet,Abodit.Temporal.TemporalSet)">
            <summary>
            Simplify an intersection of two temporal sets
            </summary>
        </member>
        <member name="M:Abodit.Temporal.Simplifiers.TemporalSetSimplifierBase.SimplifyUnion(Abodit.Temporal.TemporalSet,Abodit.Temporal.TemporalSet)">
            <summary>
            Simplify a union of two temporal sets
            </summary>
        </member>
        <member name="F:Abodit.Temporal.Simplifiers.TemporalSetSimplifierBase.CannotSimplify">
            <summary>
            A special temporal set marker for returning when no simplification exists (syntactic sugar on null)
            </summary>
        </member>
        <member name="F:Abodit.Temporal.Simplifiers.TemporalSetSimplifierBase.All">
            <summary>
            Get all TemporalSet simplifiers.
            </summary>
            <remarks>
            If you add a simplifier it needs to be added here
            </remarks>
        </member>
        <member name="T:Abodit.Temporal.TemporalSet">
            <summary>
            A TemporalSet is a set of datetimeranges, possibly finite, possibly infinite, possibly uniform, possibly non-uniform
            </summary>
            <remarks>
            
            dateTime MATCHES TemporalSet
              --> Apply(visit(temporalSet), dateTime)
            i.e. the temporal set is mapped to a Func[DateTimeOffset, bool]
            
            If the Database field is NOT a DateTimeOffset then the local TZ offset would need
            to be added to it, but that cannot possibly get correct answers. So for DateTime
            fields in UTC all queries will have to be in UTC Also.
            
            
            When we need to query the database for a different timezone...
              --> SWITCHOFFSET(@dt, '-08:00')
            or the equivalent objects
              --> dt + timezone offset
            
            TemporalSetRelative(TokenExpressionConstantDateTime(now))
              - so "10 minutes ago" knows how long 'ago' is.
              - but what about last year, last month, ...
              - Monday ?
            
            
            
            </remarks>
        </member>
        <member name="P:Abodit.Temporal.TemporalSet.Type">
            <summary>
            The .NET Type of this <see cref="T:Abodit.Expressions.TokenExpression"/>
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSet.HasStart">
            <summary>
            Has a finite start point
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSet.HasEnd">
            <summary>
            Has a finite end point
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSet.IsFinite">
            <summary>
            Has a finite start and end point
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSet.IsInfinite">
            <summary>
            Is not finite
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSet.Priority">
            <summary>
            Priority is used to enforce precedence rules
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSet.Accept``1(Abodit.Expressions.Visitor.ITokenExpressionSoloVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSet.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSet.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
            <remarks>
            Typically you do this when you ask for thimgs after now
            This method will happily let you enumerate a half infinite set so don't call ToList() on the result!
            Throws an Exception if you try to enumerate a full infinite set, so check IsFinite or HasEnd before calling this method
            </remarks>
        </member>
        <member name="M:Abodit.Temporal.TemporalSet.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSet.Earliest">
            <summary>
            Earliest time
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSet.Latest">
            <summary>
            Latest time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSet.op_ExclusiveOr(Abodit.Temporal.TemporalSet,Abodit.Temporal.TemporalSet)">
            <summary>
            Intersection of two temporal sets
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSet.EnumerateIntersectionForward(Abodit.Units.CalendarDateTime,Abodit.Temporal.TemporalSet,Abodit.Temporal.TemporalSet)">
            <summary>
            Enumerates the intersection of two TemporalSets forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSet.EnumerateIntersectionBackward(Abodit.Units.CalendarDateTime,Abodit.Temporal.TemporalSet,Abodit.Temporal.TemporalSet)">
            <summary>
            Enumerates the intersection of two TemporalSets backward from a point in time
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSet.Never">
            <summary>
            Never
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSet.Always">
            <summary>
            Always
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSet.Unknown">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSet.Q1">
            <summary>
            Q1
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSet.Q2">
            <summary>
            Q2
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSet.Q3">
            <summary>
            Q3
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSet.Q4">
            <summary>
            Q4
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSet.H1">
            <summary>
            H1
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSet.H2">
            <summary>
            H2
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSet.Intersect(Abodit.Temporal.TemporalSet)">
            <summary>
            Intersect this TemporalSet with another TemporalSet - works for anything infinite or finite
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSet.Union(Abodit.Temporal.TemporalSet)">
            <summary>
            Union this TemporalSet with another TemporalSet - works for anything infinite or finite
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSet.op_BitwiseOr(Abodit.Temporal.TemporalSet,Abodit.Temporal.TemporalSet)">
            <summary>
            Union of two temporal sets
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSet.ConstrainToAfterNow">
            <summary>
            Create a new temporal set restricting this one to after now
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSet.ConstrainToBeforeNow">
            <summary>
            Create a new temporal set restricting this one to before now
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSet.ConstrainToAfter(Abodit.Units.CalendarDateTime)">
            <summary>
            Create a new temporal set restricting this one to after a given point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSet.ConstrainToBefore(Abodit.Units.CalendarDateTime)">
            <summary>
            Create a new temporal set restricting this one to before a given point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSet.Shift(Abodit.Units.TimePeriod)">
            <summary>
            Shifts a temporal set by an amount of time
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetInfiniteAfter">
            <summary>
            The word "After" applied to another TemporalSet (e.g. after 22nd May 1987)
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteAfter.Child">
            <summary>
            The child temporal set
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteAfter.#ctor(Abodit.Temporal.TemporalSet)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Temporal.TemporalSetInfiniteAfter"/> class
            </summary>
            <param name="child"></param>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteAfter.HasStart">
            <summary>
            Has a finite start point
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteAfter.HasEnd">
            <summary>
            Has a finite end point
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteAfter.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enmerates a temporal set in the forward direction from a given point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteAfter.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enmerates a temporal set in the backward direction from a given point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteAfter.ToString">
            <summary>
            Returns a string representation of the temporal set
            </summary>
            <returns></returns>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteAfter.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteAfter.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteAfter.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetInfiniteBefore">
            <summary>
            The word "Before" applied to another TemporalSet
            </summary>
            <remarks>
            Before May 1987
            </remarks>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteBefore.Child">
            <summary>
            Get the child TemporalSet
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteBefore.#ctor(Abodit.Temporal.TemporalSet)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Temporal.TemporalSetInfiniteBefore"/> class
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteBefore.HasStart">
            <summary>
            Has a start point
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteBefore.HasEnd">
            <summary>
            Has an end point
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteBefore.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteBefore.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteBefore.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteBefore.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteBefore.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteBefore.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetEvery">
            <summary>
            The word Every applied to another TemporalSet (e.g. every May OR every May 5th)
            TODO: Should this be a production rule instead?
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetEvery.Left">
            <summary>
            Gets the left set
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetEvery.#ctor(Abodit.Temporal.TemporalSetInfinite)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetEvery"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetEvery.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetEvery.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetEvery.Earliest">
            <summary>
            Gets the Earliest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetEvery.Latest">
            <summary>
            Gets the latest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetEvery.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetEvery.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetEvery.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetFinite">
            <summary>
            Finite sets are easy to deal with, we can iterate over all their elements if we have to ...
            They can however be formed from two infinite sets (one forward and one backward)
            </summary>
            <remarks>
            TemporalSetFinite includes 
                TemporalSetFiniteWellKnown's such as a specific year, e.g. 2010
                TemporalSetFiniteSingleInterval e.g. specific time and date to a specific time and date
            
            </remarks>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFinite.HasStart">
            <summary>
            Has a finite start point
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFinite.HasEnd">
            <summary>
            Has a finite end point
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFinite.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFinite.EnumerateForward">
            <summary>
            Enumerates the temporal finite set forward
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFinite.EnumerateBackward">
            <summary>
            Enumerates the temporal finite set backward
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetFiniteDayOfMonthInYear">
            <summary>
            Every month in a specific year on a given day of that month, e.g. the 20th / 2010
            </summary>
            <remarks>
            Unlikely this will ever be used
            </remarks>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteDayOfMonthInYear.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetFiniteDayOfMonthInYear"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteDayOfMonthInYear.GenerateIntervals(System.Int32,System.Int32)">
            <summary>
            Generate the intervals for a given day of month in a year 
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetFiniteIntervals">
            <summary>
            A finite set with known intervals
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSetFiniteIntervals.intervals">
            <summary>
            Our base interval list (these are CalendarDateTimeRanges and need to be mapped to actual times if you want that
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteIntervals.Intervals">
            <summary>
            The discrete intervals covered by this temporal set with respect to a reference time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteIntervals.#ctor(Abodit.Units.CalendarDateTimeRange)">
            <summary>
            Constructor for use by the special case single interval finite set
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteIntervals.#ctor(System.Collections.Generic.IEnumerable{Abodit.Units.CalendarDateTimeRange})">
            <summary>
            A complex finite temporal set with many discrete intervals
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteIntervals.Earliest">
            <summary>
            Gets the Earliest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteIntervals.Latest">
            <summary>
            Gets the latest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteIntervals.EnumerateForward">
            <summary>
            Enumerate the TemporalSet forward
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteIntervals.EnumerateBackward">
            <summary>
            Enumerate the TemporalSet backward
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteIntervals.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteIntervals.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteIntervals.Shift(Abodit.Units.TimePeriod)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetFiniteShift"/>
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetFiniteQuantityOf">
            <summary>
            e.g. IN 30 days, 2 months AGO, 5 weeks from tomorrow, ... e.g. the last 5 years
            
            TODO: Does this duplcate some other class? What is the finite anchor on? Why no Child set?
            
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteQuantityOf.Future">
            <summary>
            Is this in the future
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteQuantityOf.TimePeriod">
            <summary>
            Gets the time period
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteQuantityOf.#ctor(Abodit.Units.TimePeriod,System.Boolean)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetFiniteQuantityOf"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteQuantityOf.Add(System.DateTimeOffset)">
            <summary>
            Add this quantity of time to a base DateTime value
            </summary>
            <remarks>
            Would prefer to return a TimeSpan but .NET TimeSpan's aren't expressive enough - no "month" time span for example.
            This is mostly here for testing
            </remarks>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteQuantityOf.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteQuantityOf.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteQuantityOf.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteQuantityOf.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetFiniteSingleHalf">
            <summary>
            A Specific Half in a Year
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteSingleHalf.Year">
            <summary>
            Gets the year
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteSingleHalf.HalfNumber">
            <summary>
            Gets the half number
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSingleHalf.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetFiniteSingleHalf"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSingleHalf.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetFiniteSingleInterval">
            <summary>
            A <see cref="T:Abodit.Temporal.TemporalSet"/> with just a single finite interval
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteSingleInterval.Interval">
            <summary>
            Gets the interval
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSingleInterval.#ctor(Abodit.Units.CalendarDateTimeRange)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetFiniteSingleInterval"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSingleInterval.#ctor(Abodit.Units.CalendarDateTime,Abodit.Units.CalendarDateTime)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetFiniteSingleInterval"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSingleInterval.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSingleInterval.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSingleInterval.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSingleInterval.Equals(Abodit.Temporal.TemporalSetFiniteSingleInterval)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSingleInterval.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetFiniteSingleMonthYear">
            <summary>
            A specific month
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSingleMonthYear.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetFiniteSingleMonthYear"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSingleMonthYear.#ctor(Abodit.Units.CalendarDateTimeRange)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetFiniteSingleMonthYear"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSingleMonthYear.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetFiniteMonthYearList">
            <summary>
            A specific list of months in a year (does not cross year boundaries)
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteMonthYearList.Year">
            <summary>
            The year
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteMonthYearList.Months">
            <summary>
            The months
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteMonthYearList.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Temporal.TemporalSetFiniteMonthYearList"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteMonthYearList.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteMonthYearList.Create(System.Int32,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Create with factory
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteMonthYearList.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteMonthYearList.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteMonthYearList.GetHashCode">
            <summary>
            Hashcode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetFiniteSingleQuarter">
            <summary>
            A Specific Quarter in a Year
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteSingleQuarter.Year">
            <summary>
            Gets the Year
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteSingleQuarter.QuarterNumber">
            <summary>
            Gets the quarter number
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteSingleQuarter.Months">
            <summary>
            Gets the month numbers in this quarter
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSingleQuarter.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetFiniteSingleQuarter"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSingleQuarter.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetFiniteSingleWeek">
            <summary>
            A specific week
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSingleWeek.#ctor(Abodit.Units.CalendarDateTimeRange)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Temporal.TemporalSetFiniteSingleWeek"/> class
            </summary>
            <param name="week"></param>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSingleWeek.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetFiniteSingleWeekend">
            <summary>
            A specific weekend
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSingleWeekend.#ctor(Abodit.Units.CalendarDateTimeRange)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetFiniteSingleWeekend"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSingleWeekend.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetFiniteYear">
            <summary>
            A Specific Year
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSetFiniteYear.MinYear">
            <summary>
            Minimum allowed year
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSetFiniteYear.MaxYear">
            <summary>
            Maximum allowed year
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteYear.Year">
            <summary>
            Gets the year
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteYear.Interval">
            <summary>
            Gets the interval
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteYear.#ctor(Abodit.Units.CalendarDateTimeRange)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetFiniteYear"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteYear.#ctor(System.Int32)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetFiniteYear"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteYear.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteYear.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteYear.CouldBe(System.Int32,System.Type[],Abodit.Temporal.TemporalSetFiniteYear@)">
            <summary>
            Convert an Int to a TemporalSetFiniteSingleYear if that makes sense
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetFiniteSpecificCentury">
            <summary>
            A specific century
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteSpecificCentury.StartYear">
            <summary>
            Gets the start year
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSpecificCentury.#ctor(System.Int32)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetFiniteSpecificCentury"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSpecificCentury.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Temporal.DateFormat">
            <summary>
            DateFormat: USA, UK (and most of ROW), or ISO
            </summary>
        </member>
        <member name="F:Abodit.Temporal.DateFormat.USA">
            <summary>
            USA date format MM/DD/YYYY
            </summary>
        </member>
        <member name="F:Abodit.Temporal.DateFormat.UK">
            <summary>
            UK date format DD/MM/YYYY
            </summary>
        </member>
        <member name="F:Abodit.Temporal.DateFormat.ISO8601">
            <summary>
            ISO date format YYYY/MM/DD
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetFiniteSpecificDate">
            <summary>
            A specific day in a specific month in a specific year
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteSpecificDate.DateFormat">
            <summary>
            Gets the DateFormat
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteSpecificDate.Year">
            <summary>
            Year (duplicate data)
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteSpecificDate.Month">
            <summary>
            Month (duplicate data)
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteSpecificDate.Day">
            <summary>
            Day (duplicate data)
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSpecificDate.#ctor(System.Int32,System.Int32,System.Int32,Abodit.Temporal.DateFormat)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetFiniteSpecificDate"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSpecificDate.#ctor(Abodit.Units.CalendarDate)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetFiniteSpecificDate"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSpecificDate.#ctor(Abodit.Units.CalendarDateTimeRange)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetFiniteSpecificDate"/>
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteSpecificDate.DateTime">
            <summary>
            Since this represents a specific year/month/day we can return a DateTime value for it
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteSpecificDate.CalendarDate">
            <summary>
            Since this represents a specific year/month/day we can return a CalendarDate for it
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSpecificDate.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSpecificDate.Equals(Abodit.Temporal.TemporalSetFiniteSpecificDate)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetFiniteSpecificDecade">
            <summary>
            A specific decade
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteSpecificDecade.StartYear">
            <summary>
            Gets the start year
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSpecificDecade.#ctor(System.Int32)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetFiniteSpecificDecade"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSpecificDecade.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetFiniteSpecificMillennium">
            <summary>
            A specific Millennium
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteSpecificMillennium.StartYear">
            <summary>
            Gets the start year
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSpecificMillennium.#ctor(System.Int32)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetFiniteSpecificMillennium"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteSpecificMillennium.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetFiniteWellKnown">
            <summary>
            A specific day/month/year or a specific month/year or a specific year -
            something we can easily qualify further
            </summary>
            <remarks>
            Mostly something we can easily describe and work with as we build up a time expression using multiple constraints
            e.g. 2010, or July 2010, or ...
            </remarks>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteWellKnown.Year">
            <summary>
            Gets the Year
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteWellKnown.Month">
            <summary>
            Gets the Month
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteWellKnown.Day">
            <summary>
            Gets the Day
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteWellKnown.TimeInDay">
            <summary>
            Gets the TimeRange in the day, if any
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteWellKnown.#ctor(System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32},Abodit.Units.TimeRange,Abodit.Units.CalendarDateTimeRange)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Temporal.TemporalSetFiniteWellKnown"/> class
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteWellKnown.#ctor(System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32},Abodit.Units.TimeRange,System.Collections.Generic.IEnumerable{Abodit.Units.CalendarDateTimeRange})">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Temporal.TemporalSetFiniteWellKnown"/> class
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteWellKnown.#ctor(Abodit.Units.CalendarDate)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Temporal.TemporalSetFiniteWellKnown"/> class
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteWellKnown.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteWellKnown.ConstrainTimeOfDay(Abodit.Units.TimeRange)">
            <summary>
            Constrain to a specific time of day
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteWellKnown.ConstrainDay(System.Int32)">
            <summary>
            Constrain to a specific day of the month
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteWellKnown.ConstrainMonth(System.Int32)">
            <summary>
            Constrain to a specific month
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteWellKnown.ConstrainDayAndMonth(System.Int32,System.Int32)">
            <summary>
            Constrain to a specific day of the month and to a specific month
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteWellKnown.ConstrainDayAndYear(System.Int32,System.Int32)">
            <summary>
            Constrain to a specific day of the month and to a specific year
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteWellKnown.FactoryWithNiceness(System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32},Abodit.Units.TimeRange)">
            <summary>
            Construct a TemporalSetFiniteSingleWellKnown with niceness
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteWellKnown.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteWellKnown.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteWellKnown.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetFiniteYearList">
            <summary>
            A collection of years
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteYearList.Years">
            <summary>
            The years
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteYearList.#ctor(Abodit.Temporal.TemporalSetFiniteYear[])">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Temporal.TemporalSetFiniteYearList"/> class
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteYearList.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Temporal.TemporalSetFiniteYearList"/> class
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteYearList.#ctor(System.Int32[])">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Temporal.TemporalSetFiniteYearList"/> class
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteYearList.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteYearList.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteYearList.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteYearList.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetHalfInfiniteAfter">
            <summary>
            After a specific date time, e.g. after 5pm today 
            </summary>
            <remarks>
            This is not the same as after an infinite interval, e.g. after 5pm which means something different ...
            </remarks>
        </member>
        <member name="F:Abodit.Temporal.TemporalSetHalfInfiniteAfter.DividingTime">
            <summary>
            Gets the dividing time
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetHalfInfiniteAfter.HasStart">
            <summary>
            Gets whether this TemporalSet has known start point
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetHalfInfiniteAfter.HasEnd">
            <summary>
            Gets whether this TemporalSet has known end point
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetHalfInfiniteAfter.#ctor(Abodit.Units.CalendarDateTime)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetHalfInfiniteAfter"/>
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetHalfInfiniteAfter.Earliest">
            <summary>
            Gets the Earliest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetHalfInfiniteAfter.Latest">
            <summary>
            Gets the latest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetHalfInfiniteAfter.EnumerateForward">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetHalfInfiniteAfter.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetHalfInfiniteAfter.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetHalfInfiniteAfter.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetHalfInfiniteAfter.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetHalfInfiniteAfter.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetHalfInfiniteAfter.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetHalfInfiniteBefore">
            <summary>
            e.g. before 5pm today 
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSetHalfInfiniteBefore.DividingTime">
            <summary>
            Gets the dividing time
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetHalfInfiniteBefore.HasStart">
            <summary>
            Gets whether this TemporalSet has known start point
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetHalfInfiniteBefore.HasEnd">
            <summary>
            Gets whether this TemporalSet has known end point
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetHalfInfiniteBefore.#ctor(Abodit.Units.CalendarDateTime)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetHalfInfiniteBefore"/>
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetHalfInfiniteBefore.Earliest">
            <summary>
            Gets the Earliest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetHalfInfiniteBefore.Latest">
            <summary>
            Gets the latest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetHalfInfiniteBefore.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetHalfInfiniteBefore.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetHalfInfiniteBefore.EnumerateBackward">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetHalfInfiniteBefore.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetHalfInfiniteBefore.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetHalfInfiniteBefore.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetHalfInfiniteBefore.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetInfinite">
            <summary>
            e.g. every monday
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfinite.HasStart">
            <summary>
            Has a finite start point
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfinite.HasEnd">
            <summary>
            Has a finite end point
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfinite.ToString">
            <summary>
            Returns a string representation of this object
            </summary>
            <returns></returns>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfinite.Earliest">
            <summary>
            Gets the Earliest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfinite.Latest">
            <summary>
            Gets the latest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetInfiniteAlways">
            <summary>
            Always
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSetInfiniteAlways.Instance">
            <summary>
            Singleton instance of <see cref="T:Abodit.Temporal.TemporalSetInfiniteAfter"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteAlways.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteAlways.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteAlways.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteAlways.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteAlways.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteAlways.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetInfiniteAnyPeriod">
            <summary>
            An infinite repeat by period (day, month, year, weekend, ...)
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteAnyPeriod.TimePeriod">
            <summary>
            Gets the TimePeriod for this infinite repeat
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteAnyPeriod.#ctor(Abodit.Units.TimePeriod)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Temporal.TemporalSetInfiniteAnyPeriod"/> class
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteAnyPeriod.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteAnyPeriod.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteAnyPeriod.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteAnyPeriod.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteAnyPeriod.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteAnyPeriod.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetInfiniteDayInMonth">
            <summary>
            A specific day in a specific month ( combination of day of month and month)
            e.g. Jun 22nd
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteDayInMonth.DayOfMonth">
            <summary>
            Gets the day of the month
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteDayInMonth.Month">
            <summary>
            Gets the month
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayInMonth.#ctor(System.Int32,System.Int32)">
            <summary>
            A regular set based on a day of the month, e.g. every 1st of the month
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayInMonth.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayInMonth.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayInMonth.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayInMonth.CompareTo(Abodit.Temporal.TemporalSetInfiniteDayInMonth)">
            <summary>
            Compares to another to find earliest in year
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayInMonth.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayInMonth.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayInMonth.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetInfiniteDayOfMonth">
            <summary>
            A repeat on every instance of a particular day of the month e.g. 1st of every month
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSetInfiniteDayOfMonth.MinDay">
            <summary>
            Get the minimum possible integer value for a day (1)
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSetInfiniteDayOfMonth.MaxDay">
            <summary>
            Get the maximum possible integer value for a day (31)
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteDayOfMonth.DayOfMonth">
            <summary>
            Gets the day of the month
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayOfMonth.#ctor(System.Int32)">
            <summary>
            A regular set based on a day of the month, e.g. every 1st of the month
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayOfMonth.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayOfMonth.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayOfMonth.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayOfMonth.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayOfMonth.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayOfMonth.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayOfMonth.CouldBe(System.Int32,System.Type[],Abodit.Temporal.TemporalSetInfiniteDayOfMonth@)">
            <summary>
            Convert an Int to a TemporalSetInfiniteDayOfMonth if that makes sense
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetInfiniteDayOfWeek">
            <summary>
            A repeat on every instance of a particular day of the week e.g. every monday
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteDayOfWeek.DayOfWeek">
            <summary>
            Gets the DayOfWeek
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayOfWeek.#ctor(System.DayOfWeek)">
            <summary>
            A regular set based on a day of the week, e.g. every monday
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayOfWeek.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayOfWeek.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayOfWeek.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayOfWeek.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetInfiniteDayOfWeekList">
            <summary>
            A repeat on every instance of a particular group of days of the week
            </summary>
            <remarks>
            e.g. RANGE: every monday to wednesday
                 RANGE: from sunday to tuesday,
                 RANGE: from sunday thru tuesday,
                 SET: sundays and mondays 
                 SET: every monday, wednesday, or friday ...
            
            This can be either a RANGE or a SET
            </remarks>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteDayOfWeekList.DayOfWeekStart">
            <summary>
            Gets the start day of week
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteDayOfWeekList.DayOfWeekEnd">
            <summary>
            Gets the end day of week (may wrap)
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteDayOfWeekList.DaysIncluded">
            <summary>
            Gets the days include
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteDayOfWeekList.IsRange">
            <summary>
            Is this a range of days?
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteDayOfWeekList.IsContiguous">
            <summary>
            Are the days contiguous?
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayOfWeekList.#ctor(System.DayOfWeek,System.DayOfWeek)">
            <summary>
            A range of days of the week, e.g. every monday to wednesday
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayOfWeekList.#ctor(System.Collections.Generic.IEnumerable{System.DayOfWeek},System.Boolean)">
            <summary>
            An arbitrary set of days of the week (unordered) or a range (disjoint)
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayOfWeekList.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayOfWeekList.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayOfWeekList.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayOfWeekList.Create(System.Collections.Generic.IEnumerable{System.DayOfWeek},System.Boolean)">
            <summary>
            Creates a new TemporalSet (with simplification)
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayOfWeekList.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayOfWeekList.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteDayOfWeekList.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetInfiniteHalfSpecific">
            <summary>
            A repeat on a half-year period
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteHalfSpecific.HalfNumber">
            <summary>
            Get the half number
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteHalfSpecific.FirstMonth">
            <summary>
            Get the first month of the half
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteHalfSpecific.Quarters">
            <summary>
            Get the quarters in this half
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteHalfSpecific.Months">
            <summary>
            Get the months in this half
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteHalfSpecific.#ctor(System.Int32)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetInfiniteHalfSpecific"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteHalfSpecific.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteHalfSpecific.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteHalfSpecific.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteHalfSpecific.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteHalfSpecific.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteHalfSpecific.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetInfiniteMonthList">
            <summary>
            A repeat on every instance of a particular group of months
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteMonthList.MonthStart">
            <summary>
            The first month in the list
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteMonthList.MonthEnd">
            <summary>
            The last month in the list
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteMonthList.Months">
            <summary>
            Gets the months
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteMonthList.IsRange">
            <summary>
            Is a range of months
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteMonthList.IsContiguous">
            <summary>
            Is contiguous
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteMonthList.#ctor(System.Int32,System.Int32)">
            <summary>
            A range of months, e.g. jun thru jul
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteMonthList.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Boolean)">
            <summary>
            An arbitrary set of months
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteMonthList.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteMonthList.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteMonthList.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteMonthList.Create(System.Collections.Generic.IEnumerable{System.Int32},System.Int32)">
            <summary>
            Create a month list (or simpler IntervalInYear) from a list of months and an additional month
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteMonthList.Create(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Create a month list (or simpler IntervalInYear) from a list of months
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteMonthList.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteMonthList.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteMonthList.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetInfiniteMonthSpecific">
            <summary>
            A repeat on a month, e.g. every January
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSetInfiniteMonthSpecific.January">
            <summary>
            Jan
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSetInfiniteMonthSpecific.February">
            <summary>
            Feb
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSetInfiniteMonthSpecific.March">
            <summary>
            Mar
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSetInfiniteMonthSpecific.April">
            <summary>
            Apr
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSetInfiniteMonthSpecific.May">
            <summary>
            May
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSetInfiniteMonthSpecific.June">
            <summary>
            Jun
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSetInfiniteMonthSpecific.July">
            <summary>
            Jul
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSetInfiniteMonthSpecific.August">
            <summary>
            Aug
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSetInfiniteMonthSpecific.September">
            <summary>
            Sep
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSetInfiniteMonthSpecific.October">
            <summary>
            Oct
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSetInfiniteMonthSpecific.November">
            <summary>
            Nov
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSetInfiniteMonthSpecific.December">
            <summary>
            Dec
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteMonthSpecific.MonthNumber">
            <summary>
            The month number
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteMonthSpecific.#ctor(System.Int32)">
            <summary>
            A regular set based on a month, e.g. every January
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteMonthSpecific.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteMonthSpecific.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteMonthSpecific.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteMonthSpecific.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteMonthSpecific.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteMonthSpecific.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetInfiniteQuarterSpecific">
            <summary>
            A repeat on a quarter
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteQuarterSpecific.QuarterNumber">
            <summary>
            The number of the quarter
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteQuarterSpecific.FirstMonth">
            <summary>
            The first month of the quarter
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteQuarterSpecific.LastMonth">
            <summary>
            The last month of the quarter
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteQuarterSpecific.Months">
            <summary>
            The months in the quarter
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteQuarterSpecific.#ctor(System.Int32)">
            <summary>
            A regular set based on a month, e.g. every January
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteQuarterSpecific.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteQuarterSpecific.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteQuarterSpecific.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteQuarterSpecific.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteQuarterSpecific.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteQuarterSpecific.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetInfiniteRepeatYearly">
            <summary>
            A repeat on every instance of a particular period in a year (e.g. christmas)
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteRepeatYearly.Name">
            <summary>
            Gets the name for this repeat, e.g. Easter
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteRepeatYearly.#ctor(System.String,System.Func{Abodit.Units.CalendarDate,Abodit.Units.CalendarDateTimeRange})">
            <summary>
            A repeat on every instance of a particular period in a year (e.g. christmas)
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteRepeatYearly.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteRepeatYearly.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteRepeatYearly.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteRepeatYearly.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteRepeatYearly.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteRepeatYearly.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetInfiniteTimeExactInDay">
            <summary>
            A repeat on a specific time, e.g. at 5pm (treated as a small range +/- 5 minutes)
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteTimeExactInDay.Time">
            <summary>
            Gets the Time of day
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTimeExactInDay.#ctor(Abodit.Units.Time)">
            <summary>
            A regular set based on a point in time within a day, e.g. 5pm
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTimeExactInDay.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay">
            <summary>
            A repeat on a time range with a day, e.g. 5pm to 8pm
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay.TimeRange">
            <summary>
            Gets the TimeRange
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay.#ctor(Abodit.Units.Time,Abodit.Units.Time)">
            <summary>
            A regular set based on a time range within a day, e.g. 5pm to 7pm
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay.#ctor(Abodit.Units.TimeRange)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay"/>
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay.Pieces">
            <summary>
            Get one or two pieces not overlapping midnight
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate the TemporalSet forward from a given point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay.Morning">
            <summary>
            Morning
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay.Afternoon">
            <summary>
            Afternoon
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay.Evening">
            <summary>
            Evening
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay.Night">
            <summary>
            Night
            </summary>
        </member>
        <member name="F:Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay.AllDay">
            <summary>
            All day
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay.TemporalSetInfiniteTimeRangeOfDayMorning.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay.TemporalSetInfiniteTimeRangeOfDayAfternoon.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay.TemporalSetInfiniteTimeRangeOfDayEvening.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay.TemporalSetInfiniteTimeRangeOfDayNight.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay.TemporalSetInfiniteTimeRangeOfDayAllDay.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay.Equals(Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTimeRangeInDay.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetInfiniteWeekday">
            <summary>
            A regular set based on a day of the week, e.g. every monday
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteWeekday.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteWeekday.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteWeekday.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteWeekday.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteWeekday.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteWeekday.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetInfiniteWeekend">
            <summary>
            A weekend repeat
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteWeekend.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteWeekend.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteWeekend.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteWeekend.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteWeekend.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteWeekend.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetInfiniteWeekSpecific">
            <summary>
            A repeat on a numbered week in a year, e.g. week 27
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteWeekSpecific.WeekNumber">
            <summary>
            Gets the Week number
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteWeekSpecific.#ctor(System.Int32)">
            <summary>
            A regular set based on a month, e.g. every January
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteWeekSpecific.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteWeekSpecific.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteWeekSpecific.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteWeekSpecific.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteWeekSpecific.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteWeekSpecific.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetIntersectionFinite">
            <summary>
            The intersection of two temporal sets which has a finite result
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetIntersectionFinite.Left">
            <summary>
            Get the left set
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetIntersectionFinite.Right">
            <summary>
            Get the right set
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetIntersectionFinite.HasStart">
            <summary>
            Does this intersection have a start time?
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetIntersectionFinite.HasEnd">
            <summary>
            Does this intersection have an end time?
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetIntersectionFinite.Earliest">
            <summary>
            Gets the earliest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetIntersectionFinite.Latest">
            <summary>
            Gets the latest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetIntersectionFinite.#ctor(Abodit.Temporal.TemporalSet,Abodit.Temporal.TemporalSet)">
            <summary>
            An intersection of two sets, at least one of which is infinite (otherwise you should go combine them first)
            OR both are opposing half intervals (e.g. after May 2010 ^ before June 2011
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetIntersectionFinite.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetIntersectionFinite.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetIntersectionFinite.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetIntersectionFinite.EnumerateForward">
            <summary>
            Enumerate the TemporalSet forward
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetIntersectionFinite.EnumerateBackward">
            <summary>
            Enumerate the TemporalSet backward
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetIntersectionFinite.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetIntersectionFinite.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetIntersectionFinite.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetIntersectionInfinite">
            <summary>
            The intersection of two temporal sets (at least one of which is infinite (otherwise you could combine them directly))
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetIntersectionInfinite.Left">
            <summary>
            Get the left set
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetIntersectionInfinite.Right">
            <summary>
            Get the right set
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetIntersectionInfinite.HasStart">
            <summary>
            Does this temporal set have a known start point in time?
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetIntersectionInfinite.HasEnd">
            <summary>
            Does this temporal set have a known end point in time?
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetIntersectionInfinite.Earliest">
            <summary>
            Gets the Earliest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetIntersectionInfinite.Latest">
            <summary>
            Gets the latest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetIntersectionInfinite.#ctor(Abodit.Temporal.TemporalSet,Abodit.Temporal.TemporalSet)">
            <summary>
            An intersection of two sets that is infinite
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetIntersectionInfinite.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetIntersectionInfinite.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetIntersectionInfinite.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetIntersectionInfinite.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetIntersectionInfinite.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetIntersectionInfinite.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetNever">
            <summary>
            A temporal set with nothing in it
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetNever.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetNever.HasStart">
            <summary>
            Has a finite start point
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetNever.HasEnd">
            <summary>
            Has a finite end point
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetNever.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetNever.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetNever.Earliest">
            <summary>
            Gets the Earliest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetNever.Latest">
            <summary>
            Gets the latest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetNever.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetNever.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetNever.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetInfiniteShift">
            <summary>
            Shifts a temporal set by a given time period
            </summary>
            <remarks>
            Three weeks before ... the first week in November
            </remarks>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteShift.Child">
            <summary>
            The nested or child Temporal set
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteShift.TimePeriod">
            <summary>
            The time period to shift by
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteShift.#ctor(Abodit.Temporal.TemporalSet,Abodit.Units.TimePeriod)">
            <summary>
            The first infnite in infinite
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteShift.HasStart">
            <summary>
            Has a finite start point
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteShift.HasEnd">
            <summary>
            Has a finite end point
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteShift.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteShift.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteShift.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteShift.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteShift.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetFiniteShift">
            <summary>
            Shifts a finite temporal set by a given time period
            </summary>
            <remarks>
            Three weeks before ... the first week in November
            </remarks>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteShift.Child">
            <summary>
            The nested temporal set
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteShift.TimePeriod">
            <summary>
            The time period
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteShift.#ctor(Abodit.Temporal.TemporalSetFinite,Abodit.Units.TimePeriod)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Temporal.TemporalSetFiniteShift"/> class
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteShift.HasStart">
            <summary>
            Has a finite start point
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteShift.HasEnd">
            <summary>
            Has a finite end point
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteShift.Earliest">
            <summary>
            Gets the Earliest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteShift.Latest">
            <summary>
            Gets the latest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteShift.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteShift.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteShift.EnumerateForward">
            <summary>
            Enumerate the TemporalSet forward
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteShift.EnumerateBackward">
            <summary>
            Enumerate the TemporalSet backward
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteShift.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteShift.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteShift.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetInfiniteTheLast">
            <summary>
            The words "The Last" applied to another TemporalSet (e.g. the last week in November)
            </summary>
            <remarks>
            The last week in November
            The last day of Spring
            The last weekend after the 28th of September
            </remarks>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteTheLast.Left">
            <summary>
            Gets the left set
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteTheLast.Right">
            <summary>
            Gets the right set
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTheLast.#ctor(Abodit.Temporal.TemporalSet,Abodit.Temporal.TemporalSet)">
            <summary>
            The last infnite in infinite
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteTheLast.HasStart">
            <summary>
            Does this temporal set have a known start point in time?
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteTheLast.HasEnd">
            <summary>
            Has a finite end point
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTheLast.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTheLast.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTheLast.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTheLast.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTheLast.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTheLast.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetFiniteTheLast">
            <summary>
            The words "The Last" TemporalSet in TemporalSetFinite
            </summary>
            <remarks>
            The first sunday in August 2013
            </remarks>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteTheLast.Left">
            <summary>
            Gets the left set
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteTheLast.Right">
            <summary>
            Gets the right set
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheLast.#ctor(Abodit.Temporal.TemporalSet,Abodit.Temporal.TemporalSet)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetFiniteTheLast"/>
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteTheLast.HasStart">
            <summary>
            Does this temporal set have a known start point in time?
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteTheLast.HasEnd">
            <summary>
            Has a finite end point
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteTheLast.Earliest">
            <summary>
            Gets the Earliest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteTheLast.Latest">
            <summary>
            Gets the latest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheLast.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheLast.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheLast.EnumerateForward">
            <summary>
            Enumerate the TemporalSet forward
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheLast.EnumerateBackward">
            <summary>
            Enumerate the TemporalSet backward
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheLast.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheLast.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheLast.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheLast.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetInfiniteTheNth">
            <summary>
            The words "The First", "the second", ... applied to another TemporalSet / Temporal set intersection (e.g. the first week in November)
            </summary>
            <remarks>
            The first week in November
            The first day of Spring
            The first weekend after the 28th of September
            </remarks>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteTheNth.Intersected">
            <summary>
            Gets the intersected set
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteTheNth.Left">
            <summary>
            Gets the left set
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteTheNth.Right">
            <summary>
            Gets the right set
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteTheNth.Nth">
            <summary>
            Gets the n value
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTheNth.#ctor(System.Int32,Abodit.Temporal.TemporalSet,Abodit.Temporal.TemporalSet)">
            <summary>
            The first infnite in infinite
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteTheNth.HasStart">
            <summary>
            Does this temporal set have a known start point in time?
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteTheNth.HasEnd">
            <summary>
            Has a finite end point
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTheNth.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTheNth.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTheNth.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTheNth.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTheNth.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTheNth.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetFiniteTheNth">
            <summary>
            The nth TemporalSet in TemporalSetFinite
            </summary>
            <remarks>
            The 3rd sunday in August 2013
            </remarks>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteTheNth.Intersected">
            <summary>
            Gets the intersected set
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteTheNth.Left">
            <summary>
            Gets the left set
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteTheNth.Right">
            <summary>
            Gets the right set
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteTheNth.Nth">
            <summary>
            Gets the n value
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheNth.#ctor(System.Int32,Abodit.Temporal.TemporalSet,Abodit.Temporal.TemporalSet)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetFiniteTheNth"/>
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteTheNth.HasStart">
            <summary>
            Does this temporal set have a known start point in time?
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteTheNth.HasEnd">
            <summary>
            Has a finite end point
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteTheNth.Earliest">
            <summary>
            Gets the Earliest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteTheNth.Latest">
            <summary>
            Gets the latest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheNth.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheNth.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheNth.EnumerateForward">
            <summary>
            Enumerate the TemporalSet forward
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheNth.EnumerateBackward">
            <summary>
            Enumerate the TemporalSet backward
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheNth.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheNth.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheNth.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheNth.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetInfiniteTheXAfterY">
            <summary>
            The X after Y, could be finite or infinite
            </summary>
            <remarks>
            The hour after midnight
            The three days after May 2015
            
            Could be finite or infinite
            </remarks>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteTheXAfterY.Period">
            <summary>
            The period before
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteTheXAfterY.Nested">
            <summary>
            The nested temporal set
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTheXAfterY.#ctor(Abodit.Units.TimePeriod,Abodit.Temporal.TemporalSet)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetInfiniteTheXAfterY"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTheXAfterY.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTheXAfterY.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteTheXAfterY.HasStart">
            <summary>
            Does this temporal set have a known start point in time?
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteTheXAfterY.HasEnd">
            <summary>
            Has a finite end point
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteTheXAfterY.Earliest">
            <summary>
            Gets the Earliest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteTheXAfterY.Latest">
            <summary>
            Gets the latest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTheXAfterY.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTheXAfterY.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTheXAfterY.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteTheXAfterY.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetFiniteTheXAfterY">
            <summary>
            The X after Y
            </summary>
            <remarks>
            The hour after midnight
            The three days after May 2015
            </remarks>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteTheXAfterY.Period">
            <summary>
            Gets the period
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteTheXAfterY.Nested">
            <summary>
            Gets the nested set
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheXAfterY.#ctor(Abodit.Units.TimePeriod,Abodit.Temporal.TemporalSet)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetFiniteTheXAfterY"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheXAfterY.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheXAfterY.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheXAfterY.EnumerateForward">
            <summary>
            Enumerate the TemporalSet forward
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheXAfterY.EnumerateBackward">
            <summary>
            Enumerate the TemporalSet backward
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteTheXAfterY.HasStart">
            <summary>
            Does this temporal set have a known start point in time?
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteTheXAfterY.HasEnd">
            <summary>
            Has a finite end point
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteTheXAfterY.Earliest">
            <summary>
            Gets the Earliest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteTheXAfterY.Latest">
            <summary>
            Gets the latest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheXAfterY.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheXAfterY.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheXAfterY.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheXAfterY.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY">
            <summary>
            The X before Y, could be finite or infinite
            </summary>
            <remarks>
            The hour before midnight
            The three days before May 2015
            
            Could be finite or infinite
            </remarks>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY.Period">
            <summary>
            Gets the period
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY.Nested">
            <summary>
            Gets the nested set
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY.#ctor(Abodit.Units.TimePeriod,Abodit.Temporal.TemporalSet)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY.HasStart">
            <summary>
            Does this temporal set have a known start point in time?
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY.HasEnd">
            <summary>
            Has a finite end point
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY.Earliest">
            <summary>
            Gets the Earliest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY.Latest">
            <summary>
            Gets the latest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetInfiniteThePeriodXBeforeY.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetFiniteTheXBeforeY">
            <summary>
            The X before Y, could be finite or infinite
            </summary>
            <remarks>
            The hour before midnight
            The three days before May 2015
            
            Could be finite or infinite
            </remarks>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteTheXBeforeY.TimePeriod">
            <summary>
            The time period before
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteTheXBeforeY.Nested">
            <summary>
            The nested temporal set
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheXBeforeY.#ctor(Abodit.Units.TimePeriod,Abodit.Temporal.TemporalSet)">
            <summary>
            Create a new instance of <see cref="T:Abodit.Temporal.TemporalSetFiniteTheXBeforeY"/>
            </summary>
            <param name="period"></param>
            <param name="left"></param>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheXBeforeY.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheXBeforeY.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheXBeforeY.EnumerateForward">
            <summary>
            Enumerate the TemporalSet forward
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheXBeforeY.EnumerateBackward">
            <summary>
            Enumerate the TemporalSet backward
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteTheXBeforeY.HasStart">
            <summary>
            Does this temporal set have a known start point in time?
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteTheXBeforeY.HasEnd">
            <summary>
            Has a finite end point
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteTheXBeforeY.Earliest">
            <summary>
            Gets the Earliest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetFiniteTheXBeforeY.Latest">
            <summary>
            Gets the latest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheXBeforeY.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheXBeforeY.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheXBeforeY.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetFiniteTheXBeforeY.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetUnionFinite">
            <summary>
            The finite union of two temporal sets (i.e. both are also finite)
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetUnionFinite.Left">
            <summary>
            Gets the left set
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetUnionFinite.Right">
            <summary>
            Gets the right set
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetUnionFinite.HasStart">
            <summary>
            Does this temporal set have a known start point in time?
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetUnionFinite.HasEnd">
            <summary>
            Has a finite end point
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetUnionFinite.Earliest">
            <summary>
            Gets the Earliest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetUnionFinite.Latest">
            <summary>
            Gets the latest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetUnionFinite.#ctor(Abodit.Temporal.TemporalSet,Abodit.Temporal.TemporalSet)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetUnionFinite"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetUnionFinite.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetUnionFinite.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetUnionFinite.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetUnionFinite.EnumerateForward">
            <summary>
            Enumerate the TemporalSet forward
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetUnionFinite.EnumerateBackward">
            <summary>
            Enumerate the TemporalSet backward
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetUnionFinite.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetUnionFinite.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetUnionFinite.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetUnionInfinite">
            <summary>
            The union of two temporal sets, at least one being infinite
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetUnionInfinite.Left">
            <summary>
            Gets the left set
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetUnionInfinite.Right">
            <summary>
            Gets the right set
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetUnionInfinite.HasStart">
            <summary>
            Does this temporal set have a known start point in time?
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetUnionInfinite.HasEnd">
            <summary>
            Has a finite end point
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetUnionInfinite.Earliest">
            <summary>
            Gets the Earliest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetUnionInfinite.Latest">
            <summary>
            Gets the latest calendar date time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetUnionInfinite.#ctor(Abodit.Temporal.TemporalSet,Abodit.Temporal.TemporalSet)">
            <summary>
            Creates a new <see cref="T:Abodit.Temporal.TemporalSetUnionInfinite"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetUnionInfinite.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetUnionInfinite.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetUnionInfinite.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetUnionInfinite.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetUnionInfinite.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetUnionInfinite.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetUnknown">
            <summary>
            An unknown or unknowable answer
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetUnknown.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetUnknown.HasStart">
            <summary>
            Has a finite start point
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetUnknown.HasEnd">
            <summary>
            Has a finite end point
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetUnknown.EnumerateForward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going forward from a point in time
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetUnknown.EnumerateBackward(Abodit.Units.CalendarDateTime)">
            <summary>
            Enumerate a (possibly infinite) temporal set going backward from a point in time
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetUnknown.Earliest">
            <summary>
            Gets the Earliest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="P:Abodit.Temporal.TemporalSetUnknown.Latest">
            <summary>
            Gets the latest possible <see cref="T:Abodit.Units.CalendarDateTime"/>
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetUnknown.Equals(Abodit.Expressions.TokenExpression)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetUnknown.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetUnknown.Accept``1(Abodit.Expressions.Visitor.ITemporalSetVisitor{``0})">
            <summary>
            Accepts a visitor
            </summary>
        </member>
        <member name="T:Abodit.Temporal.TemporalSetHelper">
            <summary>
            Static methods taken out of temporal set
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetHelper.CreateUnion(Abodit.Temporal.TemporalSet,Abodit.Temporal.TemporalSet)">
            <summary>
            Create the union of two temporal sets
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetHelper.CreateTheFirst(Abodit.Temporal.TemporalSet,Abodit.Temporal.TemporalSet)">
            <summary>
            Create the first intersection of one temporal set with another (e.g. first Sunday in May)
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetHelper.CreateTheLast(Abodit.Temporal.TemporalSet,Abodit.Temporal.TemporalSet)">
            <summary>
            Create the last intersection of one temporal set with another (e.g. last Sunday in May)
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetHelper.CreateTheNth(System.Int32,Abodit.Temporal.TemporalSet,Abodit.Temporal.TemporalSet)">
            <summary>
            Create the nth intersection of one temporal set with another (e.g. 3rd Sunday in May)
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetHelper.CreateAfter(Abodit.Temporal.TemporalSetInfinite,Abodit.Temporal.TemporalSetFinite)">
            <summary>
            Create a half infinite after another temporal set, e.g. May 23rd after 2015
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetHelper.CreateBefore(Abodit.Temporal.TemporalSetInfinite,Abodit.Temporal.TemporalSetFinite)">
            <summary>
            Create a half infinite before another temporal set, e.g. every May 23rd before 2015
            </summary>
        </member>
        <member name="M:Abodit.Temporal.TemporalSetHelper.CreateIntersection(Abodit.Temporal.TemporalSet,Abodit.Temporal.TemporalSet)">
            <summary>
            Create the intersection of two temporal sets
            </summary>
        </member>
        <member name="T:Abodit.Temporal.ITemporalSet">
            <summary>
            Interface for a Temporal Set
            </summary>
        </member>
        <member name="P:Abodit.Temporal.ITemporalSet.IsFinite">
            <summary>
            Is this temporal set finite?
            </summary>
        </member>
        <member name="P:Abodit.Temporal.ITemporalSet.IsInfinite">
            <summary>
            Is this temporal set infinite?
            </summary>
        </member>
        <member name="P:Abodit.Temporal.ITemporalSet.HasStart">
            <summary>
            Does this temporal set have a start?
            </summary>
        </member>
        <member name="P:Abodit.Temporal.ITemporalSet.HasEnd">
            <summary>
            Does this temporal set have an end?
            </summary>
        </member>
        <member name="M:Abodit.Temporal.ITemporalSet.Describe(System.Boolean)">
            <summary>
            Describe this temporal set
            </summary>
        </member>
        <member name="P:Abodit.Temporal.ITemporalSet.Earliest">
            <summary>
            Earliest 
            </summary>
        </member>
        <member name="P:Abodit.Temporal.ITemporalSet.Latest">
            <summary>
            Latest
            </summary>
        </member>
        <member name="T:Abodit.Temporal.IInfinite">
            <summary>
            An infinite temporal set
            </summary>
        </member>
        <member name="T:Abodit.Temporal.IHaveStart">
            <summary>
            A temporal set with a finite start
            </summary>
        </member>
        <member name="M:Abodit.Temporal.IHaveStart.EnumerateForward">
            <summary>
            Enumerate this temporal set forward from its finite start
            </summary>
        </member>
        <member name="T:Abodit.Temporal.IHaveEnd">
            <summary>
            A temporal set with a finite end
            </summary>
        </member>
        <member name="M:Abodit.Temporal.IHaveEnd.EnumerateBackward">
            <summary>
            Enumerate this temporal set backward from its finite end
            </summary>
        </member>
        <member name="T:Abodit.Temporal.IFinite">
            <summary>
            A finite temporal set
            </summary>
        </member>
        <member name="T:Abodit.Sensitivity">
            <summary>
            Sensitivity for matching
            </summary>
        </member>
        <member name="P:Abodit.Sensitivity.CaseInsensitive">
            <summary>
            Case insensitive
            </summary>
        </member>
        <member name="P:Abodit.Sensitivity.EditDistance">
            <summary>
            Edit distance allowed or obtained
            </summary>
        </member>
        <member name="P:Abodit.Sensitivity.Strict">
            <summary>
            If set, sensitivity must match exactly, not includes
            </summary>
        </member>
        <member name="F:Abodit.Sensitivity.Default">
            <summary>
            Default sensitivity = case sensitive (but OK at start of sentence)
            </summary>
        </member>
        <member name="F:Abodit.Sensitivity.NoneStrict">
            <summary>
            Case sensitive and must match all characters
            </summary>
        </member>
        <member name="F:Abodit.Sensitivity.Insensitive">
            <summary>
            Insensitive, no edits
            </summary>
        </member>
        <member name="F:Abodit.Sensitivity.InsensitiveWithOneEdit">
            <summary>
            Insensitive, one edit
            </summary>
        </member>
        <member name="F:Abodit.Sensitivity.InsensitiveWithTwoEdits">
            <summary>
            Insensitive, two edits
            </summary>
        </member>
        <member name="M:Abodit.Sensitivity.Create(System.Boolean,System.Int32)">
            <summary>
            Creates a new <see cref="T:Abodit.Sensitivity"/>
            </summary>
        </member>
        <member name="M:Abodit.Sensitivity.Union(Abodit.Sensitivity)">
            <summary>
            Union two sensitivities together to form the least restrictive
            </summary>
        </member>
        <member name="M:Abodit.Sensitivity.Equals(Abodit.Sensitivity)">
            <summary>
            Are these sensitivities equal
            </summary>
        </member>
        <member name="M:Abodit.Sensitivity.Incorporates(Abodit.Sensitivity)">
            <summary>
            Does this Sensitivity incorporate the other one
            </summary>
        </member>
        <member name="M:Abodit.Sensitivity.CompareTo(Abodit.Sensitivity)">
            <summary>
            Best one sorts first, EditDistance >> Case Sensitivity
            </summary>
        </member>
        <member name="P:Abodit.Sensitivity.Score">
            <summary>
            A score for the sensitivity used - highest == worst
            edit distance counts most, then case sensitivity, ...
            </summary>
        </member>
        <member name="M:Abodit.Sensitivity.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:Abodit.TernaryTree`1">
            <summary>
            A Ternary Tree with a generic value on each node
            </summary>
        </member>
        <member name="M:Abodit.TernaryTree`1.Add(System.String,`0)">
            <summary>
            Add a key and value to the tree
            </summary>
        </member>
        <member name="M:Abodit.TernaryTree`1.Contains(System.String)">
            <summary>
            Does the tree contain a particular key?
            </summary>
        </member>
        <member name="M:Abodit.TernaryTree`1.TryGetValue(System.String,`0@)">
            <summary>
            Get a value from the tree
            </summary>
        </member>
        <member name="M:Abodit.TernaryTree`1.AddOrUpdate(System.String,System.Func{`0,`0})">
            <summary>
            Get a value from the tree or add a new value if it does not exist
            </summary>
        </member>
        <member name="M:Abodit.TernaryTree`1.GetPathValues(System.String,System.Int32)">
            <summary>
            Get all values along a path, i.e. substrings of the input that have a value on them 
            </summary>
        </member>
        <member name="M:Abodit.TernaryTree`1.GetPathValues(Abodit.TernaryTree{`0}.TernaryNode,System.String,System.Int32)">
            <summary>
            Get all values along a path, i.e. substrings of the input that have a value on them 
            </summary>
        </member>
        <member name="M:Abodit.TernaryTree`1.GetAutocompleteValues(System.String,System.Int32)">
            <summary>
            Get all values at or beyond this prefix for an autocomplete operation
            </summary>
        </member>
        <member name="P:Abodit.TernaryTree`1.NodeWithPos.Text">
            <summary>
            The accumulated text from nodes above and including this one
            </summary>
        </member>
        <member name="M:Abodit.TernaryTree`1.UnionWith(Abodit.TernaryTree{`0})">
            <summary>
            Merge another ternary tree into this one
            </summary>
        </member>
        <member name="M:Abodit.TernaryTree`1.GetBelow(Abodit.TernaryTree{`0}.TernaryNode,System.String,Abodit.TernaryTree{`0}.TernaryNode)">
            <summary>
            Return words below here in alphabetic order (lazily)
            </summary>
        </member>
        <member name="T:Abodit.TernaryTree`1.TernaryNode">
            <summary>
            A Node on the tree
            </summary>
        </member>
        <member name="M:Abodit.TernaryTree`1.TernaryNode.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:Abodit.TernaryTree`1.GetFuzzyMatches(System.String,System.Int32,Abodit.Sensitivity)">
            <summary>
            Get fuzzy matches with an edit distance of e on a substring of the input 's'
            </summary>
        </member>
        <member name="M:Abodit.TernaryTree`1.GetFuzzyMatches(Abodit.TernaryTree{`0}.TernaryNode,System.String,System.Int32,Abodit.Sensitivity)">
            <summary>
            Get fuzzy matches with an edit distance of e on a substring of the input 's'
            </summary>
        </member>
        <member name="M:Abodit.TernaryTree`1.SimilarLetters(System.Char,System.Char)">
            <summary>
            Returns true if the letters are phonetically similar or
            are located close to each other on qwerty keyboard
            </summary>
        </member>
        <member name="T:Abodit.TernaryTreeList`1">
            <summary>
            A ternary tree with lists as the leafs
            </summary>
        </member>
        <member name="M:Abodit.TernaryTreeList`1.AddToTree(System.String,`0)">
            <summary>
            Add to the ternary tree
            </summary>
        </member>
        <member name="T:Abodit.TernaryTreeMatch`1">
            <summary>
            The results from a ternary tree match
            </summary>
        </member>
        <member name="P:Abodit.TernaryTreeMatch`1.InputText">
            <summary>
            Gets the input text
            </summary>
        </member>
        <member name="P:Abodit.TernaryTreeMatch`1.TreeText">
            <summary>
            Gets the tree text that matched the input text
            </summary>
        </member>
        <member name="P:Abodit.TernaryTreeMatch`1.SensitivityUsed">
            <summary>
            Gets the sensitivity used
            </summary>
        </member>
        <member name="P:Abodit.TernaryTreeMatch`1.Value">
            <summary>
            Gets the value
            </summary>
        </member>
        <member name="M:Abodit.TernaryTreeMatch`1.ToStringElementType``1">
            <summary>
            ToString enhanced for Enumerables
            </summary>
        </member>
        <member name="M:Abodit.TernaryTreeMatch`1.ToString">
            <summary>
            ToString
            </summary>
        </member>
    </members>
</doc>
