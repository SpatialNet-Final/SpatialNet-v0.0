<?xml version="1.0"?>
<doc>
    <assembly>
        <name>AboditNLP</name>
    </assembly>
    <members>
        <member name="T:AboditNLP.Attributes.SensitiveAttribute">
            <summary>
            Sets the sensitivity required for a given parameter of an NLP rule
            </summary>
        </member>
        <member name="P:AboditNLP.Attributes.SensitiveAttribute.Sensitivity">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Attributes.SensitiveAttribute"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.Attributes.Strict">
            <summary>
            Indicates that case and spelling must match exactly
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.Strict.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Attributes.Strict"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.Attributes.InsensitiveAttribute">
            <summary>
            Indicates that case or punctuation insensitive matching should be used
            e.g. iPhone, IPhone, iphone
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.InsensitiveAttribute.#ctor(System.Boolean,System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Attributes.InsensitiveAttribute"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.Attributes.OptionalAttribute">
            <summary>
            Indicates that a token is optional. Use only on non-value-type parameters.
            </summary>
            <remarks>
            You can also use the .NET provided Optional parameter but use this one instead for clarity
            You will get an exception if you use this on a ValueType.
            </remarks>
        </member>
        <member name="P:AboditNLP.Attributes.OptionalAttribute.Group">
            <summary>
            The Group that this parameter belongs to (semantics is all or none for grouped optional parameters)
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.OptionalAttribute.#ctor">
            <summary>
            Create a new instance of the optional attribute
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.OptionalAttribute.#ctor(System.Int32)">
            <summary>
            Optional attributes can be grouped so they all go away together or all stay (e.g. 5 km - want both the double and the unit to stay)
            </summary>
            <param name="group">The group to which this parameter belongs</param>
        </member>
        <member name="T:AboditNLP.Attributes.ParameterData">
            <summary>
            ParameterData used internally when creating rules
            </summary>
        </member>
        <member name="P:AboditNLP.Attributes.ParameterData.ParameterType">
            <summary>
            The type of this parameter
            </summary>
        </member>
        <member name="P:AboditNLP.Attributes.ParameterData.Position">
            <summary>
            Position in the calling array
            </summary>
        </member>
        <member name="P:AboditNLP.Attributes.ParameterData.Optional">
            <summary>
            An optional parameter
            </summary>
        </member>
        <member name="P:AboditNLP.Attributes.ParameterData.Permute">
            <summary>
            Permute this parameter
            </summary>
        </member>
        <member name="P:AboditNLP.Attributes.ParameterData.Sensitivity">
            <summary>
            The sensitivity to use for matching
            </summary>
        </member>
        <member name="P:AboditNLP.Attributes.ParameterData.SpecificInterfaces">
            <summary>
            Specific interfaces that have been requested for this parameter in addition to the type specified
            </summary>
        </member>
        <member name="P:AboditNLP.Attributes.ParameterData.PermuteGroup">
            <summary>
            Permute group or -1 if not permuted
            </summary>
        </member>
        <member name="P:AboditNLP.Attributes.ParameterData.Group">
            <summary>
            Belonging group or 0 if no attachment to other Tokens
            </summary>
            <remarks>
            An Optional group is all-or-none.
            </remarks>
        </member>
        <member name="M:AboditNLP.Attributes.ParameterData.#ctor(System.Type,System.Int32,System.Boolean,System.Int32,System.Boolean,System.Int32,Abodit.Sensitivity)">
            <summary>
            Create a new instance of the ParameterData class
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.ParameterData.#ctor(System.Reflection.ParameterInfo,System.Int32)">
            <summary>
            Create a new instance of the ParameterData class
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.ParameterData.ToString">
            <summary>
            Return a string representation of this object
            </summary>
        </member>
        <member name="T:AboditNLP.Attributes.PermuteAttribute">
            <summary>
            Indicates that all consecutive permute tokens having the same group number may be found in any order
            </summary>
        </member>
        <member name="P:AboditNLP.Attributes.PermuteAttribute.Group">
            <summary>
            The Group to which this permutation belongs
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.PermuteAttribute.#ctor">
            <summary>
            Create a new instance of the PermuteAttribute class with no group
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.PermuteAttribute.#ctor(System.Int32)">
            <summary>
            Create a new instance of the PermuteAttribute class in a specific group
            </summary>
        </member>
        <member name="T:AboditNLP.Attributes.PriorityAttribute">
            <summary>
            The Priority of a rule determines in what order competing rules get executed.  
            If two rules have matched an input, the one with the highest priority will win.
            The default priority is zero.
            </summary>
        </member>
        <member name="P:AboditNLP.Attributes.PriorityAttribute.Value">
            <summary>
            The value of this priority
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.PriorityAttribute.#ctor(System.Int32)">
            <summary>
            Create a new instance of the Priority attribute
            </summary>
        </member>
        <member name="T:AboditNLP.Attributes.Associativity">
            <summary>
            The Associativity of an operator
            </summary>
        </member>
        <member name="F:AboditNLP.Attributes.Associativity.Left">
            <summary>
            A left associative operator
            </summary>
        </member>
        <member name="F:AboditNLP.Attributes.Associativity.Right">
            <summary>
            A right associative operator
            </summary>
        </member>
        <member name="F:AboditNLP.Attributes.Associativity.None">
            <summary>
            An operator with no associativity
            </summary>
        </member>
        <member name="T:AboditNLP.Attributes.ProductionRuleAttribute">
            <summary>
            Indicates that a method is a production rule and defines its associativity and precedence
            </summary>
        </member>
        <member name="P:AboditNLP.Attributes.ProductionRuleAttribute.Associativity">
            <summary>
            Production rules can be left or right associative. Being associative
            reduces the number of permutations AboditNLP will examine and resolves
            ambiguity.
            e.g. a + b + c is interpreted as (a + b) + c when + is left associative
            </summary>
        </member>
        <member name="P:AboditNLP.Attributes.ProductionRuleAttribute.Priority">
            <summary>
            Priority over other rules, the higher the number the higher the precedence, e.g. + vs *
            </summary>
        </member>
        <member name="P:AboditNLP.Attributes.ProductionRuleAttribute.Probability">
            <summary>
            Probability of this rule being relevant vs all others at same point in parse
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.ProductionRuleAttribute.#ctor(AboditNLP.Attributes.Associativity,System.Int32,System.Double)">
            <summary>
            Create a new instance of the ProductionRule attribute
            </summary>
        </member>
        <member name="T:AboditNLP.Attributes.RequiredInterfaceAttribute">
            <summary>
            Indicates that specific additional interfaces are required, e.g. a specific verb tense
            </summary>
        </member>
        <member name="P:AboditNLP.Attributes.RequiredInterfaceAttribute.Interfaces">
            <summary>
            The interfaces required
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.RequiredInterfaceAttribute.#ctor(System.Type)">
            <summary>
            Create a new instance of the RequiredInterfaceAttribute class
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.RequiredInterfaceAttribute.#ctor(System.Type[])">
            <summary>
            Create a new instance of the RequiredInterfaceAttribute class
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.RequiredInterfaceAttribute.#ctor(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Create a new instance of the RequiredInterfaceAttribute class
            </summary>
        </member>
        <member name="T:AboditNLP.Attributes.RequiredTenseAttribute">
            <summary>
            Indicates that specific additional interfaces are required, e.g. a specific verb tense
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.RequiredTenseAttribute.#ctor(System.Type)">
            <summary>
            Create a new instance of the RequiredTenseAttribute class
            </summary>
        </member>
        <member name="T:AboditNLP.Attributes.InfinitiveAttribute">
            <summary>
            Indicates that the Verb must be an infinitive
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.InfinitiveAttribute.#ctor">
            <summary>
            Create a new instance of the InfinitiveAttribute class
            </summary>
        </member>
        <member name="T:AboditNLP.Attributes.PastTenseAttribute">
            <summary>
            Indicates that the Verb must be past tense
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.PastTenseAttribute.#ctor">
            <summary>
            Create a new instance of the PastTenseAttribute
            </summary>
        </member>
        <member name="T:AboditNLP.Attributes.PastPluralTenseAttribute">
            <summary>
            Indicates that the Verb must be past tense, plural, e.g. were
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.PastPluralTenseAttribute.#ctor">
            <summary>
            Create a new instance of the PastTenseAttribute
            </summary>
        </member>
        <member name="T:AboditNLP.Attributes.PresentParticipleTenseAttribute">
            <summary>
            Indicates that the Verb must be present participle tense (the -ing form)
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.PresentParticipleTenseAttribute.#ctor">
            <summary>
            Create a new instance of the <see cref="T:AboditNLP.Attributes.PresentParticipleTenseAttribute"/> 
            </summary>
        </member>
        <member name="T:AboditNLP.Attributes.PresentTenseAttribute">
            <summary>
            Indicates that the Verb must be present tense
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.PresentTenseAttribute.#ctor">
            <summary>
            Create a new instance of the PresentTenseAttribute
            </summary>
        </member>
        <member name="T:AboditNLP.Attributes.PresentSelfTenseAttribute">
            <summary>
            Indicates that the Verb must be present tense for 'self', i.e. "I"
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.PresentSelfTenseAttribute.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Attributes.PresentSelfTenseAttribute"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.Attributes.PresentThirdPersonTenseAttribute">
            <summary>
            Indicates that the Verb must be present tense for a third person, i.e. "he" or "she"
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.PresentThirdPersonTenseAttribute.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Attributes.PresentThirdPersonTenseAttribute"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.Attributes.PresentPluralTenseAttribute">
            <summary>
            Indicates that the Verb must be present tense for a third person plural, i.e. "they"
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.PresentPluralTenseAttribute.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Attributes.PresentPluralTenseAttribute"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.Attributes.FutureTenseAttribute">
            <summary>
            Indicates that the Verb must be future tense
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.FutureTenseAttribute.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Attributes.FutureTenseAttribute"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.Attributes.RequiredPluralizationAttribute">
            <summary>
            Indicates that the noun must be singular or plural
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.RequiredPluralizationAttribute.#ctor(System.Type)">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Attributes.RequiredPluralizationAttribute"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.Attributes.SingularAttribute">
            <summary>
            Indicates that the noun must be singular
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.SingularAttribute.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Attributes.SingularAttribute"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.Attributes.PluralAttribute">
            <summary>
            Indicates that the noun must be plural
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.PluralAttribute.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Attributes.PluralAttribute"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.Attributes.RequiredAdjectiveAttribute">
            <summary>
            Base class for attributes on adjectives
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.RequiredAdjectiveAttribute.#ctor(System.Type)">
            <summary>
            Creates a new instace of the <see cref="T:AboditNLP.Attributes.RequiredAdjectiveAttribute"/> class
            </summary>
            <param name="type"></param>
        </member>
        <member name="T:AboditNLP.Attributes.NormalFormAttribute">
            <summary>
            Indicates that the normal form of the adjective is required
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.NormalFormAttribute.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Attributes.NormalFormAttribute"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.Attributes.SuperlativeAttribute">
            <summary>
            Indicates that the superlative form of the adjective is required
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.SuperlativeAttribute.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Attributes.SuperlativeAttribute"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.Attributes.ComparativeAttribute">
            <summary>
            Indicates that the comparative form of an adjective is required
            </summary>
        </member>
        <member name="M:AboditNLP.Attributes.ComparativeAttribute.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Attributes.ComparativeAttribute"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.Builder.AboditT4">
            <summary>
            A class to process a single input file (.TTL) and output .CS files
            containing the interfaces and other pieces needed for AboditNLP.
            </summary>
        </member>
        <member name="M:AboditNLP.Builder.AboditT4.#ctor(System.String)">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Builder.AboditT4"/> class
            </summary>
        </member>
        <member name="M:AboditNLP.Builder.AboditT4.#ctor(System.String,System.Action{System.String})">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Builder.AboditT4"/> class
            </summary>
        </member>
        <member name="M:AboditNLP.Builder.AboditT4.Process(System.String)">
            <summary>
            Process one input file
            </summary>
        </member>
        <member name="M:AboditNLP.Builder.AboditT4.ProcessCsvFile(System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Process a CSV file as a specific type of entity
            </summary>
        </member>
        <member name="M:AboditNLP.Builder.AboditT4.Write(System.String)">
            <summary>
            Write the output to the given path
            </summary>
        </member>
        <member name="M:AboditNLP.Builder.AboditT4.SafeUrlSlug(System.String)">
            <summary>
            A safe URL slug for generating URLs
            </summary>
        </member>
        <member name="M:AboditNLP.Builder.AboditT4.Limit(System.String,System.Int32)">
            <summary>
            Substring but OK if shorter
            </summary>
        </member>
        <member name="T:AboditNLP.Builder.FileLineReader">
            <summary>
            Read lines from a file
            </summary>
        </member>
        <member name="P:AboditNLP.Builder.FileLineReader.Name">
            <summary>
            The Name is the local file path
            </summary>
        </member>
        <member name="F:AboditNLP.Builder.FileLineReader.localFilePath">
            <summary>
            The local file path
            </summary>
        </member>
        <member name="M:AboditNLP.Builder.FileLineReader.#ctor(System.String)">
            <summary>
            Create a new instance of the FileLineReader class
            </summary>
        </member>
        <member name="M:AboditNLP.Builder.FileLineReader.GetLines">
            <summary>
            Get lines from the file
            </summary>
            <returns></returns>
        </member>
        <member name="M:AboditNLP.Builder.FileLineReader.ReadLinesFromFile">
            <summary>
            Read all lines from a file
            </summary>
        </member>
        <member name="M:AboditNLP.Builder.FileLineReader.ReadLinesFromFile(System.String,System.Int32)">
            <summary>
            Read all lines from a file using a regular expression to break up each line
            </summary>
        </member>
        <member name="T:AboditNLP.Builder.FileLineReaderFromResource">
            <summary>
            Read lines from an embedded resource
            </summary>
        </member>
        <member name="M:AboditNLP.Builder.FileLineReaderFromResource.#ctor(System.String)">
            <summary>
            Create a new instance of the file line reader for reading from a resource
            </summary>
        </member>
        <member name="M:AboditNLP.Builder.FileLineReaderFromResource.GetLines">
            <summary>
            Get lines from the source
            </summary>
        </member>
        <member name="T:AboditNLP.Builder.PlainTextReader">
            <summary>
            A plain text reader
            </summary>
        </member>
        <member name="M:AboditNLP.Builder.PlainTextReader.#ctor(System.String)">
            <summary>
            Create a new instance of the plain text reader
            </summary>
        </member>
        <member name="M:AboditNLP.Builder.PlainTextReader.GetLines">
            <summary>
            Get lines from the file
            </summary>
        </member>
        <member name="T:AboditNLP.Builder.WebBackedReader">
            <summary>
            The WebBackedReader reads from a URL or local cached copy
            </summary>
        </member>
        <member name="M:AboditNLP.Builder.WebBackedReader.#ctor(System.String,System.String,System.String)">
            <summary>
            Create a new instance of the WebBackedReader class
            </summary>
        </member>
        <member name="M:AboditNLP.Builder.WebBackedReader.GetLines">
            <summary>
            Get a file from a Uri if it's not present on disk - used to fetch large DBPedia files etc.
            </summary>
        </member>
        <member name="T:AboditNLP.Builder.SynsetForBuilder">
            <summary>
            Temporary representation of a synset that will later be rendered to generated code
            </summary>
        </member>
        <member name="P:AboditNLP.Builder.SynsetForBuilder.InterfaceName">
            <summary>
            e.g. mammal1
            </summary>
        </member>
        <member name="P:AboditNLP.Builder.SynsetForBuilder.InterfaceNameQualifiedIfNecessary">
            <summary>
            e.g. mammal1 or yournamespace.Noun.mammal1
            </summary>
        </member>
        <member name="P:AboditNLP.Builder.SynsetForBuilder.InterfaceNameForClass">
            <summary>
            e.g. Mammal1
            </summary>
        </member>
        <member name="P:AboditNLP.Builder.SynsetForBuilder.BelongsInCore">
            <summary>
            This Synset is not a common meaning in the English language
            Such words will be put in the Extensions DLL not the main DLL
            </summary>
        </member>
        <member name="P:AboditNLP.Builder.SynsetForBuilder.HasDescendants">
            <summary>
            If a Synset has descendants it can act both as the class (e.g. Mammal1) and the instance (mammal1)
            </summary>
        </member>
        <member name="M:AboditNLP.Builder.SynsetForBuilder.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:AboditNLP.Builder.VerbConjugation">
            <summary>
            The various forms of a verb
            </summary>
        </member>
        <member name="M:AboditNLP.Builder.WordnetWriter.AddVerbForms(System.IO.StreamWriter,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{System.String[]}},AboditNLP.Builder.SynsetForBuilder)">
            <summary>
            Add verb forms - past, genrund, infinitive, ...
            </summary>
        </member>
        <member name="T:AboditNLP.MemoryOfGoldfish">
            <summary>
            A null memory that remembers nothing.  Used as a throw-away memory for testing.
            </summary>
        </member>
        <member name="M:AboditNLP.MemoryOfGoldfish.Remember(System.Object)">
            <summary>
            Remember something
            </summary>
        </member>
        <member name="M:AboditNLP.MemoryOfGoldfish.GetLast``1">
            <summary>
            Get the last instance of a remembered item of type T
            </summary>
        </member>
        <member name="M:AboditNLP.MemoryOfGoldfish.GetRecent``1">
            <summary>
            Get recent instances of a remembered item of type T
            </summary>
        </member>
        <member name="M:AboditNLP.MemoryOfGoldfish.Forget(AboditNLP.RememberedThing)">
            <summary>
            Forget a remembered thing
            </summary>
        </member>
        <member name="T:AboditNLP.Collector">
            <summary>
            A simple string collector for a synch version of IListener
            </summary>
        </member>
        <member name="M:AboditNLP.Collector.#ctor(AboditNLP.IRememberState)">
            <summary>
            Create a new instance of the simple string Collector
            </summary>
        </member>
        <member name="P:AboditNLP.Collector.Result">
            <summary>
            Get the remembered result
            </summary>
        </member>
        <member name="M:AboditNLP.Collector.Say(System.String)">
            <summary>
            Add a line to the collected result
            </summary>
        </member>
        <member name="M:AboditNLP.Collector.Remember(System.Object)">
            <summary>
            Remember something
            </summary>
        </member>
        <member name="M:AboditNLP.Collector.Forget(AboditNLP.RememberedThing)">
            <summary>
            Forget something
            </summary>
        </member>
        <member name="M:AboditNLP.Collector.GetRecent``1">
            <summary>
            Get recent remembered things of type T
            </summary>
        </member>
        <member name="M:AboditNLP.Collector.GetLast``1">
            <summary>
            Get the last remembered thing of type T
            </summary>
        </member>
        <member name="T:AboditNLP.ConsoleCollector">
            <summary>
            Simple console Collector - copies all output to the Console.  Useful for testing.
            </summary>
        </member>
        <member name="M:AboditNLP.ConsoleCollector.#ctor(AboditNLP.IRememberState)">
            <summary>
            Create a new instance of the ConsoleCollector (used for testing)
            </summary>
        </member>
        <member name="M:AboditNLP.ConsoleCollector.Say(System.String)">
            <summary>
            Add a line to the collector
            </summary>
        </member>
        <member name="M:AboditNLP.ConsoleCollector.Remember(System.Object)">
            <summary>
            Remember an object
            </summary>
            <param name="thing"></param>
        </member>
        <member name="M:AboditNLP.ConsoleCollector.Forget(AboditNLP.RememberedThing)">
            <summary>
            Foret an object
            </summary>
            <param name="thing"></param>
        </member>
        <member name="M:AboditNLP.ConsoleCollector.GetRecent``1">
            <summary>
            Get recent objects
            </summary>
        </member>
        <member name="M:AboditNLP.ConsoleCollector.GetLast``1">
            <summary>
            Get the last remembered object of a given type
            </summary>
        </member>
        <member name="T:AboditNLP.IListener">
            <summary>
            Something we can talk to that remembers state too
            </summary>
        </member>
        <member name="T:AboditNLP.ILogger">
            <summary>
            A logger for AboditNLP
            </summary>
            <remarks>
            Implement this, typically by calling straight through to Log4Net or
            some other logging framework. By providing an interface Abodit NLP has
            no dependency on any specific logging framework.
            </remarks>
        </member>
        <member name="M:AboditNLP.ILogger.Trace(System.String)">
            <summary>
            Log a message at Trace level
            </summary>
        </member>
        <member name="M:AboditNLP.ILogger.Debug(System.String)">
            <summary>
            Log a message at Debug level
            </summary>
        </member>
        <member name="M:AboditNLP.ILogger.Info(System.String)">
            <summary>
            Log a message at Informational level
            </summary>
        </member>
        <member name="M:AboditNLP.ILogger.Warn(System.String)">
            <summary>
            Log a message at Warning level
            </summary>
        </member>
        <member name="M:AboditNLP.ILogger.Error(System.String,System.Exception)">
            <summary>
            Log a message at Warning level
            </summary>
        </member>
        <member name="M:AboditNLP.ILogger.Fatal(System.String)">
            <summary>
            Log a message at Fatal level
            </summary>
        </member>
        <member name="T:AboditNLP.ConsoleLoger">
            <summary>
            A simple logger that logs to the console
            </summary>
        </member>
        <member name="M:AboditNLP.ConsoleLoger.Trace(System.String)">
            <summary>
            Log at trace severity
            </summary>
        </member>
        <member name="M:AboditNLP.ConsoleLoger.Debug(System.String)">
            <summary>
            Log at debug severity
            </summary>
        </member>
        <member name="M:AboditNLP.ConsoleLoger.Info(System.String)">
            <summary>
            Log at info severity
            </summary>
        </member>
        <member name="M:AboditNLP.ConsoleLoger.Warn(System.String)">
            <summary>
            Log at warn severity
            </summary>
        </member>
        <member name="M:AboditNLP.ConsoleLoger.Error(System.String,System.Exception)">
            <summary>
            Log at error severity
            </summary>
        </member>
        <member name="M:AboditNLP.ConsoleLoger.Fatal(System.String)">
            <summary>
            Log at fatal severity
            </summary>
        </member>
        <member name="T:AboditNLP.IRememberState">
            <summary>
            An object implementing this interface handles state information
            </summary>
        </member>
        <member name="M:AboditNLP.IRememberState.Remember(System.Object)">
            <summary>
            Remember something ... with your conversation state
            </summary>
        </member>
        <member name="M:AboditNLP.IRememberState.GetRecent``1">
            <summary>
            Get recent remembered objects
            </summary>
        </member>
        <member name="M:AboditNLP.IRememberState.GetLast``1">
            <summary>
            Get a remembered object
            </summary>
        </member>
        <member name="M:AboditNLP.IRememberState.Forget(AboditNLP.RememberedThing)">
            <summary>
            Forgets a remembered object
            </summary>
        </member>
        <member name="T:AboditNLP.ISendInput">
            <summary>
            An object implementing this interface is interested in an ongoing conversation from 
            some other object
            </summary>
        </member>
        <member name="M:AboditNLP.ISendInput.Say(System.String)">
            <summary>
            Add a line to the conversation
            </summary>
        </member>
        <member name="T:AboditNLP.NullCollector">
            <summary>
            Null collector - logs any messages sent to it but otherwise does very little. 
            </summary>
            <remarks>
            Used for testing.
            </remarks>
        </member>
        <member name="M:AboditNLP.NullCollector.Say(System.String)">
            <summary>
            Say the input on the collector
            </summary>
        </member>
        <member name="M:AboditNLP.NullCollector.Remember(System.Object)">
            <summary>
            Remember a thing
            </summary>
        </member>
        <member name="M:AboditNLP.NullCollector.Forget(AboditNLP.RememberedThing)">
            <summary>
            Forget a thing
            </summary>
        </member>
        <member name="M:AboditNLP.NullCollector.GetLast``1">
            <summary>
            Get the last remembered thing of a given type
            </summary>
        </member>
        <member name="M:AboditNLP.NullCollector.GetRecent``1">
            <summary>
            Get recent remembered things of a given type
            </summary>
        </member>
        <member name="T:AboditNLP.RememberedHistory">
            <summary>
            Implements a history list for remembered objects - a FIFO queue with some smart clean up rules
            </summary>
        </member>
        <member name="F:AboditNLP.RememberedHistory.rememberedThings">
            <summary>
            Things we have spoken about recently
            </summary>
        </member>
        <member name="M:AboditNLP.RememberedHistory.Remember(System.Object,System.TimeSpan)">
            <summary>
            Remember an object for a specific period of time
            </summary>
        </member>
        <member name="M:AboditNLP.RememberedHistory.Remember(System.Object)">
            <summary>
            Remember for the default period
            </summary>
        </member>
        <member name="M:AboditNLP.RememberedHistory.Forget(AboditNLP.RememberedThing)">
            <summary>
            Forget something (e.g. a question that's been answered)
            </summary>
        </member>
        <member name="M:AboditNLP.RememberedHistory.GetLast``1">
            <summary>
            Get the last reference to an object of type T, e.g. the last Building Area, ...
            </summary>
        </member>
        <member name="M:AboditNLP.RememberedHistory.GetInOrderInternal``1">
            <summary>
            Get the elements as Type, in reverse order, USE ONLY IN THIS CLASS!
            </summary>
            <returns></returns>
        </member>
        <member name="M:AboditNLP.RememberedHistory.GetRecent``1">
            <summary>
            Get the last reference to an object of type T, e.g. the last Building Area, ...
            </summary>
        </member>
        <member name="M:AboditNLP.RememberedHistory.GetEnumerator">
            <summary>
            Get the enumerator for RememberedThings
            </summary>
        </member>
        <member name="T:AboditNLP.RememberedObject`1">
            <summary>
            A strongly typed remembered thing
            </summary>
        </member>
        <member name="P:AboditNLP.RememberedObject`1.Thing">
            <summary>
            Get the Thing that was remembered
            </summary>
        </member>
        <member name="M:AboditNLP.RememberedObject`1.op_Implicit(AboditNLP.RememberedObject{`0})~`0">
            <summary>
            You can treat a remembered object as an object of that type without having to pick of the .Thing property
            </summary>
        </member>
        <member name="T:AboditNLP.RememberedThing">
            <summary>
            Remembered something
            </summary>
        </member>
        <member name="F:AboditNLP.RememberedThing.thing">
            <summary>
            The remembered thing
            </summary>
        </member>
        <member name="P:AboditNLP.RememberedThing.Thing">
            <summary>
            Get the Thing that was remembered
            </summary>
        </member>
        <member name="M:AboditNLP.RememberedThing.Is``1">
            <summary>
            Is the remembered thing a T?
            </summary>
        </member>
        <member name="M:AboditNLP.RememberedThing.As``1">
            <summary>
            This can cast an object that's been remembered so you can get a less derived version of it
            In .NET 4.0 this might go away with covariance and contravariance
            </summary>
        </member>
        <member name="P:AboditNLP.RememberedThing.DateTimeWeDiscussedIt">
            <summary>
            The date time it was remembered
            </summary>
        </member>
        <member name="M:AboditNLP.RememberedThing.WasDiscussedInTheLastSeconds(System.Int32)">
            <summary>
            Did we discuss this in the last n seconds?
            </summary>
        </member>
        <member name="M:AboditNLP.RememberedThing.WasDiscussedInTheLastMinutes(System.Int32)">
            <summary>
            Did we discuss this in the last n minutes?
            </summary>
        </member>
        <member name="M:AboditNLP.RememberedThing.#ctor(System.DateTime,System.Object,System.TimeSpan)">
            <summary>
            A remembered object
            </summary>
        </member>
        <member name="P:AboditNLP.RememberedThing.Expired">
            <summary>
            Whether the thing has expired
            </summary>
        </member>
        <member name="M:AboditNLP.RememberedThing.ToString">
            <summary>
            Gets a string representation of this object
            </summary>
            <returns></returns>
        </member>
        <member name="T:AboditNLP.ILexemeStore">
            <summary>
            A Lexeme store stores words in an efficient data structure and maps them
            to meanings (interfaces) or actual objects (metaentities, fields, sort orders, ...)
            </summary>
        </member>
        <member name="M:AboditNLP.ILexemeStore.Store(AboditNLP.IWordBuilderComplete)">
            <summary>
            Store a set of words representing a single meaning from a WordBuilder
            </summary>
        </member>
        <member name="M:AboditNLP.ILexemeStore.Store(System.Collections.Generic.IEnumerable{AboditNLP.Lexeme})">
            <summary>
            Store a sequence of Lexemes in the ternary tree
            </summary>
        </member>
        <member name="M:AboditNLP.ILexemeStore.Store(AboditNLP.Lexeme)">
            <summary>
            Store a single Lexeme in the ternary tree
            </summary>
        </member>
        <member name="M:AboditNLP.ILexemeStore.Retrieve(System.String)">
            <summary>
            Retrieve all Lexemes found at the start of the input string, longest first
            </summary>
        </member>
        <member name="M:AboditNLP.ILexemeStore.AutoComplete(System.String)">
            <summary>
            Provides possible matches that are at or beyond the input text (may include obscene words)
            </summary>
        </member>
        <member name="M:AboditNLP.ILexemeStore.FuzzyMatch(System.String,Abodit.Sensitivity)">
            <summary>
            Retrieve all possible substrings of the input that are close spellings
            </summary>
        </member>
        <member name="P:AboditNLP.ILexemeStore.TernaryTreeList">
            <summary>
            The ternary tree used internally (don't use this)
            </summary>
        </member>
        <member name="P:AboditNLP.ILexemeStore.Count">
            <summary>
            Count of how many Lexemes have been stored
            </summary>
        </member>
        <member name="M:AboditNLP.ILexemeStore.AddMetaModel(Abodit.Meta.IMetaModel)">
            <summary>
            Add a meta model to the store containing metadata about entities, fields and more
            </summary>
        </member>
        <member name="M:AboditNLP.ILexemeStore.AddMetaEntity(Abodit.Meta.IMetaEntity)">
            <summary>
            Add a MetaEntity and all of its fields to the LexemeStore
            </summary>
            <param name="entity"></param>
        </member>
        <member name="M:AboditNLP.ILexemeStore.AddLiveObject(AboditNLP.SynSet,System.Object)">
            <summary>
            Add an object to the tokens that can be returned
            </summary>
            <remarks>
            Allows an arbitrary .NET object to be returned from the internal tree of words
            in response to a given synset
            </remarks>
        </member>
        <member name="M:AboditNLP.ILexemeStore.RemoveLiveObject(System.Object)">
            <summary>
            Remove an object from the tokens that can be returned
            </summary>
        </member>
        <member name="M:AboditNLP.ILexemeStore.GetLiveObject(AboditNLP.SynSet)">
            <summary>
            Get a live object by Synset (used internally)
            </summary>
        </member>
        <member name="T:AboditNLP.LexemeStore">
            <summary>
            LexemeStore stores lexemes in an efficient tree structure for fast exact and approximate retrieval
            </summary>
        </member>
        <member name="P:AboditNLP.LexemeStore.TernaryTreeList">
            <summary>
            Access the underlying tree used in this LexemeStore
            </summary>
        </member>
        <member name="P:AboditNLP.LexemeStore.Count">
            <summary>
            Count of how many Lexemes are in the store
            </summary>
        </member>
        <member name="M:AboditNLP.LexemeStore.Store(AboditNLP.IWordBuilderComplete)">
            <summary>
            Store a single Word builder
            </summary>
        </member>
        <member name="M:AboditNLP.LexemeStore.Store(System.Collections.Generic.IEnumerable{AboditNLP.Lexeme})">
            <summary>
            Store an enumeration of Lexemes
            </summary>
        </member>
        <member name="M:AboditNLP.LexemeStore.Store(AboditNLP.Lexeme)">
            <summary>
            Store a single token
            </summary>
        </member>
        <member name="M:AboditNLP.LexemeStore.Retrieve(System.String)">
            <summary>
            Retrieve all Lexemes found at the start of the input string, longest first
            </summary>
        </member>
        <member name="M:AboditNLP.LexemeStore.AutoComplete(System.String)">
            <summary>
            Retrieve all possible completions of a given string that lead to Lexemes
            </summary>
        </member>
        <member name="M:AboditNLP.LexemeStore.FuzzyMatch(System.String,Abodit.Sensitivity)">
            <summary>
            Retrieve all possible substrings of the input that are close spellings
            </summary>
        </member>
        <member name="M:AboditNLP.LexemeStore.AddMetaModel(Abodit.Meta.IMetaModel)">
            <summary>
            Add a meta model to the lexeme store
            (A meta model is a model that describes entities, fields and relationships)
            </summary>
            <param name="metaModel"></param>
        </member>
        <member name="M:AboditNLP.LexemeStore.AddMetaEntity(Abodit.Meta.IMetaEntity)">
            <summary>
            Add a MetaEntity and all of its fields to the LexemeStore.
            </summary>
            <remarks>
            VariableAccesses are converted to FieldAccesses with respect to the MetaEntity
            </remarks>
            <param name="entity"></param>
        </member>
        <member name="M:AboditNLP.LexemeStore.AddMetaWords(Abodit.Meta.IMeta,System.Object)">
            <summary>
            Add all of the variants of a meta and each of their synonyms (aliases) into the LexemeStore
            </summary>
        </member>
        <member name="F:AboditNLP.LexemeStore.objectMap">
            <summary>
            Object map allows any Synset to have multiple real, live objects connected to it
            when that synset is parsed, those objects are returned as possible parse tokens
            </summary>
        </member>
        <member name="M:AboditNLP.LexemeStore.AddLiveObject(AboditNLP.SynSet,System.Object)">
            <summary>
            Adds an object to a given synset
            </summary>
            <remarks>
            During matching this object will be returned as a possible parse for synset
            </remarks>
            <param name="synset">The synset to match</param>
            <param name="obj">The object to return from the parse</param>
        </member>
        <member name="M:AboditNLP.LexemeStore.RemoveLiveObject(System.Object)">
            <summary>
            Removes a 'live' object from the store, <see cref="M:AboditNLP.LexemeStore.AddLiveObject(AboditNLP.SynSet,System.Object)"/>
            </summary>
            <param name="obj">The object to return from the parse</param>
        </member>
        <member name="M:AboditNLP.LexemeStore.GetLiveObject(AboditNLP.SynSet)">
            <summary>
            Get a live object matching a synset
            </summary>
        </member>
        <member name="T:AboditNLP.Database.TernaryTreeForLexemes">
            <summary>
            A ternary tree with lists of Lexemes as the leaves
            </summary>
        </member>
        <member name="P:AboditNLP.Database.TernaryTreeForLexemes.Count">
            <summary>
            Count how many Lexemes are in the tree
            </summary>
        </member>
        <member name="M:AboditNLP.Database.TernaryTreeForLexemes.AddToTree(System.String,AboditNLP.Lexeme)">
            <summary>
            Add a Lexeme to the tree
            </summary>
        </member>
        <member name="T:AboditNLP.TokenLexemeFactory">
            <summary>
            TokenLexemeFactory is an in-memory token store for frequently used words where 
            we want a super-quick lookup.
            </summary>
            <remarks>
            This token factory relies on the injected LexemeStore.
            You can add values to that at runtime.
            Values can also be attached to any meaning (synset) in the LexemeStore
            </remarks>
        </member>
        <member name="M:AboditNLP.TokenLexemeFactory.#ctor(AboditNLP.ILexemeStore)">
            <summary>
            Create a new instance of the TokenLexemeFactory
            </summary>
        </member>
        <member name="M:AboditNLP.TokenLexemeFactory.Parse(AboditNLP.NLPOptions,System.Int32,System.String,AboditNLP.AllowedToken[])">
            <summary>
            Parse the input to get tokens
            </summary>
        </member>
        <member name="T:AboditNLP.Noun.chart1">
            <summary>
            A graphical representation of data
            </summary>
        </member>
        <member name="T:AboditNLP.Noun.Chart1">
            <summary>
             The class of all chart1
             A graphical representation of data
            </summary>
        </member>
        <member name="T:AboditNLP.Noun.graph1">
            <summary>
            graph-noun-1
            </summary>
        </member>
        <member name="T:AboditNLP.Noun.histogram1">
            <summary>
            A graphical representation of data as bars
            </summary>
        </member>
        <member name="T:AboditNLP.Noun.metadata1">
            <summary>
            Data about other data, e.g. a database schema is metadata about a database
            </summary>
        </member>
        <member name="T:AboditNLP.Noun.metamodel1">
            <summary>
            Data describing a data model, e.g. the contents and types for each column in a table
            </summary>
        </member>
        <member name="T:AboditNLP.Noun.meta1">
            <summary>
            A prefix meaning at a higher level or abstraction
            </summary>
        </member>
        <member name="T:AboditNLP.Noun.pie_chart1">
            <summary>
            A graphical representation of data in slices
            </summary>
        </member>
        <member name="T:AboditNLP.Noun.mile">
            <summary>
            
            </summary>
        </member>
        <member name="T:AboditNLP.Noun.yard">
            <summary>
            yard-noun-1: a unit of length equal to 3 feet; defined as 91.44 centimeters; originally taken to be the average length of a stride
            </summary>
        </member>
        <member name="T:AboditNLP.Noun.foot2">
            <summary>
            foot-noun-2 a linear unit of length equal to 12 inches or a third of a yard; "he is six feet tall"
            </summary>
        </member>
        <member name="T:AboditNLP.Noun.inch">
            <summary>
            inch-noun-1 a unit of length equal to one twelfth of a foot
            </summary>
        </member>
        <member name="T:AboditNLP.Noun.cubicyard">
            <summary>
            cubic_yard-noun-1 a unit of volume (as for sand or gravel)
            </summary>
        </member>
        <member name="T:AboditNLP.Noun.order">
            <summary>
            Noun order or ordering
            </summary>
        </member>
        <member name="T:AboditNLP.Noun.Type.Pronoun">
            <summary>
            A Pronoun is a word that replaces a person, place, thing, or idea. Pronouns can act as subjects or objects, and some can show possession.
            </summary>
        </member>
        <member name="T:AboditNLP.Noun.Type.SingleInstance">
            <summary>
            Countable but there is only one
            </summary>
        </member>
        <member name="T:AboditNLP.Noun.Type.Concrete">
            <summary>
             If you can see, hear, smell, taste, or feel the item, it's a concrete noun.
            </summary>
        </member>
        <member name="T:AboditNLP.Noun.Type.Abstract">
            <summary>
            Abstract nouns on the other hand refer to abstract objects such as ideas or concepts, like the nouns "politeness" or "hatefulness".
            </summary>
        </member>
        <member name="T:AboditNLP.Noun.Type.CardinalTerminator">
            <summary>
            A cardinal that occurs in last position (cannot be followed by another fragment of a cardinal)
            </summary>
        </member>
        <member name="T:AboditNLP.Noun.Type.CardinalDecade">
            <summary>
            A decade, e.g. 100, 1000, 100000, ...
            </summary>
        </member>
        <member name="T:AboditNLP.Noun.Type.RationalPlural">
            <summary>
            e.g. sixths
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.abaft2">
            <summary>
            nearer the stern than; behind
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.aboard2">
            <summary>
            on or into a vehicle
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.aboard3">
            <summary>
            on or into a vehicle
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.aboutOrAround1">
            <summary>
            about, around, circa, approximately, roughly, close to a time
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.aboutOrAround2">
            <summary>
            about, around, roughly, approximately in space...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.above2">
            <summary>
            having a higher position
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.across2">
            <summary>
            from one side to the other side of (something)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.afore3">
            <summary>
            afore...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.after1">
            <summary>
            later than something, e.g. &quot;ten past six&quot; (after, past, since or subsequent to)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.after2">
            <summary>
            on or to the other side of somebody/something (after, past)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.against2">
            <summary>
            in opposition to (someone or something)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.agent4">
            <summary>
            Prepositions that express a causal relationship between the noun and an action, e.g. &quot;by, with&quot;, etc.
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.ahead1">
            <summary>
            ahead in time
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.ahead2">
            <summary>
            in, at, or to a place before (someone or something)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.ahead3">
            <summary>
            ahead...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.along2">
            <summary>
            distributed horizontally
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.among2">
            <summary>
            among, amongst, amid, amidst, ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.anti2">
            <summary>
            anti or against (position)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.apartFrom2">
            <summary>
            set at a distance away from a person, place or thing
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.aproposOf7">
            <summary>
            apropos of...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.apropos7">
            <summary>
            apropos...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.asFor7">
            <summary>
            as for...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.asideFrom2">
            <summary>
            aside from...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.aside2">
            <summary>
            aside...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.asOf1">
            <summary>
            e.g. as of 9pm tonight
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.asPer7">
            <summary>
            as per...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.as1">
            <summary>
            as ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.asRegards7">
            <summary>
            as regards...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.astride2">
            <summary>
            astride...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.athwart7">
            <summary>
            athwart...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.at1">
            <summary>
            indicating the point in time at which a particular event, process, or activity happens, e.g. &quot;meet me at 10AM&quot;
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.at2">
            <summary>
            at (positional)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.away3">
            <summary>
            in the opposite direction from another object
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.back2">
            <summary>
            back...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.barring7">
            <summary>
            barring...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.becauseOf6">
            <summary>
            because of...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.before1">
            <summary>
            before in time...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.before2">
            <summary>
            preceding (something or someone) in order or in a series
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.behind1">
            <summary>
            behind in time
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.behind2">
            <summary>
            in or to a place at the back of or to the rear of (someone or something)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.behind3">
            <summary>
            behind or following (directional)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.behither1">
            <summary>
            behither...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.below2">
            <summary>
            in or to a lower place
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.beside2">
            <summary>
            beside...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.besides2">
            <summary>
            besides...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.between1">
            <summary>
            between...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.between2">
            <summary>
            with someone/something on each side or end
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.betwixt2">
            <summary>
            betwixt...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.beyond1">
            <summary>
            happening or continuing after
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.beyond3">
            <summary>
            in a further direction
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.beyond31">
            <summary>
            having progressed or achieved more than (a specified stage or level)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.but7">
            <summary>
            except; apart from; other than
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.byMeansOf4">
            <summary>
            with the help or agency of
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.by4">
            <summary>
            identifying the agent performing an action, e.g. by him
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.by5">
            <summary>
            by (instrument), e.g. by bus
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.chez7">
            <summary>
            at the home of (used in imitation of French, usually humorously)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.concerning7">
            <summary>
            concerning ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.connection7">
            <summary>
            A preposition expressing a connection, e.g. &quot;of, to, with&quot;
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.despite1">
            <summary>
            despite ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.despite4">
            <summary>
            despite-preposition-4
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.directional3">
            <summary>
            A directional preposition relates to direction
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.down3">
            <summary>
            in an downward direction
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.dueTo1">
            <summary>
            due to ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.dueTo4">
            <summary>
            due-to-preposition-4
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.during1">
            <summary>
            during (temporal)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.exceptFor7">
            <summary>
            except for ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.except7">
            <summary>
            except ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.excluding7">
            <summary>
            excluding ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.failing6">
            <summary>
            failing ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.farFrom2">
            <summary>
            far from ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.fornenst1">
            <summary>
            fornenst ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.fornent1">
            <summary>
            fornent ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.for1">
            <summary>
            expressing a duration, e.g. for a period of time
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.for2">
            <summary>
            expressing a distance, e.g. &quot;for 5 miles&quot;
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.for6">
            <summary>
            expressing a reason, e.g. &quot;he did it for the right reason&quot;
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.from1">
            <summary>
            indicating the point in time at which a particular event, process, or activity starts, e.g. &quot;from 10AM to noon&quot;
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.from2">
            <summary>
            indicating the point in space at which an action or motion starts, e.g. &quot;she flew from London&quot;
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.from8">
            <summary>
            indicating the source or provenance of someone or something, e.g. &quot;bananas from Indonesia&quot;
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.given1">
            <summary>
            given ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.horizontalDirectional2">
            <summary>
            a directional preposition referring to the horizontal dimension
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.horizontalDirectional3">
            <summary>
            horizontal-directional-preposition-3
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.horizontalPositional2">
            <summary>
            horizontal-positional-preposition-2
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.horizontalPosition2">
            <summary>
            a positional preposition referring to the horizontal dimension
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.inAccordanceWith1">
            <summary>
            in accordance with ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.inCaseOf1">
            <summary>
            in case of ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.including7">
            <summary>
            including, as well as, in addition to,...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.inFront2">
            <summary>
            in-front-preposition-2
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.inLieuOf6">
            <summary>
            in lieu of ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.inOrDuringOrAt1">
            <summary>
            In or during or at
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.inOrDuring1">
            <summary>
            In or during
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.inOrOf1">
            <summary>
            in or of
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.inOrOnOrAt1">
            <summary>
            in or on or at (temporal)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.inOrOnOrAt2">
            <summary>
            in or on or at (positional)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.inOrOnOrDuring1">
            <summary>
            In or on or during
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.inOrOn2">
            <summary>
            in or on
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.inPlaceOf6">
            <summary>
            in place of ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.inPointOf6">
            <summary>
            in point of ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.in1">
            <summary>
            in (temporal)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.in2">
            <summary>
            in (positional)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.in3">
            <summary>
            in an inward direction
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.inside2">
            <summary>
            inside, within (positional)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.inSpiteOf6">
            <summary>
            in spite of ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.insteadOf6">
            <summary>
            instead of ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.instrument5">
            <summary>
            A preposition for an instrument, device or machine, e.g. &quot;on, by, with the help of&quot;
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.leftOf2">
            <summary>
            left of...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.like1">
            <summary>
            like ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.mid1">
            <summary>
            mid ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.mid2">
            <summary>
            mid ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.midst1">
            <summary>
            midst ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.minus1">
            <summary>
            minus ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.near2">
            <summary>
            near in place; &quot;stood near the door&quot;
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.next1">
            <summary>
            next (in time)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.next2">
            <summary>
            next...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.notwithstanding6">
            <summary>
            notwithstanding ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.off1">
            <summary>
            e.g. off month (temporal preposition)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.off2">
            <summary>
            off ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.off3">
            <summary>
            e.g. off site
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.of1">
            <summary>
            of (temporal)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.of8">
            <summary>
            of (origin)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.onAccountOf4">
            <summary>
            on account of ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.onBehalfOf4">
            <summary>
            on behalf of ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.on1">
            <summary>
            on (temporal)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.on2">
            <summary>
            on, upon, ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.onto3">
            <summary>
            in the direction of moving onto another object
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.opposite2">
            <summary>
            opposite...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.origin8">
            <summary>
            A preposition expressing an origin, e.g. &quot;from, of&quot;
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.out3">
            <summary>
            in a direction leaving a place or object
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.outside2">
            <summary>
            outside (positional)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.outWith1">
            <summary>
            out with ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.over2">
            <summary>
            at a higher level than; &quot;a floor above mine&quot;
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.owingTo6">
            <summary>
            owing to ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.pace6">
            <summary>
            used before a person&apos;s name to express polite disagreement with what they have said
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.per1">
            <summary>
            per ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.plus1">
            <summary>
            plus ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.positional2">
            <summary>
            A positional preposition relates to place
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.previous1">
            <summary>
            previous (in time)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.pro1">
            <summary>
            pro ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.pursuantTo6">
            <summary>
            pursuant to ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.qua1">
            <summary>
            qua ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.reason6">
            <summary>
            A preposition for a reason, e.g. &quot;for, through, because of, on account of, from&quot;
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.regarding7">
            <summary>
            regarding ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.regardlessOf7">
            <summary>
            regardless of ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.rightOf2">
            <summary>
            right of...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.round1">
            <summary>
            round ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.round3">
            <summary>
            round (opposite of through)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.temporal1">
            <summary>
            A temporal preposition relates to time
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.thanksTo6">
            <summary>
            thanks to ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.than1">
            <summary>
            than ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.than7">
            <summary>
            Introducing the second element in a comparison. e.g. &apos;he was much smaller than his son&apos;
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.thatOf1">
            <summary>
            that of ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.throughout2">
            <summary>
            expressing a spatial distribution, e.g. &quot;throughout the land&quot;
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.through1">
            <summary>
            through, thru, throughout
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.through3">
            <summary>
            through, thru
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.through6">
            <summary>
            through, expressing a reason, e.g. &quot;he went there through a sense of guilt&quot;
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.times1">
            <summary>
            times ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.to1">
            <summary>
            indicating the point in time at which a particular event, process, or activity ends, e.g. &quot;from 8AM to 10AM&quot;
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.to2">
            <summary>
            indicating the point in space at which an action or motion ends
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.toward3">
            <summary>
            in the direction of another object
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.under2">
            <summary>
            at a lower level, rank or grade than; &quot;below cost; below freezing&quot;
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.unlike1">
            <summary>
            unlike ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.until1">
            <summary>
            until (temporal)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.unto1">
            <summary>
            unto ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.up3">
            <summary>
            in an upward direction
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.verticalDirectional2">
            <summary>
            a directional preposition referring to the vertical dimension
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.verticalDirectional3">
            <summary>
            vertical-directional-preposition-3
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.verticalPositional2">
            <summary>
            vertical-positional-preposition-2
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.verticalPosition2">
            <summary>
            a positional preposition referring to the vertical dimension
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.via1">
            <summary>
            via ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.vice1">
            <summary>
            vice ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.visavis1">
            <summary>
            visvis ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.whereas1">
            <summary>
            whereas ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.within1">
            <summary>
            inside, within (temporal)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.without4">
            <summary>
            without (agent), e.g. without her
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.without5">
            <summary>
            without (instrument), e.g. without a key
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.without7">
            <summary>
            without, except, sans, save, ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.with4">
            <summary>
            with (agent), e.g. with her
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.with5">
            <summary>
            with (instrument), e.g. with a key
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.with7">
            <summary>
            accompanying; possessing (something) as a feature (e.g. with a white bib)
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.withRegardTo7">
            <summary>
            with regard to ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.withRespectTo7">
            <summary>
            with respect to ...
            </summary>
        </member>
        <member name="T:AboditNLP.Preposition.worth1">
            <summary>
            worth ...
            </summary>
        </member>
        <member name="T:AboditNLP.W00">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W00.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W01">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W01.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W02">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W02.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W04">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W04.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W05">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W05.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W06">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W06.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W07">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W07.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W08">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W08.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W09">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W09.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W10">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W10.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W11">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W11.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W12">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W12.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W13">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W13.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W14">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W14.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W15">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W15.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W16">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W16.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W17">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W17.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W18">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W18.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W19">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W19.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W20">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W20.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W21">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W21.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W23">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W23.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W24">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W24.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W25">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W25.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W27">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W27.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W28">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W28.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W29">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W29.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W30">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W30.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W31">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W31.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W32">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W32.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W33">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W33.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W34">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W34.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W35">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W35.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W36">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W36.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W37">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W37.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W39">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W39.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W40">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W40.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W41">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W41.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W42">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W42.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W43">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W43.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W46">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W46.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W47">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W47.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W49">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W49.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W50">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W50.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W51">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W51.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W52">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W52.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W53">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W53.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W54">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W54.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W55">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W55.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W56">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W56.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W57">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W57.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W58">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W58.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W59">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W59.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W60">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W60.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W61">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W61.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W62">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W62.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W63">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W63.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W64">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W64.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W65">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W65.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W66">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W66.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W68">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W68.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W69">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W69.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W72">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W72.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W73">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W73.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W74">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W74.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W75">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W75.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W77">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W77.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W79">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W79.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W80">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W80.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W82">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W82.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W83">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W83.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W85">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W85.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W86">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W86.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W87">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W87.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W88">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W88.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W89">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W89.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W90">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W90.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W91">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W91.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W92">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W92.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W94">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W94.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W95">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W95.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W97">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W97.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W98">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W98.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.W99">
            <summary>
             A collection of Lexeme definitions
            </summary>
        </member>
        <member name="M:AboditNLP.W99.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
             Create words and add them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.GraphA">
            <summary>
             Graph generator
            </summary>
        </member>
        <member name="M:AboditNLP.GraphA.CreateGraph">
            <summary>
             Add graph relationships
            </summary>
        </member>
        <member name="T:AboditNLP.GraphB">
            <summary>
             Graph generator
            </summary>
        </member>
        <member name="M:AboditNLP.GraphB.CreateGraph">
            <summary>
             Add graph relationships
            </summary>
        </member>
        <member name="T:AboditNLP.GraphC">
            <summary>
             Graph generator
            </summary>
        </member>
        <member name="M:AboditNLP.GraphC.CreateGraph">
            <summary>
             Add graph relationships
            </summary>
        </member>
        <member name="T:AboditNLP.GraphD">
            <summary>
             Graph generator
            </summary>
        </member>
        <member name="M:AboditNLP.GraphD.CreateGraph">
            <summary>
             Add graph relationships
            </summary>
        </member>
        <member name="T:AboditNLP.GraphE">
            <summary>
             Graph generator
            </summary>
        </member>
        <member name="M:AboditNLP.GraphE.CreateGraph">
            <summary>
             Add graph relationships
            </summary>
        </member>
        <member name="T:AboditNLP.GraphF">
            <summary>
             Graph generator
            </summary>
        </member>
        <member name="M:AboditNLP.GraphF.CreateGraph">
            <summary>
             Add graph relationships
            </summary>
        </member>
        <member name="T:AboditNLP.GraphG">
            <summary>
             Graph generator
            </summary>
        </member>
        <member name="M:AboditNLP.GraphG.CreateGraph">
            <summary>
             Add graph relationships
            </summary>
        </member>
        <member name="T:AboditNLP.GraphH">
            <summary>
             Graph generator
            </summary>
        </member>
        <member name="M:AboditNLP.GraphH.CreateGraph">
            <summary>
             Add graph relationships
            </summary>
        </member>
        <member name="T:AboditNLP.GraphI">
            <summary>
             Graph generator
            </summary>
        </member>
        <member name="M:AboditNLP.GraphI.CreateGraph">
            <summary>
             Add graph relationships
            </summary>
        </member>
        <member name="T:AboditNLP.GraphL">
            <summary>
             Graph generator
            </summary>
        </member>
        <member name="M:AboditNLP.GraphL.CreateGraph">
            <summary>
             Add graph relationships
            </summary>
        </member>
        <member name="T:AboditNLP.GraphM">
            <summary>
             Graph generator
            </summary>
        </member>
        <member name="M:AboditNLP.GraphM.CreateGraph">
            <summary>
             Add graph relationships
            </summary>
        </member>
        <member name="T:AboditNLP.GraphN">
            <summary>
             Graph generator
            </summary>
        </member>
        <member name="M:AboditNLP.GraphN.CreateGraph">
            <summary>
             Add graph relationships
            </summary>
        </member>
        <member name="T:AboditNLP.GraphO">
            <summary>
             Graph generator
            </summary>
        </member>
        <member name="M:AboditNLP.GraphO.CreateGraph">
            <summary>
             Add graph relationships
            </summary>
        </member>
        <member name="T:AboditNLP.GraphP">
            <summary>
             Graph generator
            </summary>
        </member>
        <member name="M:AboditNLP.GraphP.CreateGraph">
            <summary>
             Add graph relationships
            </summary>
        </member>
        <member name="T:AboditNLP.GraphQ">
            <summary>
             Graph generator
            </summary>
        </member>
        <member name="M:AboditNLP.GraphQ.CreateGraph">
            <summary>
             Add graph relationships
            </summary>
        </member>
        <member name="T:AboditNLP.GraphR">
            <summary>
             Graph generator
            </summary>
        </member>
        <member name="M:AboditNLP.GraphR.CreateGraph">
            <summary>
             Add graph relationships
            </summary>
        </member>
        <member name="T:AboditNLP.GraphT">
            <summary>
             Graph generator
            </summary>
        </member>
        <member name="M:AboditNLP.GraphT.CreateGraph">
            <summary>
             Add graph relationships
            </summary>
        </member>
        <member name="T:AboditNLP.GraphU">
            <summary>
             Graph generator
            </summary>
        </member>
        <member name="M:AboditNLP.GraphU.CreateGraph">
            <summary>
             Add graph relationships
            </summary>
        </member>
        <member name="T:AboditNLP.GraphV">
            <summary>
             Graph generator
            </summary>
        </member>
        <member name="M:AboditNLP.GraphV.CreateGraph">
            <summary>
             Add graph relationships
            </summary>
        </member>
        <member name="T:AboditNLP.GraphW">
            <summary>
             Graph generator
            </summary>
        </member>
        <member name="M:AboditNLP.GraphW.CreateGraph">
            <summary>
             Add graph relationships
            </summary>
        </member>
        <member name="F:AboditNLP.ProductionRules.OperatorType.Boolean">
            <summary>
            And, or
            </summary>
        </member>
        <member name="F:AboditNLP.ProductionRules.OperatorType.Comparison">
            <summary>
            Less than, greater than, ...
            </summary>
        </member>
        <member name="F:AboditNLP.ProductionRules.OperatorType.Matches">
            <summary>
            Matches
            </summary>
        </member>
        <member name="T:AboditNLP.ProductionRules.ExpressionOperators">
            <summary>
            Expression operators for Int, Double - grouped in one class because priorities apply across
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.ExpressionOperators.LookupOperator(AboditNLP.IOperator)">
            <summary>
            Convert an operator into a Func that creates an expression from the operands
            </summary>
        </member>
        <member name="T:AboditNLP.ProductionRules.IStringList">
            <summary>
            An object that is a list of strings parsed from the input, could be an And or an Or
            </summary>
        </member>
        <member name="P:AboditNLP.ProductionRules.IStringList.Values">
            <summary>
            Get the values
            </summary>
        </member>
        <member name="T:AboditNLP.ProductionRules.StringListOr">
            <summary>
            A parsed list of quoted strings, e.g. "A" or "B"; "A", "B" or "C".
            </summary>
        </member>
        <member name="P:AboditNLP.ProductionRules.StringListOr.Values">
            <summary>
            Get the values
            </summary>
        </member>
        <member name="T:AboditNLP.ProductionRules.StringListAnd">
            <summary>
            A parsed list of quoted strings, e.g. "A" and "B"; "A", "B" and "C".
            </summary>
        </member>
        <member name="P:AboditNLP.ProductionRules.StringListAnd.Values">
            <summary>
            Get the values
            </summary>
        </member>
        <member name="T:AboditNLP.ProductionRules.MetaSortOrderProductions">
            <summary>
            Production rules that create sort orders
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.MetaSortOrderProductions.MetaSortOrderFromExpression(Abodit.Expressions.TokenExpression,System.Boolean)">
            <summary>
            Get a MetaSortOrder or null if it makes no sense from the expression passed in
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.MetaSortOrderProductions.TheHighestNounExpr(AboditNLP.Article.the,AboditNLP.Adjective.Type.LargeType,Abodit.Expressions.TokenExpression)">
            <summary>
            A production rule that matches phrases like "the most calories",
            "the highest rating", "the greatest price", "the heaviest"
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.MetaSortOrderProductions.TheHighestNounExpr(AboditNLP.Article.the,AboditNLP.Adjective.Type.LargeType,AboditNLP.IAmbiguous{Abodit.Expressions.TokenExpression})">
            <summary>
            A production rule that matches phrases like "the most calories",
            "the highest rating", "the greatest price", "the heaviest"
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.MetaSortOrderProductions.TheSmallestNounExpr(AboditNLP.Article.the,AboditNLP.Adjective.Type.SmallType,Abodit.Expressions.TokenExpression)">
            <summary>
            A production rule that matches phrases like "the smallest diameter",
            "the fewest people", ...
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.MetaSortOrderProductions.TheSmallestNounExpr(AboditNLP.Article.the,AboditNLP.Adjective.Type.SmallType,AboditNLP.IAmbiguous{Abodit.Expressions.TokenExpression})">
            <summary>
            A production rule that matches phrases like "the smallest diameter",
            "the fewest people", ...
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.MetaSortOrderProductions.ByFieldAscending(AboditNLP.Preposition.by5,Abodit.Expressions.TokenExpression,AboditNLP.Adjective.ascending)">
            <summary>
            A production rule that matches phrases like "by price ascending", or just "by price"
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.MetaSortOrderProductions.ByFieldDescending(AboditNLP.Preposition.by5,Abodit.Expressions.TokenExpression,AboditNLP.Adjective.descending)">
            <summary>
            A production rule that matches phrases like "by price descending",
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.MetaSortOrderProductions.ByFieldDescending(AboditNLP.Preposition.by5,Abodit.Expressions.TokenExpression,AboditNLP.Adjective.inverse,AboditNLP.Noun.order)">
            <summary>
            A production rule that matches phrases like "by price reverse", "by price reverse order"
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.MetaSortOrderProductions.InOrderBy(AboditNLP.Preposition.in1,AboditNLP.Noun.orbit,AboditNLP.Preposition.by5,Abodit.Expressions.TokenExpression,AboditNLP.Adjective.ascending)">
            <summary>
            A production rule that matches phrases like "in order by price", "in reverse price order", ...
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.MetaSortOrderProductions.InOrderBy(AboditNLP.Preposition.in1,AboditNLP.Adjective.ascending,AboditNLP.Noun.order,AboditNLP.Preposition.by5,Abodit.Expressions.TokenExpression)">
            <summary>
            A production rule that matches phrases like "in ascending order by price"...
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.MetaSortOrderProductions.ByFieldDescending(AboditNLP.Preposition.in1,AboditNLP.Noun.order,AboditNLP.Preposition.by5,Abodit.Expressions.TokenExpression,AboditNLP.Adjective.descending)">
            <summary>
            A production rule that matches phrases like "in order by price descending",
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.MetaSortOrderProductions.ByFieldDescending(AboditNLP.Preposition.in1,AboditNLP.Adjective.descending,AboditNLP.Noun.orbit,AboditNLP.Preposition.by5,Abodit.Expressions.TokenExpression)">
            <summary>
            A production rule that matches phrases like "in descending order by price",
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.MetaSortOrderProductions.ByFieldDescending(AboditNLP.Preposition.in1,AboditNLP.Adjective.inverse,AboditNLP.Noun.orbit,AboditNLP.Preposition.by5,Abodit.Expressions.TokenExpression)">
            <summary>
            A production rule that matches phrases like "in reverse order by price",
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.MetaSortOrderProductions.ByFieldAscending(AboditNLP.Preposition.by5,AboditNLP.IAmbiguous{Abodit.Expressions.TokenExpression},AboditNLP.Adjective.ascending)">
            <summary>
            A production rule that matches phrases like "by price ascending", or just "by price"
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.MetaSortOrderProductions.ByFieldDescending(AboditNLP.Preposition.by5,AboditNLP.IAmbiguous{Abodit.Expressions.TokenExpression},AboditNLP.Adjective.descending)">
            <summary>
            A production rule that matches phrases like "by price descending",
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.MetaSortOrderProductions.InOrderBy(AboditNLP.Preposition.in1,AboditNLP.Noun.orbit,AboditNLP.Preposition.by5,AboditNLP.IAmbiguous{Abodit.Expressions.TokenExpression},AboditNLP.Adjective.ascending)">
            <summary>
            A production rule that matches phrases like "in order by price", "in reverse price order", ...
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.MetaSortOrderProductions.InOrderBy(AboditNLP.Preposition.in1,AboditNLP.Adjective.ascending,AboditNLP.Noun.orbit,AboditNLP.Preposition.by5,AboditNLP.IAmbiguous{Abodit.Expressions.TokenExpression})">
            <summary>
            A production rule that matches phrases like "in ascending order by price"...
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.MetaSortOrderProductions.ByFieldDescending(AboditNLP.Preposition.in1,AboditNLP.Noun.orbit,AboditNLP.Preposition.by5,AboditNLP.IAmbiguous{Abodit.Expressions.TokenExpression},AboditNLP.Adjective.descending)">
            <summary>
            A production rule that matches phrases like "in order by price descending",
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.MetaSortOrderProductions.ByFieldDescending(AboditNLP.Preposition.in1,AboditNLP.Adjective.descending,AboditNLP.Noun.orbit,AboditNLP.Preposition.by5,AboditNLP.IAmbiguous{Abodit.Expressions.TokenExpression})">
            <summary>
            A production rule that matches phrases like "in descending order by price",
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.MetaSortOrderProductions.ByFieldDescending(AboditNLP.Preposition.in1,AboditNLP.Adjective.inverse,AboditNLP.Noun.order,AboditNLP.Preposition.by5,Abodit.Expressions.TokenExpression)">
            <summary>
            A production rule that matches phrases like "in reverse order by price", "reverse order by price", "reverse by price"
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.MetaSortOrderProductions.ByFieldDescending(AboditNLP.Preposition.in1,AboditNLP.Adjective.inverse,AboditNLP.Noun.order,AboditNLP.Preposition.by5,AboditNLP.IAmbiguous{Abodit.Expressions.TokenExpression})">
            <summary>
            A production rule that matches phrases like "in reverse order by price", "reverse order by price", "reverse by price"
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.CardinalProductions.CardinalTerminatingIsInt(AboditNLP.Noun.Type.CardinalTerminator)">
            <summary>
            A terminating cardinal can be an int
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.CardinalProductions.CardinalTensDashUnits(AboditNLP.Noun.Type.CardinalTens,AboditNLP.Punctuation.dash,AboditNLP.Noun.Type.CardinalUnits)">
            <summary>
            e.g. "sixty-three" which is the proper way to write "sixty three"
            but accept both
            </summary>
            <remarks>
            High priority because otherwise it becomes an expression sixty minus three
            </remarks>
        </member>
        <member name="M:AboditNLP.ProductionRules.CardinalProductions.UpperDecadeAndLowerDecade(Abodit.Expressions.TokenInt,AboditNLP.Conjunction.and,Abodit.Expressions.TokenInt)">
            <summary>
            e.g. two hundred and sixty-three
            or repeatedly five hundred and fifty million two hundred and ten thousand
            don't check size order to allow the old english "four and twenty" XXX didn't do this
            </summary>
        </member>
        <member name="T:AboditNLP.ProductionRules.AdjectiveNounThingType">
            <summary>
            A pair of adjective plus noun (e.g. unoccupied rooms)
            </summary>
        </member>
        <member name="P:AboditNLP.ProductionRules.AdjectiveNounThingType.Adjective">
            <summary>
            The Adjective
            </summary>
        </member>
        <member name="P:AboditNLP.ProductionRules.AdjectiveNounThingType.Noun">
            <summary>
            The Noun
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.AdjectiveNounThingType.#ctor(AboditNLP.IAdjective,AboditNLP.INoun)">
            <summary>
            Create a new instane of AdjectiveNounThingType
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.AdjectiveNounThingType.GetOrAdd(AboditNLP.IAdjective,AboditNLP.INoun)">
            <summary>
            Factory method that identity-maps each use of a given adjective,noun pair to same object
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.AdjectiveNounThingType.Format(System.Double)">
            <summary>
            Get a textual description
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.AdjectiveNounThingType.ReduceKeepingAdjective``1(AboditNLP.ProductionRules.AdjectiveNounThingType,System.String,System.String)">
            <summary>
            Project, don't forget to filter out nulls
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.AdjectiveNounThingType.ReduceRemovingAdjective``1(AboditNLP.ProductionRules.AdjectiveNounThingType,System.String,System.String)">
            <summary>
            Project, removing the adjective, and changing the noun don't forget to filter out nulls
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.AdjectiveNounThingType.ReduceRemovingAdjective(AboditNLP.ProductionRules.AdjectiveNounThingType)">
            <summary>
            Project, removing the adjective, don't forget to filter out nulls
            </summary>
        </member>
        <member name="T:AboditNLP.ProductionRules.CountableThingsProductionRules`2">
            <summary>
            Inherit from this and use the adjective or noun classes you want for your countable nouns, e.g.
            public class CountablePeople&lt;IAdjective,people1&gt; ...
            </summary>
        </member>
        <member name="T:AboditNLP.ProductionRules.CountableThingsProductionRules`1">
            <summary>
            Inherit from this and use the noun interfaces you want for your countable nouns, 
            e.g. public class CountablePeople&lt;people1&gt; ...
            </summary>
        </member>
        <member name="P:AboditNLP.ProductionRules.CountableThingsProductionRules`1.Dimension">
            <summary>
            Dimension for this set of production rules
            </summary>
        </member>
        <member name="T:AboditNLP.ProductionRules.CountableThingProductionRulesCombinations">
            <summary>
            Rules that apply to all instances of countable things in sequences
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.OrdinalProductions.CardinalTensHyphenOrdinalTerminator(AboditNLP.Noun.Type.CardinalTens,AboditNLP.Punctuation.dash,AboditNLP.Adjective.Type.OrdinalTerminator)">
            <summary>
            e.g. "fifty-sixth"
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.OrdinalProductions.OrdinalFromCardinalOrdinalDecade(AboditNLP.Noun.Type.Cardinal,AboditNLP.Adjective.Type.OrdinalDecade)">
            <summary>
            e.g. hundred thousandth
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.OrdinalProductions.OrdinalFromCardinalDashOrdinalDecade(AboditNLP.Noun.Type.Cardinal,AboditNLP.Punctuation.dash,AboditNLP.Adjective.Type.OrdinalDecade)">
            <summary>
            e.g. hundred-thousandth
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.OrdinalProductions.OrdinalFromCardinalOrdinal(AboditNLP.Noun.Type.Cardinal,AboditNLP.Adjective.Type.OrdinalTerminator)">
            <summary>
            e.g. twenty seventh
            e.g. two hundred and sixty-*first*
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.OrdinalProductions.OrdinalFromCardinalAndOrdinal(AboditNLP.Noun.Type.Cardinal,AboditNLP.Conjunction.and,AboditNLP.Adjective.Type.OrdinalType)">
            <summary>
            e.g. hundred and ninety-ninth
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.OrdinalProductions.OrdinalFromCardinalDashAndDashOrdinal(AboditNLP.Noun.Type.Cardinal,AboditNLP.Punctuation.dash,AboditNLP.Conjunction.and,AboditNLP.Punctuation.dash,AboditNLP.Adjective.Type.OrdinalTerminator)">
            <summary>
            e.g. hundred-and-first
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.RationalProductions.ArticlePlusOrdinal(AboditNLP.Article.AAn,AboditNLP.Adjective.Type.OrdinalType)">
            <summary>
            a *sixth*, a *twentieth*, a *thousandth*, a "five hundred-thousandth"
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.RationalProductions.RationalNumbersWithHyphen(AboditNLP.Noun.Type.Cardinal,AboditNLP.Noun.Type.Cardinal,AboditNLP.Punctuation.dash,AboditNLP.Noun.Type.RationalPlural)">
            <summary>
            e.g. "two fifty-sixths" = 2/56
            e.g. "five two hundred and fifty-sixths" = 1/256
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.RationalProductions.OneRationalSingle(AboditNLP.Noun.one,AboditNLP.Adjective.Type.OrdinalType)">
            <summary>
            e.g. "one twenty-eighth" = 1/28
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.RationalProductions.MultipleOfRational(AboditNLP.Noun.Type.Cardinal,AboditNLP.Noun.Type.RationalPlural)">
            <summary>
            e.g. "four fifty-sixths" = 4/56
            e.g. "nine two hundred and fifty-sixths" = 9/256
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.RationalProductions.MultipleOfOrdinalTerminator(AboditNLP.Noun.Type.Cardinal,AboditNLP.Adjective.Type.OrdinalTerminator)">
            <summary>
            e.g. " one sixth" = 1/56
            </summary>
            <remarks>
            "sixth" isn't a fraction until you preprend it with "A" or "One"
            "90 second" isn't acceptable
            twenty thirds is acceptable
            "two-sixths" however should be hyphenated
            </remarks>
        </member>
        <member name="M:AboditNLP.ProductionRules.TemporalSets.TemporalSetDayOfMonthProductions.InfiniteDayInMonthRange(Abodit.Temporal.TemporalSetInfiniteDayInMonth,AboditNLP.Preposition.to1,Abodit.Temporal.TemporalSetInfiniteDayInMonth)">
            <summary>
            From April 1st to August 2nd
            or from November 2nd to January 8th (wrap over year)
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.TemporalSets.TemporalSetMonths.InfiniteMonthRange(AboditNLP.Preposition.from1,Abodit.Temporal.TemporalSetInfiniteMonthSpecific,AboditNLP.Preposition.to1,Abodit.Temporal.TemporalSetInfiniteMonthSpecific)">
            <summary>
            From April to June
            or from November to January
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.TemporalSets.TemporalSetProductions.TemporalSetFromTimeRange(Abodit.Units.TimeRange)">
            <summary>
            Any time range can represent a time in a day
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.TemporalSets.TemporalSetProductions.DayOfMonth(AboditNLP.Adjective.Type.OrdinalType)">
            <summary>
            An ordinal up to 31st can be a day of the month
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.TemporalSets.TemporalSetTimePeriods.TheNthPeriodIn(AboditNLP.Article.the,AboditNLP.Adjective.Type.OrdinalType,AboditNLP.Noun.Type.Cardinal,AboditNLP.Noun.Type.UnitOfTime,AboditNLP.Preposition.in1,Abodit.Temporal.TemporalSetFinite)">
            <summary>
            Production rule for creating the Nth M periods in a temporal set
            </summary>
            <remarks>
            the first three months in 2018 => the first month U the second month U the third month 
            </remarks>
        </member>
        <member name="M:AboditNLP.ProductionRules.TemporalSets._TokenTemporalProductionRules.DateRangeFromTo(AboditNLP.Preposition.from1,Abodit.Temporal.TemporalSetFiniteSpecificDate,AboditNLP.Preposition.to1,Abodit.Temporal.TemporalSetFiniteSpecificDate)">
            <summary>
            e.g. From 1/1/2015 to 3/3/2015
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.TemporalSets._TokenTemporalProductionRules.BetweenTemporalSets(AboditNLP.Preposition.between1,Abodit.Temporal.TemporalSetFinite,AboditNLP.Conjunction.and,Abodit.Temporal.TemporalSetFinite)">
            <summary>
            e.g. Between 1/1/2015 and 3/3/2015
            Between 1984 and 1985
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.TemporalSets._TokenTemporalProductionRules.BetweenTemporalSets(Abodit.Temporal.TemporalSetFinite,AboditNLP.Punctuation.dash,Abodit.Temporal.TemporalSetFinite)">
            <summary>
            1984-1985
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.TemporalSets._TokenTemporalProductionRules.DateTime(Abodit.Temporal.TemporalSetFiniteSpecificDate)">
            <summary>
            Allow specific dates to be used as DateTime values
            </summary>
        </member>
        <member name="T:AboditNLP.ProductionRules.Units.Prefix">
            <summary>
            A prefix like "that is", "which are", "who is"
            with, with a, with an, with the, whose, ...
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.Units.Prefix.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:AboditNLP.ProductionRules.Units.UnitProductionBase">
            <summary>
            Base class for all unit productions
            </summary>
        </member>
        <member name="F:AboditNLP.ProductionRules.Units.UnitProductionBase.AdjectiveInterpretations">
            <summary>
            Common interpretations for adjectives mapping them to dimensions and qualifiers
            </summary>
            <remarks>
            There is a 1:1 correspondence between an adjective and an interpretation,
            create new adjectives if there is more than one meaning for a word in terms
            of dimensionality or qualifier.
            </remarks>
        </member>
        <member name="M:AboditNLP.ProductionRules.Units.UnitProductionBase.InterpretationFromAdjectiveBase(AboditNLP.IAdjective)">
            <summary>
            Interpret an adjective as a Dimension and qualifiers
            </summary>
        </member>
        <member name="T:AboditNLP.ProductionRules.Units.UnitProductions`1">
            <summary>
            Each new unit type that is defined should also have an instance of this generic type created for it that
            handles all the common range productions for that type
            </summary>
            <summary>
            Each new unit type that is defined should also have an instance of this generic type created for it that
            handles all the common range productions for that type
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:AboditNLP.ProductionRules.Units.UnitProductions`1.Dimension">
            <summary>
            Each set of production rules is with respect to a specific Dimension
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.Units.UnitProductions`1.InterpretationFromAdjective(AboditNLP.IAdjective,`0)">
            <summary>
            Convert an adjective to a set of Qualifiers 
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.Units.UnitProductions`1.ExpressionDoesNotWorkWithRange(Abodit.Expressions.TokenExpression,Abodit.Units.Range{`0})">
            <summary>
            Checks that the expr and the range have compatible dimensions
            </summary>
        </member>
        <member name="T:AboditNLP.ProductionRules.Units.ConnectingStopWordsBeforeRange">
            <summary>
            that are, which are, is, are, of...
            </summary>
        </member>
        <member name="T:AboditNLP.ProductionRules.Units.UnitProductionsCommon">
            <summary>
            Contains common prefixes and such like used by all unit productions
            </summary>
        </member>
        <member name="T:AboditNLP.ProductionRules.Units._QuantityProductions">
            <summary>
            Production rules for producing quantities
            </summary>
        </member>
        <member name="M:AboditNLP.ProductionRules.Units._QuantityProductions.CreateFromUnits``1(Abodit.Expressions.TokenDouble,AboditNLP.ITokenText,Abodit.Units.UnitSet,System.Func{System.Double,Abodit.Units.IUnit,Abodit.Units.QuantityQualifier,``0})">
            <summary>
            Create a UnitOfMeasure from a given prefix like mega, kilo, ...
            </summary>
        </member>
        <member name="T:AboditNLP.ProductionRules.Units.UnitLexemes">
            <summary>
            Add all of the Units in the unit registry into the Lexeme store
            </summary>
        </member>
        <member name="T:AboditNLP.Filters.ActionMethodFilterAttribute">
            <summary>
            Base for all attributes applied for NLP purposes
            </summary>
        </member>
        <member name="M:AboditNLP.Filters.ActionMethodFilterAttribute.IsValid(AboditNLP.IRememberState)">
            <summary>
            Is the action method valid for this remembers state
            </summary>
        </member>
        <member name="T:AboditNLP.Filters.IgnoreRuleAttribute">
            <summary>
            The ignore rule attribute excludes a method from consideration as a valid rule
            </summary>
        </member>
        <member name="M:AboditNLP.Filters.IgnoreRuleAttribute.IsValid(AboditNLP.IRememberState)">
            <summary>
            Is the action method valid in this state
            </summary>
        </member>
        <member name="T:AboditNLP.Filters.KnownTypesAttribute">
            <summary>
            A class marked with KnownTypes may generate tokens having interfaces other than the ones marked on the class itself
            </summary>
        </member>
        <member name="P:AboditNLP.Filters.KnownTypesAttribute.Interfaces">
            <summary>
            The interfaces this class can produce
            </summary>
        </member>
        <member name="M:AboditNLP.Filters.KnownTypesAttribute.#ctor(System.Type[])">
            <summary>
            Create a new instance of the KnownTypesAttribute
            </summary>
        </member>
        <member name="M:AboditNLP.Filters.KnownTypesAttribute.IsValidFor(System.Type[])">
            <summary>
            Is this valid for a given type?
            </summary>
            <param name="requestedTypes"></param>
            <returns></returns>
        </member>
        <member name="T:AboditNLP.Filters.UniversalTokenAttribute">
            <summary>
            A class marked as UniversalToken will be called to parse all input strings regardless of the active types at this time
            </summary>
        </member>
        <member name="T:AboditNLP.INLP">
            <summary>
            The NLP engine's primary interface
            </summary>
        </member>
        <member name="P:AboditNLP.INLP.Ready">
            <summary>
            Signals that NLP is ready
            </summary>
        </member>
        <member name="M:AboditNLP.INLP.Execute(System.String,System.Object[])">
            <summary>
            Executes a natural language command
            </summary>
            <param name="text">the line to interpret</param>
            <param name="objectsToInject">additional objects to inject into the constructor of any classes containing rules
            beyond those supplied using an IOC by way of CommonServiceLocator</param>
            <returns>true if the command was matched against the rules base</returns>
        </member>
        <member name="M:AboditNLP.INLP.ParseInputToGetTokens(AboditNLP.IDependencyScope,System.String)">
            <summary>
            Parse input without executing any rules (mostly for test purposes)
            </summary>
        </member>
        <member name="M:AboditNLP.INLP.Initialize">
            <summary>
            Before calling intialize you should set dependency resolver, logger and options
            </summary>
        </member>
        <member name="M:AboditNLP.INLP.InitializeAsync">
            <summary>
            Before calling intialize you should set dependency resolver, logger and options
            </summary>
        </member>
        <member name="M:AboditNLP.INLP.InitializeAsync(System.Threading.CancellationToken)">
            <summary>
            Initiate initialization Before calling intialize you should set dependency resolver, logger and options
            </summary>
        </member>
        <member name="P:AboditNLP.INLP.LexemeStore">
            <summary>
            Get the LexemeStore where additional Lexemes can be stored at startup or runtime
            </summary>
            <remarks>
            For example, you could add product names, product family names and brand names here.
            </remarks>
        </member>
        <member name="M:AboditNLP.INLP.GetDefinition(AboditNLP.ITokenText)">
            <summary>
            Assemblies built from RDF/N3 may include definitions for each token
            </summary>
            <remarks>
            The Wordnet assemblies for AboditNLP both include definitions
            </remarks>
        </member>
        <member name="M:AboditNLP.INLP.GetDefinition(AboditNLP.SynSet)">
            <summary>
            Assemblies built from RDF/N3 may include definitions for each synset
            </summary>
            <remarks>
            The Wordnet assemblies for AboditNLP both include definitions
            </remarks>
        </member>
        <member name="M:AboditNLP.INLP.AddProductionRule``2(System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Int32,AboditNLP.Attributes.Associativity,System.Double)">
            <summary>
            Add a ProductionRule as an Expression
            </summary>
        </member>
        <member name="M:AboditNLP.INLP.AddProductionRule``3(System.Linq.Expressions.Expression{System.Func{``0,``1,``2}},System.Int32,AboditNLP.Attributes.Associativity,System.Double)">
            <summary>
            Add a ProductionRule as an Expression
            </summary>
        </member>
        <member name="T:AboditNLP.INLPRule">
            <summary>
            Marker class to put on each class that contains Rules or ProductionRules
            </summary>
            <remarks>
            AboditNLP will construct this class and inject any necessary parameters into it
            provided they are available either in the parameters passed to the Execute method
            or registered with the dependency injection framework container
            </remarks>
        </member>
        <member name="T:AboditNLP.ITokenFactory">
            <summary>
            A Token factory hands out tokens chomped off the front of an input string
            </summary>
        </member>
        <member name="M:AboditNLP.ITokenFactory.Parse(AboditNLP.NLPOptions,System.Int32,System.String,AboditNLP.AllowedToken[])">
            <summary>
            Parse the input string starting at the start position returning any tokens that
            are found at that location
            </summary>
            <param name="options"></param>
            <param name="start"></param>
            <param name="input"></param>
            <param name="allowed"></param>
            <returns></returns>
        </member>
        <member name="T:AboditNLP.ITokenFactorySlow">
            <summary>
            Marker interface on token factories that are 'slow'
            </summary>
        </member>
        <member name="T:AboditNLP.IDependencyScope">
            <summary>
            To avoid any dependency on a particular dependency injection container Abodit NLP
            takes a single parameter which is a dependency resolver.
            </summary>
            <remarks>
            See https://msdn.microsoft.com/en-us/library/system.web.http.dependencies.idependencyscope(v=vs.118).aspx
            This is just like dependency injection in Microsoft's WebAPI 2
            </remarks>
        </member>
        <member name="M:AboditNLP.IDependencyScope.GetService(System.Type)">
            <summary>
            Get a service of a given type
            </summary>
        </member>
        <member name="M:AboditNLP.IDependencyScope.GetService``1">
            <summary>
            Get a service of a given type
            </summary>
        </member>
        <member name="M:AboditNLP.IDependencyScope.GetServices(System.Type)">
            <summary>
            Get services of a given type
            </summary>
        </member>
        <member name="M:AboditNLP.IDependencyScope.GetServices``1">
            <summary>
            Get services of a given type
            </summary>
        </member>
        <member name="T:AboditNLP.IDependencyResolver">
            <summary>
            To avoid any dependency on a particular dependency injection container Abodit NLP
            takes a single parameter which is a dependency resolver.
            </summary>
            <remarks>
            See https://msdn.microsoft.com/en-us/library/system.web.http.dependencies.idependencyscope(v=vs.118).aspx
            This is just like dependency injection in Microsoft's WebAPI 2
            </remarks>
        </member>
        <member name="M:AboditNLP.IDependencyResolver.BeginScope">
            <summary>
            See https://msdn.microsoft.com/en-us/library/system.web.http.dependencies.idependencyresolver.beginscope(v=vs.118).aspx
            This is analagous to WebAPI methods
            </summary>
        </member>
        <member name="M:AboditNLP.IDependencyResolver.BeginScope(System.Object[])">
            <summary>
            Begin a dependency scope but add in some additional per-request objects that can be resolved
            </summary>
        </member>
        <member name="M:AboditNLP.IDependencyResolver.GetTypes``1">
            <summary>
            Get types that implement the interface T (without instantiating them)
            </summary>
            <remarks>
            This is unlike most dependency injection containers which can only
            hand over concrete instatiations of a type.
            </remarks>
        </member>
        <member name="T:AboditNLP.INLPPart">
            <summary>
            Marks a class as being one that should be registered with the dependency injection container
            </summary>
        </member>
        <member name="T:AboditNLP.Meta.CompleteQueryProductionRules">
            <summary>
            Production rules for complete queries
            </summary>
        </member>
        <member name="T:AboditNLP.Meta.CompleteQueryProductionRules.TakeQueryPrefix">
            <summary>
            A prefix that means 'Take', e.g. "the 25 longest products"
            </summary>
        </member>
        <member name="M:AboditNLP.Meta.CompleteQueryProductionRules.CartesianProduct(System.Collections.Generic.IEnumerable{Abodit.Expressions.TokenExpression}[])">
            <summary>
            Compute the catesian AND product of a set of true/false expressions
            </summary>
        </member>
        <member name="M:AboditNLP.Meta.CompleteQueryProductionRules.CombineFilters(Abodit.Expressions.TokenExpression[])">
            <summary>
            Combine a set of filters, possibly including nulls to create a single combined filter
            </summary>
        </member>
        <member name="T:AboditNLP.Meta.CompleteQueryProductionRules.MetaEntityListVisitor">
            <summary>
            Explores an expression to find all of the unbound meta entities in it
            </summary>
        </member>
        <member name="T:AboditNLP.Meta.MetaQuestionSuffixProductions">
            <summary>
            Production rules for meta suffixes
            </summary>
        </member>
        <member name="T:AboditNLP.Meta.QueryNotSatisfiableException">
            <summary>
            Could not satisfy all top-level ranges in a CompleteQuery
            </summary>
        </member>
        <member name="T:AboditNLP.Meta.RangeRewriterVisitor">
            <summary>
            Using an IMetaEntity rewrite any unbound Range expressions to match
            the corresponding fields in the metaentity that they might be bound to
            </summary>
        </member>
        <member name="T:AboditNLP.Expressions.DimensionalSortOrder">
            <summary>
            A sort order defined by an adjective expressing a dimension, and maybe some qualifiers
            e.g. longest, shortest, largest, heaviest, ...
            </summary>
        </member>
        <member name="P:AboditNLP.Expressions.DimensionalSortOrder.Interpretation">
            <summary>
            The adjective interpretation
            </summary>
        </member>
        <member name="M:AboditNLP.Expressions.DimensionalSortOrder.#ctor(Abodit.Units.Dimensions.Interpretation)">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Expressions.DimensionalSortOrder"/> class
            </summary>
            <param name="interpretation"></param>
        </member>
        <member name="M:AboditNLP.Expressions.DimensionalSortOrder.ToString">
            <summary>
            Returns a string representing this object
            </summary>
        </member>
        <member name="M:AboditNLP.Expressions.DimensionalSortOrder.Equals(AboditNLP.Expressions.DimensionalSortOrder)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:AboditNLP.Expressions.DimensionalSortOrder.GetHashCode">
            <summary>
            Hashcode
            </summary>
        </member>
        <member name="T:AboditNLP.Expressions.FieldQualifiersGenerator">
            <summary>
            A LexemeGenerator that puts words and synsets into the store for
            all of the defined FieldQualifiers
            </summary>
        </member>
        <member name="M:AboditNLP.Expressions.FieldQualifiersGenerator.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
            Creates words
            </summary>
        </member>
        <member name="T:AboditNLP.Expressions.WordsForMeta">
            <summary>
            These are all words needed for tests, normally these would be in Dictionary or Wordnet
            but for field adjectives we need all the definitions to be accessible to all
            users of just the core NLP library (I think)
            </summary>
        </member>
        <member name="T:AboditNLP.Expressions.WordsForMeta.GraphAntonyms">
            <summary>
             Graph generator for antonyms (sample one for testing, most are generated from Wordnet)
            </summary>
        </member>
        <member name="M:AboditNLP.Expressions.WordsForMeta.GraphAntonyms.CreateGraph">
            <summary>
             Add graph relationships
            </summary>
        </member>
        <member name="T:AboditNLP.NLP">
            <summary>
            The NLP engine ...
            </summary>
            <summary>
            Continuation of NLP class
            </summary>
        </member>
        <member name="P:AboditNLP.NLP.DependencyResolver">
            <summary>
            For testing use only
            </summary>
        </member>
        <member name="M:AboditNLP.NLP.SetResolver(AboditNLP.IDependencyResolver)">
            <summary>
            Set an IOC resolver that will be used to create NLP Controllers
            and to satisfy dependencies they may need
            </summary>
            <remarks>
            This must be called prior to parsing any sentences
            This replaces MEF AND CommonServiceLocator with an approach like that used by WebAPI2
            </remarks>
            <param name="dependencyResolver">An IDependencyResolver, typically from an implementation using an iOC container like Autofac internally</param>
        </member>
        <member name="P:AboditNLP.NLP.Log">
            <summary>
            Gets the logger in use
            </summary>
        </member>
        <member name="M:AboditNLP.NLP.SetLogger(AboditNLP.ILogger)">
            <summary>
            Set a logger for NLP to use
            </summary>
            <remarks>
            Implement ILog and call into whatever logger you want to use
            </remarks>
            <param name="logger"></param>
        </member>
        <member name="P:AboditNLP.NLP.Options">
            <summary>
            Gets the options used by NLP parsing
            </summary>
        </member>
        <member name="M:AboditNLP.NLP.SetOptions(AboditNLP.NLPOptions)">
            <summary>
            Set the options used for NLP parsing
            </summary>
        </member>
        <member name="M:AboditNLP.NLP.#ctor(System.Collections.Generic.IEnumerable{AboditNLP.ILexemeGenerator},System.Collections.Generic.IEnumerable{AboditNLP.IGraphGenerator},System.Collections.Generic.IEnumerable{AboditNLP.ITokenFactory},AboditNLP.ILexemeStore)">
            <summary>
            Create a new instance of the NLP engine
            </summary>
        </member>
        <member name="F:AboditNLP.NLP.debugging">
            <summary>
            Initial state of the debug flag - TODO: MOVE THIS TO USER STATE
            </summary>
        </member>
        <member name="P:AboditNLP.NLP.Debugging">
            <summary>
            When debugging is on we explain what we are matching
            </summary>
        </member>
        <member name="P:AboditNLP.NLP.DebuggingDetail">
            <summary>
            Extra debug detail (only applies when Debugging is also true)
            </summary>
        </member>
        <member name="M:AboditNLP.NLP.DumpRules">
            <summary>
            For debugging
            </summary>
        </member>
        <member name="P:AboditNLP.NLP.Ready">
            <summary>
            Wait on this to know when NLP is ready for processing - make sure someone called Start first!
            </summary>
        </member>
        <member name="P:AboditNLP.NLP.LexemeStore">
            <summary>
            The LexemeStore contains the dictionary and thesaurus for an NLP application
            </summary>
            <remarks>
            You can also use the Lexeme store for autocomplete and other tasks
            </remarks>
        </member>
        <member name="M:AboditNLP.NLP.CheckDependencyResolver">
            <summary>
            Throws an exception if the dependency resolver has not been set
            </summary>
        </member>
        <member name="M:AboditNLP.NLP.Initialize">
            <summary>
            Synchronous initialization of NLP
            </summary>
        </member>
        <member name="M:AboditNLP.NLP.InitializeAsync">
            <summary>
            Async initialization of NLP, can call Wait on Task that comes back
            </summary>
        </member>
        <member name="M:AboditNLP.NLP.InitializeAsync(System.Threading.CancellationToken)">
            <summary>
            Async initialization of NLP, can call Wait on Task that comes back, cancellable (but initialization continues to run)
            </summary>
        </member>
        <member name="M:AboditNLP.NLP.Permute(System.Collections.Generic.IEnumerable{AboditNLP.Attributes.ParameterData})">
            <summary>
            Compute all possible permutations of the optional parameters
            </summary>
        </member>
        <member name="M:AboditNLP.NLP.Permute2(System.Collections.Generic.IEnumerable{AboditNLP.Attributes.ParameterData},System.Collections.Generic.IEnumerable{AboditNLP.Attributes.ParameterData})">
            <summary>
            Permute head - items already in order, tail - items yet to consider
            </summary>
        </member>
        <member name="M:AboditNLP.NLP.AddRule(System.Type,System.Reflection.MethodInfo,AboditNLP.Attributes.ParameterData[],System.Object[],System.Double)">
            <summary>
            Add a single ActionMethod rule
            </summary>
        </member>
        <member name="M:AboditNLP.NLP.AddProductionRule(System.Type,System.Reflection.MethodInfo,AboditNLP.Attributes.ParameterData[],System.Object[],System.Double)">
            <summary>
            Add a single production rule
            </summary>
        </member>
        <member name="M:AboditNLP.NLP.AddProductionRule``2(System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Int32,AboditNLP.Attributes.Associativity,System.Double)">
            <summary>
            Add a single production rule at runtime using an Expression
            </summary>
        </member>
        <member name="M:AboditNLP.NLP.AddProductionRule``3(System.Linq.Expressions.Expression{System.Func{``0,``1,``2}},System.Int32,AboditNLP.Attributes.Associativity,System.Double)">
            <summary>
            Add a single production rule at runtime using an Expression
            </summary>
        </member>
        <member name="M:AboditNLP.NLP.GetDefinition(AboditNLP.ITokenText)">
            <summary>
            The AboditNLP-Wordnet assembly includes resources with definitions for each Synset
            other lexeme generator assemblies can do this too
            </summary>
        </member>
        <member name="M:AboditNLP.NLP.GetDefinition(AboditNLP.SynSet)">
            <summary>
            The AboditNLP-Wordnet assembly includes resources with definitions for each Synset
            other lexeme generator assemblies can do this too
            </summary>
        </member>
        <member name="M:AboditNLP.NLP.Execute(System.String,System.Object[])">
            <summary>
            Returns true if it found and executed a rule
            If false, don't forget to tell the user that you don't know what they said.
            </summary>
            <remarks>
            Uses a dependency resolver to resolve any dependencies needed to
            satisfy the constructors on recognizer classes.  Optionally can also use any of the injectObjects
            passed to it to satisfy constructor parameters for cases where you are not using an IOC library
            or wish to inject per-call dependencies.
            </remarks>
        </member>
        <member name="M:AboditNLP.NLP.CreateCaller``1(System.Reflection.MethodInfo)">
            <summary>
            Get a compiled lambda expression for a MethodInfo (assuming its return type is T)
            </summary>
        </member>
        <member name="M:AboditNLP.NLP.CreateGeneric(System.Type,System.Type,System.Object[])">
            <summary>
            Create an instance of generic type matching the specified types
            </summary>
        </member>
        <member name="M:AboditNLP.NLP.ParseInputToGetTokens(AboditNLP.IDependencyScope,System.String)">
            <summary>
            Parse the input to get tokens
            </summary>
        </member>
        <member name="T:AboditNLP.NLPActionResult">
            <summary>
            Every Rule must return an NLPActionResult in order to be recognized as a rule
            Currently there is only one NLPActionResult and it's a do nothing else 
            In the future there might be others that allow other rules to also execute against the same input string
            e.g. lookup ...
            </summary>
        </member>
        <member name="P:AboditNLP.NLPActionResult.None">
            <summary>
            No further action required, the sentence has been dealt with
            </summary>
        </member>
        <member name="P:AboditNLP.NLPActionResult.Continue">
            <summary>
            Keep going, although we ran there might be another sentence that should also run (maybe we couldn't handle it)
            </summary>
        </member>
        <member name="T:AboditNLP.NLPOptions">
            <summary>
            NLP options
            </summary>
        </member>
        <member name="P:AboditNLP.NLPOptions.DefaultSensitivity">
            <summary>
            Set the default Sensitivity including case insensitivity, white space insensitivity, ...
            </summary>
        </member>
        <member name="F:AboditNLP.NLPOptions.Default">
            <summary>
            Default NLPOptions allows case insensitivity but no spelling mistakes
            </summary>
        </member>
        <member name="T:AboditNLP.PendingParse">
            <summary>
            A pending parse is used to drive the parse engine
            </summary>
            <remarks>
            Must be a class because it self-references
            </remarks>
        </member>
        <member name="P:AboditNLP.PendingParse.Previous">
            <summary>
            Get the linked previos pending parse
            </summary>
        </member>
        <member name="P:AboditNLP.PendingParse.CursorPosition">
            <summary>
            Get the cursor position at the end of this pending parse
            </summary>
        </member>
        <member name="P:AboditNLP.PendingParse.LastObject">
            <summary>
            Token found at last step
            </summary>
        </member>
        <member name="P:AboditNLP.PendingParse.PendingParsesReverse">
            <summary>
            Pending parses in reverse
            </summary>
        </member>
        <member name="P:AboditNLP.PendingParse.ObjectsReverse">
            <summary>
            Objects in reverse order
            </summary>
            <remarks>
            Skip the last null (went back to root node)
            </remarks>
        </member>
        <member name="P:AboditNLP.PendingParse.Objects">
            <summary>
            Objects in forward order
            </summary>
        </member>
        <member name="M:AboditNLP.PendingParse.GetLastTokens(System.Int32)">
            <summary>
            Get last n-steps in the token list
            </summary>
        </member>
        <member name="M:AboditNLP.PendingParse.TakeLast(System.Int32)">
            <summary>
            Get the tokens and ancestor by going by a number of steps
            </summary>
        </member>
        <member name="M:AboditNLP.PendingParse.SequenceEqual(AboditNLP.PendingParse)">
            <summary>
            Same tokens all the way back
            </summary>
        </member>
        <member name="P:AboditNLP.PendingParse.AlreadyVisited">
            <summary>
            Rule nodes that have already been visited from this point (used to prevent infinite recursion)
            </summary>
        </member>
        <member name="M:AboditNLP.PendingParse.ExtendAsShift(System.Int32,System.Object,AboditNLP.Rules.RuleNode,AboditNLP.Rules.RuleFound)">
            <summary>
            Extend a pending parse
            </summary>
        </member>
        <member name="M:AboditNLP.PendingParse.ExtendAsAReduction(System.Object,System.Int32,AboditNLP.Rules.RuleNode,System.Int32,AboditNLP.Rules.RuleFound)">
            <summary>
            Extend a pending parse with an object
            </summary>
        </member>
        <member name="P:AboditNLP.PendingParse.HighestPossibleScore">
            <summary>
            The highest possible score represents the highest score that could be achieved from this ruleNode
            </summary>
        </member>
        <member name="P:AboditNLP.PendingParse.Score">
            <summary>
            Actual score achieved - which is priority of final node plus any precedence gains made ???????????
            </summary>
        </member>
        <member name="M:AboditNLP.PendingParse.#ctor(AboditNLP.PendingParse,System.Int32,System.Object,System.Int32,AboditNLP.Rules.RuleNode,AboditNLP.Rules.RuleFound,System.String)">
            <summary>
            Extended
            </summary>
        </member>
        <member name="M:AboditNLP.PendingParse.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:AboditNLP.CompletedParse">
            <summary>
            A completed parse
            </summary>
        </member>
        <member name="P:AboditNLP.CompletedParse.Objects">
            <summary>
            The Tokens and other objects that were parsed from the input
            </summary>
        </member>
        <member name="P:AboditNLP.CompletedParse.RuleFound">
            <summary>
            The rule that was found
            </summary>
        </member>
        <member name="P:AboditNLP.CompletedParse.Score">
            <summary>
            The score for this parse
            </summary>
        </member>
        <member name="P:AboditNLP.CompletedParse.Probability">
            <summary>
            The probability for this parse
            </summary>
        </member>
        <member name="M:AboditNLP.CompletedParse.#ctor(System.Collections.Generic.IEnumerable{System.Object},AboditNLP.Rules.RuleFound,System.Double,System.Double)">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.CompletedParse"/> class
            </summary>
        </member>
        <member name="M:AboditNLP.CompletedParse.ToString">
            <summary>
            Returns a string representation
            </summary>
        </member>
        <member name="M:AboditNLP.Parser.Column.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:AboditNLP.Parser.ColumnStore">
            <summary>
            All of the columns for a parse
            </summary>
        </member>
        <member name="F:AboditNLP.Parser.ColumnStore.columns">
            <summary>
            The columns
            </summary>
        </member>
        <member name="P:AboditNLP.Parser.ColumnStore.Input">
            <summary>
            The complete input string
            </summary>
        </member>
        <member name="P:AboditNLP.Parser.ColumnStore.Item(System.Int32)">
            <summary>
            Get a column
            </summary>
        </member>
        <member name="P:AboditNLP.Parser.Hypothesis.ColumnIndex">
            <summary>
            The column where this hypothesis started
            </summary>
        </member>
        <member name="P:AboditNLP.Parser.Hypothesis.RuleNode">
            <summary>
            The RuleNode used by this Hypothesis
            </summary>
        </member>
        <member name="P:AboditNLP.Parser.Hypothesis.DotIndex">
            <summary>
            Index into the rule found's required token list
            </summary>
        </member>
        <member name="P:AboditNLP.Parser.Hypothesis.Score">
            <summary>
            Score so far
            </summary>
        </member>
        <member name="P:AboditNLP.Parser.Hypothesis.Probability">
            <summary>
            Probability so far
            </summary>
        </member>
        <member name="P:AboditNLP.Parser.Hypothesis.NextTypesNeeded">
            <summary>
            The next type needed to advance the 'dot' (a set of them)
            </summary>
        </member>
        <member name="M:AboditNLP.Parser.Hypothesis.Shift(AboditNLP.TokenResult,AboditNLP.Rules.ProductionRule,System.Boolean)">
            <summary>
            Extend a hypothesis parse by shifting a new token on
            </summary>
            <remarks>
            Builds a new hypothesis because we may generate several successors if a parse produces different tokens that all match the argument type needed
            </remarks>
        </member>
        <member name="P:AboditNLP.Parser.Hypothesis.CreatedBy">
            <summary>
            For precedence and priority we need to know what rule made us
            </summary>
        </member>
        <member name="P:AboditNLP.Parser.Hypothesis.CreatedByPrevious">
            <summary>
            And what the rule was before that
            </summary>
        </member>
        <member name="P:AboditNLP.Parser.Hypothesis.CreatedByPrevious2">
            <summary>
            And what the rule was before that
            </summary>
        </member>
        <member name="M:AboditNLP.Parser.Hypothesis.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="M:AboditNLP.Parser.Hypothesis.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:AboditNLP.AdjectiveGenerator">
            <summary>
            An adjective is a word whose main syntactic role is to qualify a noun or noun phrase, giving more information about the object signified.
            </summary>
            <remarks>
            See http://www-users.cs.york.ac.uk/susan/cyc/a/adj.htm which explains the order in which adjectives should appear
            
              Opinion or judgment -- beautiful, ugly, easy, fast, interesting
              Size -- small, tall, short, big
              Age -- young, old, new, historic, ancient
              Shape -- round, square, rectangular
              Color -- red, black, green, purple
              Nationality -- French, Asian, American, Canadian, Japanese
              Material -- wooden, metallic, plastic, glass, paper
              Purpose or Qualifier -- foldout sofa, fishing boat, racing car
            
            </remarks>
        </member>
        <member name="T:AboditNLP.Adjective.Appearance.BadAppearanceType">
            <summary>
            An adjective that describes a bad appearance
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Appearance.GoodAppearanceType">
            <summary>
            An adjective that describes a good appearance
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.true">
            <summary>
            True, adjective
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.false">
            <summary>
            False, adjective
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.null">
            <summary>
            null, adjective
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.ascendingOrDescending">
            <summary>
            ascending or descending
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.ascending">
            <summary>
            ascending
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.descending">
            <summary>
            descending
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.inverse">
            <summary>
            inverse (or reverse)
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Condition.BadCondition">
            <summary>
            An adjective class representing a bad condition
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Condition.GoodCondition">
            <summary>
            An adjective class representing a good condition
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Condition.PositiveCondition">
            <summary>
            An adjective class representing a positive condition
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Condition.NegativeCondition">
            <summary>
            An adjective class representing a negative condition
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Condition.named">
            <summary>
            The adjective 'named', e.g. a named user
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Condition.concurrent">
            <summary>
            concurrent, adjective
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Condition.active">
            <summary>
            active, adjective
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.FeelingOrPersonality.Neutral">
               Opinion or judgment -- beautiful, ugly, easy, fast, interesting
            <summary>
             Adjective expressing a neutral feeling
             </summary>
        </member>
        <member name="T:AboditNLP.Adjective.FeelingOrPersonality.Good">
            <summary>
            Adjective expressing a good feeling
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.FeelingOrPersonality.Bad">
            <summary>
            Adjective expressing a bad feeling
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Personality.Neutral">
            <summary>
            Adjective describing a neutral personality
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Personality.Good">
            <summary>
            Adjective describing a good personality
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Personality.Bad">
            <summary>
            Adjective describing a bad personality
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Feeling.Good">
            <summary>
            Adjective describing a good feeling
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Feeling.Bad">
            <summary>
            Adjective describing a bad feeling
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Feeling.Tired">
            <summary>
            Adjective describing a tired feeling
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Feeling.Happy">
            <summary>
            Adjective describing a happy feeling
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Feeling.Sad">
            <summary>
            Adjective describing a sad feeling
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Feeling.Angry">
            <summary>
            Adjective describing an angry feeling
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Feeling.Pleasant">
            <summary>
            Adjective describing a pleasant feeling
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Health.Good">
            <summary>
            Adjectives that refer to good health
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Health.Bad">
            <summary>
            Adjectives that refer to poor health
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.first">
            <summary>
            first, adjective
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.second">
            <summary>
            second, adjective
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.third3">
            <summary>
            third, adjective
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.fourth">
            <summary>
            fourth, adjective
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.fifth">
            <summary>
            fifth, adjective
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.sixth">
            <summary>
            sixth, adjective
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.seventh">
            <summary>
            seventh, adjective
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.eighth">
            <summary>
            eigth, adjective
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.ninth">
            <summary>
            ninth, adjective
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.tenth">
            <summary>
            Tenth in order
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.onetenth">
            <summary>
            One tenth as a fraction
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.eleventh">
            <summary>
            Eleventh in order
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.twelfth">
            <summary>
            Twelfth in order
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.thirteenth">
            <summary>
            Thirteenth in order
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.fourteenth">
            <summary>
            Fourteenth in order
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.fifteenth">
            <summary>
            Fifteenth in order
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.sixteenth">
            <summary>
            Sixteenth in order
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.seventeenth">
            <summary>
            Seventeenth in order
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.eighteenth">
            <summary>
            Eithteenth in order
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.nineteenth">
            <summary>
            Nineteenth in order
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.twentieth">
            <summary>
            Twentieth in order
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.thirtieth">
            <summary>
            Thirtieth in order
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.fortieth">
            <summary>
            Fourtieth in order
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.fiftieth">
            <summary>
            Fiftieth in order
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.sixtieth">
            <summary>
            Sixtieth in order
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.seventieth">
            <summary>
            Seventieth in order
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.eightieth">
            <summary>
            Eigtieth in order
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.ninetieth">
            <summary>
            Nonetieth in order
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.hundredth">
            <summary>
            Hundredth in order
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.thousandth">
            <summary>
            Thousandth in order
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.millionth">
            <summary>
            Millionth in order
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.thisOrTheCurrent">
            <summary>
            This or the current in order
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.theCurrent">
            <summary>
            The current
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.this">
            <summary>
            This
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.last">
            <summary>
            Last in order
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.top">
            <summary>
            top, adjective
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.bottom">
            <summary>
            bottom, adjective
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.initial">
            <summary>
            initial, first adjective
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.next">
            <summary>
            Next in order
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.previous">
            <summary>
            Previous in order
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.on">
            <summary>
            on
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.off">
            <summary>
            off
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.all">
            <summary>
            all
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.every">
            <summary>
            every
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.big">
            <summary>
            big, more, greater, longer, over, ... most
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.small">
            <summary>
            less, smaller, under, ... least
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.long_time">
            <summary>
            long as a temporal, e.g. a long wait
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.long_distance">
            <summary>
            long as a distance, e.g. a long window
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.long_driving_distance">
            <summary>
            Long as a driving distance, e.g. a long way to go
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.average">
            <summary>
            average, adjective
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.difference">
            <summary>
            difference, adjective
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.metric">
            <summary>
            metric, adjective
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.imperial">
            <summary>
            imperial, adjective
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.Comparable">
            <summary>
            Adjectives and adverbs can be comparable (having comparative and superlative forms, the default) or Uncomparable (e.g. annual, first, extra, satin, six-figure)
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.Uncomparable">
            <summary>
            Adjectives and adverbs can be comparable (having comparative and superlative forms, the default) or Uncomparable (e.g. annual, first, extra, satin, six-figure)
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.Normal">
            <summary>
            Neither comparative nor superlative
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.Comparative">
            <summary>
            The Comparative form of an adjective
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.Superlative">
            <summary>
            The Superlative form of an adjective
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.ConditionType">
            <summary>
            An adjective desribing the condition of something
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.BadType">
            <summary>
            An adjective describing a bad condition
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.GoodType">
            <summary>
            An adjective describing a good condition
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.PositiveType">
            <summary>
            An adjective describing a positive condition
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.NegativeType">
            <summary>
            An adjective describing a negative condition
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.OccupiedType">
            <summary>
            An adjective describing an occupied condition
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.NotOccupiedType">
            <summary>
            An adjective describing a vacant condition
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.AgeType">
              Age -- young, old, new, historic, ancient
        </member>
        <member name="T:AboditNLP.Adjective.Type.AmplifierType">
            <summary>
            Amplifies another adjective
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.ComparisonType">
            <summary>
            An adjective that is a mathematical operator: less than, greater than ...
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.SmallType">
            <summary>
            An adjective that means something is small, smaller, less, few, ...
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.LargeType">
            <summary>
            An Adjective that means something is more, greater, ...
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.ChemicalType">
            <summary>
            An adjective describing a chemical
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.ColorType">
            <summary>
            An adjective describing a color
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.LocationType">
            <summary>
            An adjective describing a location type
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.OrdinalType">
            <summary>
            An adjective describing an ordinal type
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.OrdinalUnits">
            <summary>
            first, second, ... ninth (can be prefixed with an OrdinalTens)
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.OrdinalTeens">
            <summary>
            eleven ... nineteenth (cannot be prefixed with an OrdinalTens)
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.OrdinalTerminator">
            <summary>
            Any ordinal ending -th
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.OrdinalDecade">
            <summary>
            Special ordinals: hundredth, thousandth, millionth
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.OrdinalPosition">
            <summary>
            first, last, next, previous, subsequent
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.PriceType">
            <summary>
            An adjective describing a price
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.PriceHighType">
            <summary>
            An adjective describing a high price
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.PriceLowType">
            <summary>
            An adjective describing a low price
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.QuanityType">
            <summary>
            An adjective describing a quantity
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.QuantityManyType">
            <summary>
            An adjective describing a quantity of many
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.QuantityFewType">
            <summary>
            An adjective describing a quantity of few
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.SizeType">
              Size -- small, tall, short, big
            An adjective describing a size
        </member>
        <member name="T:AboditNLP.Adjective.Type.SizeLargeType">
            <summary>
            An adjective describing a large size
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.SizeSmallType">
            <summary>
            An adjective describing a small size
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.SizeTallType">
            <summary>
            An adjective describing a tall size
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.SmellType">
            <summary>
            An adjective describing a smell
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.SmellBadType">
            <summary>
            An adjective describing a bad smell
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.SmellGoodType">
            <summary>
            An adjective describing a good smell
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.ShapeType">
              Shape -- round, square, rectangular
            <summary>
            An adjective describing a shape
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.SpaceType">
            <summary>
            An adjective describing a space
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.SoundType">
            <summary>
            An adjective describing a sound
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.TasteType">
            <summary>
            An adjective describing a taste
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.TasteGoodType">
            <summary>
            An adjective describing a good taste
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.TasteBadType">
            <summary>
            An adjective describing a bad taste
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.TasteOrSmellType">
            <summary>
            An adjective describing a smell or taste
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.TasteOrSmellGoodType">
            <summary>
            An adjective describing a good smell or taste
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.TasteOrSmellBadType">
            <summary>
            An adjective describing a bad smell or taste
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.TextureType">
            <summary>
            An adjective describing a texture
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.TouchType">
            <summary>
            An adjective describing a touch
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.TouchOrTextureType">
            <summary>
            An adjective describing a touch or texture
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.TemperatureType">
            <summary>
            An adjective describing a temperature
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.TemperatureHotType">
            <summary>
            An adjective describing a hot temperature
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.TemperatureModerateType">
            <summary>
            An adjective describing a moderate temperature
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.TemperatureColdType">
            <summary>
            An adjective describing a cold temperature
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.TemperatureHotterType">
            <summary>
            An adjective describing a hotter temperature
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.TemperatureColderType">
            <summary>
            An adjective describing a colder temperature
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.TemporalType">
            <summary>
            An adjective describing a temporal
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.WeatherType">
            <summary>
            An adjective describing the weather
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.MeasurementType">
            <summary>
            An adjective describing a measurement
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.QuantityQualifierType">
            <summary>
            An adjective describing a quantity
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.NationalityType">
            <summary>
            An adjective describing a nationality
            </summary>
        </member>
        <member name="T:AboditNLP.Adjective.Type.CuisineType">
            <summary>
            An adjective describing a cuisine
            </summary>
        </member>
        <member name="T:AboditNLP.PartsOfSpeech.Adjectives.Synsets">
            <summary>
            Predefined Synsets (an experimental feature)
            </summary>
        </member>
        <member name="F:AboditNLP.PartsOfSpeech.Adjectives.Synsets.Black">
            <summary>
            Synset for black, adjective
            </summary>
        </member>
        <member name="F:AboditNLP.PartsOfSpeech.Adjectives.Synsets.White">
            <summary>
            Synset for white, adjective
            </summary>
        </member>
        <member name="F:AboditNLP.PartsOfSpeech.Adjectives.Synsets.Width">
            <summary>
            Synset for width, noun
            </summary>
        </member>
        <member name="F:AboditNLP.PartsOfSpeech.Adjectives.Synsets.Wide">
            <summary>
            Synset for wide, adjective
            </summary>
        </member>
        <member name="F:AboditNLP.PartsOfSpeech.Adjectives.Synsets.Wider">
            <summary>
            Synset for wider, adjective
            </summary>
        </member>
        <member name="F:AboditNLP.PartsOfSpeech.Adjectives.Synsets.Widest">
            <summary>
            Synset for widest, adjective
            </summary>
        </member>
        <member name="F:AboditNLP.PartsOfSpeech.Adjectives.Synsets.Narrow">
            <summary>
            Synset for narrow, adjective
            </summary>
        </member>
        <member name="F:AboditNLP.PartsOfSpeech.Adjectives.Synsets.High">
            <summary>
            Synset for high, adjective
            </summary>
        </member>
        <member name="M:AboditNLP.PartsOfSpeech.Adjectives.Synsets.RelateAdjectives(AboditNLP.SynSet,AboditNLP.SynSet,AboditNLP.SynSet,AboditNLP.SynSet)">
            <summary>
            Add all the relationships between adjectives and other word forms
            </summary>
        </member>
        <member name="T:AboditNLP.IAdjective">
            <summary>
            An Adjective is a word used to describe, or modify, a noun or a pronoun. An adjective describes "what kind," "which one," "how many," or "how much".
            An adjective is a word whose main syntactic role is to qualify a noun or noun phrase, giving more information about the object signified.
            </summary>
        </member>
        <member name="P:AboditNLP.IAdjective.Normal">
            <summary>
            The normal form of an adjective
            </summary>
        </member>
        <member name="P:AboditNLP.IAdjective.Comparative">
            <summary>
            The comparative form of an adjective
            </summary>
        </member>
        <member name="P:AboditNLP.IAdjective.Superlative">
            <summary>
            The superlative form of an adjective
            </summary>
        </member>
        <member name="T:AboditNLP.IAdjectivesatellite">
            <summary>
            WordNet has Adjectives and AdjectiveSatellites - see WordNet documentation for details
            We map IAdjectiveSatellite as a subtype of IAdjective
            </summary>
        </member>
        <member name="T:AboditNLP.IAdverb">
            <summary>
            An Adverb is a word used to describe, or modify, a verb, an adjective, or another adverb. An adverb describes how, when, where, or to what extent the verb performs.
            </summary>
        </member>
        <member name="T:AboditNLP.Adverb.Comparable">
            <summary>
            Adjectives and adverbs can be comparable (having comparative and superlative forms, the default) or Uncomparable (e.g. annual, first, extra, satin, six-figure)
            </summary>
        </member>
        <member name="T:AboditNLP.Adverb.Uncomparable">
            <summary>
            Adjectives and adverbs can be comparable (having comparative and superlative forms, the default) or Uncomparable (e.g. annual, first, extra, satin, six-figure)
            </summary>
        </member>
        <member name="T:AboditNLP.Adverb.ago">
            <summary>
            ago
            </summary>
        </member>
        <member name="T:AboditNLP.Adverb.now">
            <summary>
            now
            </summary>
        </member>
        <member name="T:AboditNLP.Adverb.since">
            <summary>
            since
            </summary>
        </member>
        <member name="T:AboditNLP.Adverb.there">
            <summary>
            since
            </summary>
        </member>
        <member name="T:AboditNLP.ICombiningForm">
            <summary>
            A linguistic element used in conjunction with another element to form a word (e.g. Anglo-, bio-, mega-, ...)
            </summary>
        </member>
        <member name="T:AboditNLP.IConjunction">
            <summary>
            A Conjunction is a word that connects other words or groups of words to each other. 
            There are three types of conjunctions: coordinating, subordinating, and correlative.
            </summary>
        </member>
        <member name="T:AboditNLP.Article.Definite">
            <summary>
            A definite article indicates that its noun is a particular one (or ones) identifiable to the listener. It may be the same thing that the speaker has already mentioned, or it may be something uniquely specified. The definite article in English is the.
            </summary>
        </member>
        <member name="T:AboditNLP.Article.Indefinite">
            <summary>
            An indefinite article indicates that its noun is not a particular one (or ones) identifiable to the listener. It may be something that the speaker is mentioning for the first time, or its precise identity may be irrelevant or hypothetical, or the speaker may be making a general statement about any such thing. English uses a/an, from the Old English forms of the number 'one', as its indefinite article. The form an is used before words that begin with a vowel sound (even if spelled with an initial consonant, as in an hour), and a before words that begin with a consonant sound (even if spelled with a vowel, as in a European).
            </summary>
        </member>
        <member name="T:AboditNLP.Article.Partitative">
            <summary>
            A partitive article is a type of indefinite article used with a mass noun such as water, to indicate a non-specific quantity of it. Partitive articles are used in French and Italian in addition to definite and indefinite articles. The nearest equivalent in English is some, although this is considered a determiner and not an article.
            </summary>
        </member>
        <member name="T:AboditNLP.Article.Negative">
            <summary>
            Negative article: A negative article specifies none of its noun, and can thus be regarded as neither definite nor indefinite. On the other hand, some consider such a word to be a simple determiner rather than an article. In English, this function is fulfilled by no.
            </summary>
        </member>
        <member name="T:AboditNLP.Article.zero">
            <summary>
            The zero article is the absence of an article. In languages having a definite article, the lack of an article specifically indicates that the noun is indefinite. Linguists interested in X-bar theory causally link zero articles to nouns lacking a determiner.[7] In English, the zero article rather than the indefinite is used with plurals and mass nouns, although the word "some" can be used as an indefinite plural article.
            </summary>
        </member>
        <member name="T:AboditNLP.IDeterminer">
            <summary>
            A determiner establishes the reference of a noun or noun-phrase, including quantity, 
            rather than its attributes as expressed by adjectives. Despite this tendency, 
            determiners have a variety of functions including, in English, modifiers in
            adjective phrases and determiner phrases, and even markers of coordination.
            
            This word class, or part of speech, exists in many languages, including English, 
            though most English dictionaries still classify determiners under other parts of speech.
            Determiners usually include articles, and may include items like demonstratives, 
            possessive determiners, quantifiers, and cardinal numbers, depending on the language.
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.Alternative">
            <summary>
            e.g. another, other, somebody else, different
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.Article">
            <summary>
            Articles: a, an, the
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.CardinalNumber">
            <summary>
            Cardinal numbers: zero, one, two, fifty, infinite, etc.
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.Degree">
            <summary>
            Degree determiners/Partitive determiners: many, much, few, little, couple, several, most
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.Demonstrative">
            <summary>
            this, that, these, those, which
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.Disjunctive">
            <summary>
            Either, neither
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.Distributive">
            <summary>
            Each, every
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.Elective">
            <summary>
            Any, either, whichever
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.Equative">
            <summary>
            The same
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.Evaluative">
            <summary>
            Such, that, so
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.Exclamative">
            <summary>
            What eyes!
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.Existential">
            <summary>
            Some, any
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.Multal">
            <summary>
            : a lot of, many, several, much
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.Negative">
            <summary>
            : no, neither
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.Paucal">
            : a few, a little, some
        </member>
        <member name="T:AboditNLP.Determiner.Personal">
            <summary>
            : we teachers, you guys
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.Possessive">
            <summary>
            my, your, our, his, her, etc.
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.Quantifiers">
            <summary>
             all, few, many, several, some, every, each, any, no, etc.
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.Sufficiency">
            <summary>
            : enough, sufficient, plenty
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.Uniquitive">
            <summary>
            : the only
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.Universal">
            <summary>
            : all, both
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.Definite">
            <summary>
                , which limit their reference back to a specific already-established entity. (cardinals, demonstratives, equatives, evaluatives, exclamatives, relatives, personals, possessives, uniquitives)
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.Indefinite">
            <summary>
            , which broaden their referent to one not previously specified, otherwise newly introduced into discourse. (disjunctives, electives, existentials,public interface  interrogatives, negatives, universals)
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.my">
            <summary>
            The determiner my
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.your">
            <summary>
            The determiner  your
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.his">
            <summary>
            The determiner his
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.her">
            <summary>
            The determiner her
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.its">
            <summary>
            The determiner its
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.our">
            <summary>
            The determinerour
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.their">
            <summary>
            The determiner their
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.ones">
            <summary>
            The determiner one's
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.INumber">
            <summary>
            A number is a determiner
            </summary>
        </member>
        <member name="P:AboditNLP.Determiner.INumber.Cardinal">
            <summary>
            The cardinal word
            </summary>
        </member>
        <member name="P:AboditNLP.Determiner.INumber.Ordinal">
            <summary>
            The ordinal word
            </summary>
        </member>
        <member name="P:AboditNLP.Determiner.INumber.Fraction">
            <summary>
            The fraction
            </summary>
        </member>
        <member name="P:AboditNLP.Determiner.INumber.FractionPlural">
            <summary>
            The plural fraction
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.IWholeNumber">
            <summary>
            A whole number
            </summary>
        </member>
        <member name="P:AboditNLP.Determiner.IWholeNumber.ValueLong">
            <summary>
            The value
            </summary>
        </member>
        <member name="T:AboditNLP.Determiner.IFraction">
            <summary>
            A fraction
            </summary>
        </member>
        <member name="P:AboditNLP.Determiner.IFraction.Numerator">
            <summary>
            The numerator of the fraction
            </summary>
        </member>
        <member name="P:AboditNLP.Determiner.IFraction.Denominator">
            <summary>
            The denominator of the fraction
            </summary>
        </member>
        <member name="P:AboditNLP.Determiner.IFraction.ValueDouble">
            <summary>
            The value
            </summary>
        </member>
        <member name="T:AboditNLP.FluentBuilder">
            <summary>
            The head of a fluent builder - this is our SYNSET for NOUNs, VERBS, ADJECTIVES and ADVERBS and the relationships between them
            </summary>
            <summary>
            The head of a fluent builder - this is our SYNSET for NOUNs, VERBS, ADJECTIVES and ADVERBS and the relationships between them
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Adjective(System.String,System.Type[])">
            <summary>
            Build an Adjective
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Adjective(System.String,System.String,System.Type[])">
            <summary>
            Build an adjective
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Adjective(System.String,System.String,System.String,System.Type[])">
            <summary>
            Build an Adjective
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Adjective(System.String,System.String,System.String,System.String,System.Type[])">
            <summary>
            Complete definition of an adjective with same interfaces on each (and same synset)
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Adjective(System.String,System.String,System.String,System.String,System.String,System.String,System.Type[])">
            <summary>
            Complete definition of an adjective with same interfaces on each (and same synset)
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Number(System.Int32)">
            <summary>
            Build a number
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Cardinal(System.String,System.Type[])">
            <summary>
            Build a number
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Cardinal(System.String,System.String,System.Type[])">
            <summary>
            Build a number
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Ordinal(System.String,System.Type)">
            <summary>
            Build a number
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Ordinal(System.String,System.String,System.Type)">
            <summary>
            Build a number
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Rational(System.String,System.Int32,System.Int32,System.Type[])">
            <summary>
            Build a number
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Rational(System.String,System.String,System.Int32,System.Int32,System.Type[])">
            <summary>
            Build a number
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Noun(System.String,System.Type[])">
            <summary>
            Build a noun with an automatically generated plural
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Noun(System.String,System.String,System.Type[])">
            <summary>
            Build a noun
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.NounNoPlural(System.String,System.String,System.Type[])">
            <summary>
            Build a noun with no plural
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.NounWithPlural(System.String,System.String,System.Type[])">
            <summary>
            Build a noun
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.NounWithPlural(System.String,System.String,System.String,System.Type[])">
            <summary>
            Build a noun
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.NounWithAllForms(System.String,System.String,System.String,System.String,System.Type[])">
            <summary>
            Build a noun
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.NounWithAllForms(System.String,System.String,System.String,System.String,System.String,System.Type[])">
            <summary>
            Build a noun
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Singular(System.String,System.Type[])">
            <summary>
            Build a noun
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Plural(System.String,System.Type[])">
            <summary>
            Build a noun
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Plural(System.String,System.String,System.Type[])">
            <summary>
            Build a noun
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.SingularPossessive(System.String,System.Type[])">
            <summary>
            Build a noun
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.PluralPossessive(System.String,System.Type[])">
            <summary>
            Build a noun
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.CollectiveNoun(System.String,System.Type[])">
            <summary>
            Build a collective noun
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.CheckNounValidity(System.String,System.Type[])">
            <summary>
            Checks that the word and the interfaces are valid as a Noun
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Extend``1(``0[],``0)">
            <summary>
            Extend an array by one element in an immutable fashion
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Verb(System.String,System.Type[])">
            <summary>
            Build a verb
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Verb(System.String,System.String,System.Type[])">
            <summary>
            Build a verb
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Infinitive(System.String,System.Type[])">
            <summary>
            Build a verb
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Infinitive(System.String,System.String,System.Type[])">
            <summary>
            Build a verb
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Regular">
            <summary>
            Build a verb
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Irregular">
            <summary>
            Build a verb
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.PresentSelf(System.String,System.Type[])">
            <summary>
            Build a verb
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.PresentThirdPerson(System.String,System.Type[])">
            <summary>
            Build a verb
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.PresentPlural(System.String,System.Type[])">
            <summary>
            Build a verb
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Past(System.String,System.Type[])">
            <summary>
            Sets the PAST and the PAST PLURAL and the PAST PARTICIPLE for a verb
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.PastPlural(System.String,System.Type[])">
            <summary>
            Build a verb
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.PresentParticiple(System.String,System.Type[])">
            <summary>
            Build a verb
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.PastParticiple(System.String,System.Type[])">
            <summary>
            Build a verb
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Future(System.String,System.Type[])">
            <summary>
            Build a verb
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.CheckVerbValidity(System.String,System.Type[])">
            <summary>
            Checks that the word and the interfaces are valid as a Verb
            </summary>
        </member>
        <member name="P:AboditNLP.FluentBuilder.New">
            <summary>
            Start a new FluentBuilderr
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.#ctor">
            <summary>
            Create a new FluentBuilder
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.CreateQuestion(System.String,System.Type[])">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.LexQuestion"/> class
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.CreatePunctuation(System.String,System.Type[])">
            <summary>
            Build punctuation
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.CreatePunctuation(System.String,System.String,System.Type[])">
            <summary>
            Build punctuation
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.CreateConjunction(System.String,System.Type[])">
            <summary>
            Build a conjunction
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.CreateConjunction(System.String,System.String,System.Type[])">
            <summary>
            Build a conjunction
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.CreateInterjection(System.String,System.Type[])">
            <summary>
            Build an interjection
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.CreateInterjection(System.String,System.String,System.Type[])">
            <summary>
            Build an interjection
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.CreateContraction(System.String,System.String,System.Type[])">
            <summary>
            Build a contraction
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.CreateNoun(System.String,System.Type[])">
            <summary>
            Build a noun with an automatically generated plural, possessive etc.
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.CreateNoun(System.String,System.String,System.Type[])">
            <summary>
            Build a noun with an automatically generated plural, possessive etc.
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.CreateVerb(System.String,System.Type[])">
            <summary>
            Build a verb with automatically generated forms
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.CreateVerb(System.String,System.String,System.Type[])">
            <summary>
            Build a verb with automaticaly generated forms
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.CreateVerb(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Type[])">
            <summary>
            Build a verb with automaticaly generated forms
            </summary>
        </member>
        <member name="F:AboditNLP.FluentBuilder.NounForm">
            <summary>
            The Noun form
            </summary>
        </member>
        <member name="F:AboditNLP.FluentBuilder.VerbForm">
            <summary>
            The Verb form
            </summary>
        </member>
        <member name="F:AboditNLP.FluentBuilder.AdjectiveNormalForm">
            <summary>
            The Adjective form
            </summary>
        </member>
        <member name="F:AboditNLP.FluentBuilder.AdjectiveComparativeForm">
            <summary>
            The Adjective Comparative form
            </summary>
        </member>
        <member name="F:AboditNLP.FluentBuilder.AdjectiveSuperlativeForm">
            <summary>
            The Adjective Superlative form
            </summary>
        </member>
        <member name="F:AboditNLP.FluentBuilder.AdverbForm">
            <summary>
            The Adverb form
            </summary>
        </member>
        <member name="F:AboditNLP.FluentBuilder.CardinalForm">
            <summary>
            The Cardinal Form
            </summary>
        </member>
        <member name="F:AboditNLP.FluentBuilder.CardinalPluralForm">
            <summary>
            The Cardinal Plural form
            </summary>
        </member>
        <member name="F:AboditNLP.FluentBuilder.OrdinalForm">
            <summary>
            The Ordinal form
            </summary>
        </member>
        <member name="F:AboditNLP.FluentBuilder.FractionalForm">
            <summary>
            The Fractional form
            </summary>
        </member>
        <member name="F:AboditNLP.FluentBuilder.FractionalPluralForm">
            <summary>
            The fractional plural form
            </summary>
        </member>
        <member name="F:AboditNLP.FluentBuilder.Other">
            <summary>
            Some other form of related word
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Adverb(System.String,System.Type[])">
            <summary>
            Build an adverb
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Adverb(System.String,System.String,System.Type[])">
            <summary>
            Build an adverb
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Determiner(System.String,System.Type[])">
            <summary>
            Build a determiner
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Determiner(System.String,System.String,System.Type[])">
            <summary>
            Build a determiner
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Article(System.String,System.Type[])">
            <summary>
            Build an article (a, an, the, ...)
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Article(System.String,System.String,System.Type[])">
            <summary>
            Build an article (a, an, the, ...)
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Preposition(System.String,System.Type[])">
            <summary>
            Build a prepostion
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Preposition(System.String,System.String,System.Type[])">
            <summary>
            Build a prepostion
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Punctuation(System.String,System.Type[])">
            <summary>
            Build punctuation
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Punctuation(System.String,System.String,System.Type[])">
            <summary>
            Build punctuation
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Question(System.String,System.Type[])">
            <summary>
            Build a question word
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Question(System.String,System.String,System.Type[])">
            <summary>
            Build q question
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.SetAllLinks">
            <summary>
            Set all links between word forms
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.GetWords">
            <summary>
            Get all the words in this synset - go up to Head to get it
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.GetWordsSingle">
            <summary>
            Get all the words, remember to filter out duplicates
            </summary>
            <returns></returns>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Add(AboditNLP.Lexeme)">
            <summary>
            Add any Lexeme type including new ones you might invent - could replace any of the singles with this (e.g. Preposition, Article, ...)
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.Harmonize">
            <summary>
            Adds relationships to the graph for adjective forms
            </summary>
        </member>
        <member name="M:AboditNLP.FluentBuilder.ToString">
            <summary>
            Returns a string representing this object
            </summary>
        </member>
        <member name="T:AboditNLP.IInterjection">
            <summary>
            An Interjection is a word used to express emotion that has no grammatical relationship to other words in the sentence. Interjections should be used sparingly and usually only belong in narrative dialogue.
            </summary>
        </member>
        <member name="T:AboditNLP.IToken">
            <summary>
            A Token (word with meaning), base interface used by most Lexemes and other tokens
            </summary>
        </member>
        <member name="T:AboditNLP.ITokenPredefinedExpression">
            <summary>
            A predefined expression, e.g. late = after 9AM
            </summary>
        </member>
        <member name="T:AboditNLP.ITokenText">
            <summary>
            A token with a single text representation (no alternate forms like singular, plural, ...)
            </summary>
        </member>
        <member name="P:AboditNLP.ITokenText.Text">
            <summary>
            Get the original text
            </summary>
        </member>
        <member name="P:AboditNLP.ITokenText.Synset">
            <summary>
            Get the Synset (if any) for this token
            </summary>
        </member>
        <member name="T:AboditNLP.IWordBuilderComplete">
            <summary>
            An interface for building words after committing to a type of word (noun, verb, ...)
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilderComplete.GetWords">
            <summary>
            Gets all the lexemes in the current word graph
            </summary>
        </member>
        <member name="T:AboditNLP.IWordBuilder">
            <summary>
            An interface for building words
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.Adjective(System.String,System.Type[])">
            <summary>
            Add an adjective to the current word graph
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.Adjective(System.String,System.String,System.Type[])">
            <summary>
            Add an adjective to the current word graph
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.Adjective(System.String,System.String,System.String,System.Type[])">
            <summary>
            Adds an adjective to the current word graph with normal, comparative, superlative forms
            </summary>
            <param name="normal">The normal form of the adjective</param>
            <param name="comparative">The comparative form of the adjective</param>
            <param name="superlative">The superlative form of the adjective</param>
            <param name="extraTypes">A list of interfaces that apply to the normal, comparative and superlative forms</param>
            <returns>A word builder</returns>
        </member>
        <member name="M:AboditNLP.IWordBuilder.Adjective(System.String,System.String,System.String,System.String,System.Type[])">
            <summary>
            Add an adjective
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.Adjective(System.String,System.String,System.String,System.String,System.String,System.String,System.Type[])">
            <summary>
            Add an adjective
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.Number(System.Int32)">
            <summary>
            Adds a number to the current word graph
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.Rational(System.String,System.Int32,System.Int32,System.Type[])">
            <summary>
            Adds a rational number to the current word graph
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.Rational(System.String,System.String,System.Int32,System.Int32,System.Type[])">
            <summary>
            Adds a rational number to the current word graph
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.Verb(System.String,System.Type[])">
            <summary>
            Adds a regular verb to the current word graph, generating all of the tenses automatically
            </summary>
            <param name="infinitive">the infinitive form of the verb</param>
            <param name="infinitiveTypes">A list of interfaces that apply to all tenses of the verb</param>
            <returns></returns>
        </member>
        <member name="M:AboditNLP.IWordBuilder.Verb(System.String,System.String,System.Type[])">
            <summary>
            Add a verb to the current word graph
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.Noun(System.String,System.Type[])">
            <summary>
            Add a noun to the current word graph
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.Noun(System.String,System.String,System.Type[])">
            <summary>
            Add a noun to the current word graph
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.NounNoPlural(System.String,System.String,System.Type[])">
            <summary>
            Add an uncountable noun to the current word graph. Uncountable nouns have no plural.
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.NounWithPlural(System.String,System.String,System.String,System.Type[])">
            <summary>
            Add a noun to the current word graph
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.NounWithAllForms(System.String,System.String,System.String,System.String,System.Type[])">
            <summary>
            Add a noun to the current word graph
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.NounWithAllForms(System.String,System.String,System.String,System.String,System.String,System.Type[])">
            <summary>
            Add a noun to the current word graph
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.CollectiveNoun(System.String,System.Type[])">
            <summary>
            Add a collective noun to the current word graph
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.Adverb(System.String,System.Type[])">
            <summary>
            Add an adverb to the current word graph
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.Adverb(System.String,System.String,System.Type[])">
            <summary>
            Add an adverb to the current word graph
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.Article(System.String,System.Type[])">
            <summary>
            Add an article to the current word graph
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.Article(System.String,System.String,System.Type[])">
            <summary>
            Add an article to the current word graph
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.Determiner(System.String,System.Type[])">
            <summary>
            Add a determiner to the current word graph
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.Determiner(System.String,System.String,System.Type[])">
            <summary>
            Add a determiner to the current word graph
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.Preposition(System.String,System.Type[])">
            <summary>
            Add a preposition to the current word graph
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.Preposition(System.String,System.String,System.Type[])">
            <summary>
            Add a preposition to the current word graph
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.Punctuation(System.String,System.Type[])">
            <summary>
            Add a punctuation mark to the current word graph
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.Punctuation(System.String,System.String,System.Type[])">
            <summary>
            Add a punctuation mark to the current word graph
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.Question(System.String,System.Type[])">
            <summary>
            Add a question word to the current word graph
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.Question(System.String,System.String,System.Type[])">
            <summary>
            Add a question word to the current word graph
            </summary>
        </member>
        <member name="M:AboditNLP.IWordBuilder.Add(AboditNLP.Lexeme)">
            <summary>
            Add a Lexeme to the current graph
            </summary>
        </member>
        <member name="T:AboditNLP.IVerbBuilder">
            <summary>
            An interface for building verbs
            </summary>
        </member>
        <member name="M:AboditNLP.IVerbBuilder.Infinitive(System.String,System.Type[])">
            <summary>
            Adds the infinitive form of a verb
            </summary>
        </member>
        <member name="M:AboditNLP.IVerbBuilder.PresentSelf(System.String,System.Type[])">
            <summary>
            Add the present self form of a verb
            </summary>
        </member>
        <member name="M:AboditNLP.IVerbBuilder.PresentThirdPerson(System.String,System.Type[])">
            <summary>
            Add the present third person form of a verb
            </summary>
        </member>
        <member name="M:AboditNLP.IVerbBuilder.PresentPlural(System.String,System.Type[])">
            <summary>
            Add the present plural form of a verb
            </summary>
        </member>
        <member name="M:AboditNLP.IVerbBuilder.Past(System.String,System.Type[])">
            <summary>
            Add the past tense of a verb
            </summary>
        </member>
        <member name="M:AboditNLP.IVerbBuilder.PastPlural(System.String,System.Type[])">
            <summary>
            Add the past plural tense of a verb
            </summary>
        </member>
        <member name="M:AboditNLP.IVerbBuilder.PresentParticiple(System.String,System.Type[])">
            <summary>
            Add the present participle tense of a verb
            </summary>
        </member>
        <member name="M:AboditNLP.IVerbBuilder.PastParticiple(System.String,System.Type[])">
            <summary>
            Add the past participle of a verb
            </summary>
        </member>
        <member name="M:AboditNLP.IVerbBuilder.Future(System.String,System.Type[])">
            <summary>
            Add the future tense of a verb
            </summary>
        </member>
        <member name="M:AboditNLP.IVerbBuilder.Regular">
            <summary>
            Mark a verb as being regular
            </summary>
        </member>
        <member name="M:AboditNLP.IVerbBuilder.Irregular">
            <summary>
            Mark a verb as irregular
            </summary>
        </member>
        <member name="T:AboditNLP.INounBuilder">
            <summary>
            Things you can do while defining a noun (countable or otherwise)
            </summary>
        </member>
        <member name="M:AboditNLP.INounBuilder.Singular(System.String,System.Type[])">
            <summary>
            Add a singular noun form
            </summary>
        </member>
        <member name="M:AboditNLP.INounBuilder.SingularPossessive(System.String,System.Type[])">
            <summary>
            Add a singular possessive noun form
            </summary>
        </member>
        <member name="M:AboditNLP.INounBuilder.Plural(System.String,System.Type[])">
            <summary>
            Add the plural of a noun
            </summary>
        </member>
        <member name="M:AboditNLP.INounBuilder.PluralPossessive(System.String,System.Type[])">
            <summary>
            Add the plural possessive of a noun
            </summary>
        </member>
        <member name="T:AboditNLP.INumberBuilder">
            <summary>
            Things you can do while defining a whole number
            </summary>
        </member>
        <member name="M:AboditNLP.INumberBuilder.Cardinal(System.String,System.Type[])">
            <summary>
            Add the cardinal form of a number
            </summary>
        </member>
        <member name="M:AboditNLP.INumberBuilder.Cardinal(System.String,System.String,System.Type[])">
            <summary>
            Add the cardinal form of a number
            </summary>
        </member>
        <member name="M:AboditNLP.INumberBuilder.Ordinal(System.String,System.Type)">
            <summary>
            Add the ordinal form of a number
            </summary>
        </member>
        <member name="M:AboditNLP.INumberBuilder.Ordinal(System.String,System.String,System.Type)">
            <summary>
            Add the ordinal form of a number
            </summary>
        </member>
        <member name="T:AboditNLP.ILexemeGenerator">
            <summary>
            An ILexemeGenerator provides Lexemes (units of meaning)
            </summary>
        </member>
        <member name="M:AboditNLP.ILexemeGenerator.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
            Creates the words and Synsets, adding them to the store
            </summary>
        </member>
        <member name="T:AboditNLP.IGraphGenerator">
            <summary>
            Called after ILexemeGenerators in order to add any graph relationships between lexemes
            </summary>
            <remarks>
            Relationships between Lexemes will inlcude antonyms, ...
            </remarks>
        </member>
        <member name="M:AboditNLP.IGraphGenerator.CreateGraph">
            <summary>
            Creates the graphs adding the to the tree
            </summary>
        </member>
        <member name="T:AboditNLP.Lexeme">
            <summary>
            The base Word
            </summary>
            <remarks>
            A lexeme is an abstract unit of morphological analysis in linguistics, that roughly corresponds to a set of forms taken by a single word.
            For example, in the English language, run, runs, ran and running are forms of the same lexeme, conventionally written as run.[1] 
            A related concept is the lemma (or citation form), which is a particular form of a lexeme that is chosen by convention to represent 
            a canonical form of a lexeme. Lemmas are used in dictionaries as the headwords, and other forms of a lexeme are often listed later 
            in the entry if they are not common conjugations of that word.
            </remarks>
        </member>
        <member name="P:AboditNLP.Lexeme.New">
            <summary>
            Start building a new Synset and Lexemes
            </summary>
        </member>
        <member name="P:AboditNLP.Lexeme.Synset">
            <summary>
            The WordNet synset (or others as extended by the user)
            </summary>
            <remarks>
            The Synset also has a collection of Lexemes on it pointing back
            to all the lexemes that are synonyms of each other
            </remarks>
        </member>
        <member name="P:AboditNLP.Lexeme.IsClean">
            <summary>
            Is this Synset 'clean', i.e. not NSFW and this suitable for inclusion in an autocomplete list
            </summary>
        </member>
        <member name="P:AboditNLP.Lexeme.Text">
            <summary>
            The actual word for this Lexeme
            </summary>
        </member>
        <member name="P:AboditNLP.Lexeme.Interfaces">
            <summary>
            The interfaces on just this Lexeme (not on any Synsets it may inherit from)
            </summary>
        </member>
        <member name="F:AboditNLP.Lexeme.interfacesIncludingInherited">
            <summary>
            Cache interfaces including inherited because it's expensive to search the entire inheritance tree every time
            </summary>
        </member>
        <member name="P:AboditNLP.Lexeme.InterfacesIncludingInherited">
            <summary>
            The interfaces on this Lexeme including any interfaces inherited from superclasses
            (Such interfaces MUST begin with a capital letter on the last part of their name, e.g. Noun.Type.Mammal)
            This field is identity mapped so reference comparisons can be made
            </summary>
        </member>
        <member name="F:AboditNLP.Lexeme.interfaces">
            <summary>
            The interfaces represent the specific meanings assigned to this Lexeme - a lexeme may inherit multiple meanings
            </summary>
            <remarks>
            This field has been identity mapped. Any set of the same interfaces will be the exact
            same object reference. This is done to reduce memory requirements and to allow
            by reference comparisons for meanings.
            </remarks>
        </member>
        <member name="M:AboditNLP.Lexeme.AddInterfaces(System.Type[])">
            <summary>
            Add interfaces (meanings) that this word represents
            </summary>
        </member>
        <member name="M:AboditNLP.Lexeme.#ctor(AboditNLP.SynSet,System.String,System.Type[])">
            <summary>
            Creates a new Lexeme (word with attached Synset meaning) instance
            </summary>
            <param name="synset">The meaning for this instance of the word</param>
            <param name="text">The text of the word</param>
            <param name="interfaces">Additional interfaces like 'Past', 'Singular', ...</param>
        </member>
        <member name="M:AboditNLP.Lexeme.ActLikeAllInterfacesPresent">
            <summary>
            Becomes a Proxy object that acts like it implements all of the interfaces listed as being supported by this Entity
            </summary>
            <remarks>
            This then allows the natural language code to fire off the appropriate statement methods based on the interfaces present on an object
            These are cached because computing the transitive closure of all interfaces can be a slow operation
            </remarks>
        </member>
        <member name="M:AboditNLP.Lexeme.ToString">
            <summary>
            Returns a string that represents the current object
            </summary>
            <returns></returns>
        </member>
        <member name="M:AboditNLP.Lexeme.Equals(System.Object)">
            <summary>
            Tests for equality
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:AboditNLP.Lexeme.GetHashCode">
            <summary>
            Returns the hashcode for this Lexeme
            </summary>
            <remarks>
            Implemented as the hashcode of the word for this Lexeme since that
            gives sufficient diversity and is easy to calculate.
            </remarks>
        </member>
        <member name="T:AboditNLP.LexAdjective">
            <summary>
            A Lexeme for an Adjective
            </summary>
        </member>
        <member name="P:AboditNLP.LexAdjective.Normal">
            <summary>
            The normal form of this adjective
            </summary>
        </member>
        <member name="P:AboditNLP.LexAdjective.Comparative">
            <summary>
            The comparative form of this adjective
            </summary>
        </member>
        <member name="P:AboditNLP.LexAdjective.Superlative">
            <summary>
            The superlative form of this adjective
            </summary>
        </member>
        <member name="P:AboditNLP.LexAdjective.IsComparable">
            <summary>
            Is this adjective a comparable adjective (i.e. does it have a comparative form)
            </summary>
            <remarks>
            Some adjectives have no comparable form, e.g. "satin"
            </remarks>
        </member>
        <member name="M:AboditNLP.LexAdjective.#ctor(AboditNLP.SynSet,System.String,System.Type[])">
            <summary>
            Create a new instance of a LexAdjective
            </summary>
        </member>
        <member name="T:AboditNLP.LexOrdinal">
            <summary>
            A Lexeme for an Ordinal
            </summary>
        </member>
        <member name="P:AboditNLP.LexOrdinal.ValueLong">
            <summary>
            The numeric value of this ordinal
            </summary>
        </member>
        <member name="P:AboditNLP.LexOrdinal.Cardinal">
            <summary>
            The cardinal form
            </summary>
        </member>
        <member name="P:AboditNLP.LexOrdinal.Ordinal">
            <summary>
            The ordinal form
            </summary>
        </member>
        <member name="P:AboditNLP.LexOrdinal.Fraction">
            <summary>
            The fraction form
            </summary>
        </member>
        <member name="P:AboditNLP.LexOrdinal.FractionPlural">
            <summary>
            The plural fraction form
            </summary>
        </member>
        <member name="M:AboditNLP.LexOrdinal.#ctor(AboditNLP.SynSet,System.String,System.Int64,System.Type[])">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.LexOrdinal"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.LexCardinal">
            <summary>
            A Lexeme for a cardinal number
            </summary>
        </member>
        <member name="P:AboditNLP.LexCardinal.ValueLong">
            <summary>
            The value represented
            </summary>
        </member>
        <member name="P:AboditNLP.LexCardinal.Cardinal">
            <summary>
            The cardinal form
            </summary>
        </member>
        <member name="P:AboditNLP.LexCardinal.Ordinal">
            <summary>
            The ordinal form
            </summary>
        </member>
        <member name="P:AboditNLP.LexCardinal.Fraction">
            <summary>
            The fraction form
            </summary>
        </member>
        <member name="P:AboditNLP.LexCardinal.FractionPlural">
            <summary>
            The fraction plural form
            </summary>
        </member>
        <member name="M:AboditNLP.LexCardinal.#ctor(AboditNLP.SynSet,System.String,System.Int32,System.Type[])">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.LexCardinal"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.LexFraction">
            <summary>
            A Lexeme for a fraction
            </summary>
        </member>
        <member name="P:AboditNLP.LexFraction.Numerator">
            <summary>
            The numerator
            </summary>
        </member>
        <member name="P:AboditNLP.LexFraction.Denominator">
            <summary>
            The denominator
            </summary>
        </member>
        <member name="P:AboditNLP.LexFraction.ValueDouble">
            <summary>
            The value as a double
            </summary>
        </member>
        <member name="P:AboditNLP.LexFraction.Cardinal">
            <summary>
            The Cardinal form
            </summary>
        </member>
        <member name="P:AboditNLP.LexFraction.Ordinal">
            <summary>
            The Ordinal form
            </summary>
        </member>
        <member name="P:AboditNLP.LexFraction.Fraction">
            <summary>
            The Fraction form 
            </summary>
        </member>
        <member name="P:AboditNLP.LexFraction.FractionPlural">
            <summary>
            The plural fraction form
            </summary>
        </member>
        <member name="M:AboditNLP.LexFraction.#ctor(AboditNLP.SynSet,System.String,System.Int32,System.Int32,System.Type[])">
            <summary>
            Creates a new instance of a Lexeme for a fraction
            </summary>
        </member>
        <member name="T:AboditNLP.LexFractionPlural">
            <summary>
            A Lexeme for a plural fraction, e.g. quarters
            </summary>
        </member>
        <member name="P:AboditNLP.LexFractionPlural.Numerator">
            <summary>
            The numerator
            </summary>
        </member>
        <member name="P:AboditNLP.LexFractionPlural.Denominator">
            <summary>
            The denominator
            </summary>
        </member>
        <member name="P:AboditNLP.LexFractionPlural.ValueDouble">
            <summary>
            The value as a double
            </summary>
        </member>
        <member name="P:AboditNLP.LexFractionPlural.Cardinal">
            <summary>
            The Cardinal form
            </summary>
        </member>
        <member name="P:AboditNLP.LexFractionPlural.Ordinal">
            <summary>
            The Ordinal form
            </summary>
        </member>
        <member name="P:AboditNLP.LexFractionPlural.Fraction">
            <summary>
            The Fraction form
            </summary>
        </member>
        <member name="P:AboditNLP.LexFractionPlural.FractionPlural">
            <summary>
            The Fraction plural form
            </summary>
        </member>
        <member name="M:AboditNLP.LexFractionPlural.#ctor(AboditNLP.SynSet,System.String,System.Int32,System.Int32,System.Type[])">
            <summary>
            Creates a new instance of a plural fraction Lexeme
            </summary>
        </member>
        <member name="T:AboditNLP.LexVerb">
            <summary>
            A Lexeme for a Verb
            </summary>
        </member>
        <member name="P:AboditNLP.LexVerb.PresentSelf">
            <summary>
            The PresentSelf form of a verb
            </summary>
        </member>
        <member name="P:AboditNLP.LexVerb.PresentThirdPerson">
            <summary>
            The present third person form of a verb
            </summary>
        </member>
        <member name="P:AboditNLP.LexVerb.PresentPlural">
            <summary>
            The present plural form of a verb
            </summary>
        </member>
        <member name="P:AboditNLP.LexVerb.PresentParticiple">
            <summary>
            The present participle form of a verb
            </summary>
        </member>
        <member name="P:AboditNLP.LexVerb.Past">
            <summary>
            The past participle form of a verb
            </summary>
        </member>
        <member name="P:AboditNLP.LexVerb.PastPlural">
            <summary>
            The past plural form of a verb
            </summary>
        </member>
        <member name="P:AboditNLP.LexVerb.PastParticiple">
            <summary>
            The past participle form of a verb
            </summary>
        </member>
        <member name="P:AboditNLP.LexVerb.Infinitive">
            <summary>
            The infinitive form of a verb
            </summary>
        </member>
        <member name="P:AboditNLP.LexVerb.Future">
            <summary>
            The future form of a verb
            </summary>
        </member>
        <member name="M:AboditNLP.LexVerb.#ctor(AboditNLP.SynSet,System.String,System.Type[])">
            <summary>
            Create a new instance of the LexVerb class (i.e. a verb word)
            </summary>
        </member>
        <member name="T:AboditNLP.LexNoun">
            <summary>
            A Lexeme for a Noun
            </summary>
            <remarks>
            Relationships between a noun form and a verb form can now be found in the Lexeme Graph
            they are not stored on the individual Lexemes in order to save space
            </remarks>
        </member>
        <member name="P:AboditNLP.LexNoun.Singular">
            <summary>
            The singular form
            </summary>
        </member>
        <member name="P:AboditNLP.LexNoun.Plural">
            <summary>
            The plural form
            </summary>
        </member>
        <member name="P:AboditNLP.LexNoun.SingularPossessive">
            <summary>
            The singular possessive
            </summary>
        </member>
        <member name="P:AboditNLP.LexNoun.PluralPossessive">
            <summary>
            The plural possessive form
            </summary>
        </member>
        <member name="P:AboditNLP.LexNoun.CollectiveNoun">
            <summary>
            The collective noun form
            </summary>
        </member>
        <member name="M:AboditNLP.LexNoun.#ctor(AboditNLP.SynSet,System.String,System.Type[])">
            <summary>
            Create a new instance of the <see cref="T:AboditNLP.LexNoun"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.LexAdverb">
            <summary>
            A Lexeme for an Adverb
            </summary>
        </member>
        <member name="P:AboditNLP.LexAdverb.Opposite">
            <summary>
            The opposite form
            </summary>
        </member>
        <member name="M:AboditNLP.LexAdverb.#ctor(AboditNLP.SynSet,System.String,System.Type[])">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.LexAdverb"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.LexInterjection">
            <summary>
            A Lexeme for an Interjection
            </summary>
        </member>
        <member name="M:AboditNLP.LexInterjection.#ctor(AboditNLP.SynSet,System.String,System.Type[])">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.LexInterjection"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.LexContraction">
            <summary>
            A Lexeme for a contraction
            </summary>
        </member>
        <member name="M:AboditNLP.LexContraction.#ctor(AboditNLP.SynSet,System.String,System.Type[])">
            <summary>
            Creates a new instace of the <see cref="T:AboditNLP.LexContraction"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.LexPreposition">
            <summary>
            A Lexeme for a Preposition
            </summary>
        </member>
        <member name="P:AboditNLP.LexPreposition.Opposite">
            <summary>
            The opposite
            </summary>
        </member>
        <member name="M:AboditNLP.LexPreposition.#ctor(AboditNLP.SynSet,System.String,System.Type[])">
            <summary>
            Creates a new instace of the <see cref="T:AboditNLP.LexPreposition"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.LexPunctuation">
            <summary>
            A Lexeme for punctuation
            </summary>
        </member>
        <member name="M:AboditNLP.LexPunctuation.#ctor(AboditNLP.SynSet,System.String,System.Type[])">
            <summary>
            Creates a new instace of the <see cref="T:AboditNLP.LexPunctuation"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.LexDeterminer">
            <summary>
            A Lexeme for a determiner
            </summary>
        </member>
        <member name="M:AboditNLP.LexDeterminer.#ctor(AboditNLP.SynSet,System.String,System.Type[])">
            <summary>
            Creates a new instace of the <see cref="T:AboditNLP.LexDeterminer"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.LexArticle">
            <summary>
            A Lexeme for an article
            </summary>
        </member>
        <member name="M:AboditNLP.LexArticle.#ctor(AboditNLP.SynSet,System.String,System.Type[])">
            <summary>
            Creates a new instace of the <see cref="T:AboditNLP.LexArticle"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.LexQuestion">
            <summary>
            A Lexeme for a Question word or phrase
            </summary>
        </member>
        <member name="M:AboditNLP.LexQuestion.#ctor(AboditNLP.SynSet,System.String,System.Type[])">
            <summary>
            Creates a new instace of the <see cref="T:AboditNLP.LexQuestion"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.LexConjunction">
            <summary>
            A Lexeme for a Conjunction
            </summary>
        </member>
        <member name="M:AboditNLP.LexConjunction.#ctor(AboditNLP.SynSet,System.String,System.Type[])">
            <summary>
            Creates a new instace of the <see cref="T:AboditNLP.LexConjunction"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.CollectiveNounGenerator">
            <summary>
            Each countable noun has a collective noun that is what a group of those objects is called ...
            </summary>
        </member>
        <member name="T:AboditNLP.TokenProduct">
            <summary>
            A product is a Countable Noun that also has a Brand, and a Model
            </summary>
            <remarks>
            Just an example, not really part of NLP core
            </remarks>
        </member>
        <member name="P:AboditNLP.TokenProduct.Brand">
            <summary>
            The brand name
            </summary>
        </member>
        <member name="P:AboditNLP.TokenProduct.Model">
            <summary>
            The model name
            </summary>
        </member>
        <member name="M:AboditNLP.TokenProduct.#ctor(System.String,System.String,System.Type[])">
            <summary>
            Create a new instance of the <see cref="T:AboditNLP.TokenProduct"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.IPronoun">
            <summary>
            A pronoun is a word that stands for a noun, like, say 'this'
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.Type.PersonalPronoun">
            <summary>
            A personal pronoun (me, I, we..)
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.Type.Singular">
            <summary>
            A singular pronoun (it, he, she, ...)
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.Type.Plural">
            <summary>
            A plural pronoun (we, they, ...)
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.Type.SingularPossessive">
            <summary>
            A singular posessive pronoun
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.Type.PluralPossessive">
            <summary>
            A plural posessive pronoun
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.Type.Demonstrative">
            <summary>
            A Demonstrative pronoun
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.Type.RelativePronoun">
            <summary>
            A relative pronoun
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.Type.ReflexivePronoun">
            <summary>
            A reflexive pronoun
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.Type.InterogativePronoun">
            <summary>
            An interogative pronoun (actually modelled as Question words instead)
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.Type.IndefinitePronoun">
            <summary>
            Indefinite pronouns are pronouns that do not point out specifically.They point out generally.
            They include such words as another, any, anybody, anyone, anything, 
            both, each, either, everybody, everyone, everything, many, 
            neither, nobody, none, no one, one, other, others, 
            some, somebody, and someone
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.Type.Male">
            <summary>
            A male pronoun (he, him, ...)
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.Type.Female">
            <summary>
            A female pronoun (she, her, ...)
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.Type.Neuter">
            <summary>
            A neuter pronoun (it, ...)
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.MeOrI">
            <summary>
            The pronoun I or me, use this for Accusative or Nominative
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.WeOrI">
            <summary>
            The pronoun I or we, Nominative
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.IorWe">
            <summary>
            The pronoun I or we, Nominative
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.MeOrUs">
            <summary>
            The pronoun me or us, use this for Accusative
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.UsOrMe">
            <summary>
            The pronoun me or us, use this for Accusative
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.i">
            <summary>
            The nominative pronoun I
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.me">
            <summary>
            The accusative pronoun me
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.mine">
            <summary>
            The posessive pronoun mine
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.heShe">
            <summary>
            The pronoun he or she
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.himHer">
            <summary>
            The accusative pronoun him or her
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.hisHers">
            <summary>
            The possessive pronoun his or hers
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.he">
            <summary>
            The nominative pronoun he
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.him">
            <summary>
            The accusative pronoun him
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.she">
            <summary>
            The nominative pronoun she
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.her">
            <summary>
            The accusative pronoun her
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.it">
            <summary>
            The pronoun it (accusative or nominative)
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.his">
            <summary>
            The possessive pronoun his
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.hers">
            <summary>
            The possessive pronoun hers or hers
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.its">
            <summary>
            The possessive pronoun its
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.theirs">
            <summary>
            The possessive pronoun theirs
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.us">
            <summary>
            The accusative pronoun us
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.we">
            <summary>
            The nominative pronoun we
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.ours">
            <summary>
            The possessive pronoun ours
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.you">
            <summary>
            The pronoun you, accusative or nominative
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.yours">
            <summary>
            The possessive pronoun yours (see also Determiner your)
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.they">
            <summary>
            The pronoun they
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.them">
            <summary>
            The pronoun them
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.this">
            <summary>
            The pronoun this
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.thatOrWhichOrWhose">
            <summary>
            Either that or which or whose (words used in forming a query, e.g. 'whose length is ...'
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.thatOrWhich">
            <summary>
            Either that or which
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.that">
            <summary>
            The pronoun that
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.which">
            <summary>
            The pronoun that
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.whose">
            <summary>
            The pronoun whose
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.these">
            <summary>
            The pronoun these
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.those">
            <summary>
            The pronoun those
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.all">
            <summary>
            The pronoun all
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.another">
            <summary>
            The indefinite pronoun another
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.any">
            <summary>
            The indefinite pronoun any
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.anybody">
            <summary>
            The indefinite pronoun anybody
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.anyone">
            <summary>
            The indefinite pronoun anyone
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.anything">
            <summary>
            The indefinite pronoun anything
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.both">
            <summary>
            The indefinite pronoun both
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.each">
            <summary>
            The indefinite pronoun each
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.either">
            <summary>
            The indefinite pronoun either
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.everybody">
            <summary>
            The indefinite pronoun everybody
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.everyone">
            <summary>
            The indefinite pronoun everyone
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.everything">
            <summary>
            The indefinite pronoun everything
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.many">
            <summary>
            The indefinite pronoun many
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.neither">
            <summary>
            The indefinite pronoun neither
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.nobody">
            <summary>
            The indefinite pronoun nobody
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.none">
            <summary>
            The indefinite pronoun none
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.no_one">
            <summary>
            The indefinite pronoun no one
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.one">
            <summary>
            The indefinite pronoun one
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.ones">
            <summary>
            The possessive pronoun one's
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.other">
            <summary>
            The indefinite pronoun other
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.others">
            <summary>
            The indefinite pronoun other
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.some">
            <summary>
            The indefinite pronoun some
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.somebody">
            <summary>
            The indefinite pronoun somebody
            </summary>
        </member>
        <member name="T:AboditNLP.Pronoun.someone">
            <summary>
            The indefinite pronoun someone
            </summary>
        </member>
        <member name="T:AboditNLP.INoun">
            <summary>
            A Noun is a word used to name a person, place, thing, or idea. A noun can be a proper noun or a common noun.
            A noun can be countable or uncountable, need to cast to the appropriate interface
            </summary>
        </member>
        <member name="P:AboditNLP.INoun.Singular">
            <summary>
            The singular form of a noun
            </summary>
        </member>
        <member name="P:AboditNLP.INoun.SingularPossessive">
            <summary>
            The plural form of a noun
            </summary>
        </member>
        <member name="P:AboditNLP.INoun.Plural">
            <summary>
            The plural form of a noun
            </summary>
        </member>
        <member name="P:AboditNLP.INoun.PluralPossessive">
            <summary>
            The plural posessive form of a noun
            </summary>
        </member>
        <member name="T:AboditNLP.IPreposition">
            <summary>
            A preposition: a word governing, and usually preceding, a noun or pronoun and expressing a relation to another 
            word or element in the clause
            </summary>
        </member>
        <member name="T:AboditNLP.IPunctuation">
            <summary>
            Any form of punctuation (comma, colon, semicolon, period, ...)
            </summary>
        </member>
        <member name="T:AboditNLP.IOperator">
            <summary>
            An operator, e.g. > == != is has, ... 
            </summary>
            <remarks>
            This includes both symbols like less than and greater than and word forms 
            </remarks>
        </member>
        <member name="T:AboditNLP.IOperatorMatches">
            <summary>
            A special operator token meaning 'matches'
            </summary>
        </member>
        <member name="T:AboditNLP.IOperatorComparison">
            <summary>
            Any operator that is a comparison, e.g. less than, greater than, ...
            </summary>
        </member>
        <member name="T:AboditNLP.IOperatorEquality">
            <summary>
            The equals or not equals operator
            </summary>
        </member>
        <member name="T:AboditNLP.IOperatorArithmetic">
            <summary>
            Any arithmetic operator
            </summary>
        </member>
        <member name="T:AboditNLP.IOperatorBooleanLogic">
            <summary>
            Andy boolean operator (and, or not)
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.Parenthesis">
            <summary>
            An open or close parenthesis character see also: <seealso cref="T:AboditNLP.Punctuation.lparen"/>
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.DateSeparator">
            <summary>
            A date separator
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.SentenceTerminator">
            <summary>
            Any punctuation character that can terminate a sentence
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.period">
            <summary>
            A period (full stop)
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.question">
            <summary>
            A question mark
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.exclamation">
            <summary>
            An exclamation mark
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.colon">
            <summary>
            A colon
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.comma">
            <summary>
            A comma
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.semicolon">
            <summary>
            A semi colon
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.slash">
            <summary>
            A forward slash character
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.backslash">
            <summary>
            A back slash character
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.lparen">
            <summary>
            A left parenthesis
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.rparen">
            <summary>
            A right parenthesis
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.lparenSquare">
            <summary>
            A left square parenthesis
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.rparenSquare">
            <summary>
            A right square parenthesis
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.lparenCurly">
            <summary>
            A curly left parenthesis
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.rparenCurly">
            <summary>
            A curly right parenthesis
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.dash">
            <summary>
            A dash
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.underscore">
            <summary>
            An underscore
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.plus">
            <summary>
            A plus symbol
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.asterisk">
            <summary>
            An asterisk symbol
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.caret">
            <summary>
            A caret symbol
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.hash">
            <summary>
            A hash symbol
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.apostrophe">
            <summary>
            An apostrophe
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.doubleQuote">
            <summary>
            A double quote
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.forwardArrow">
            <summary>
            A forward arrow
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.backwardArrow">
            <summary>
            A backward arrow
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.forwardDoubleArrow">
            <summary>
            A forward double arrow
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.backwardDoubleArrow">
            <summary>
            A backward double arrow
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.pipe">
            <summary>
            A single pipe
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.doublePipe">
            <summary>
            A double pipe
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.ampersand">
            <summary>
            A single ampersand
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.doubleAmpersand">
            <summary>
            A double ampersand
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.equal">
            <summary>
            An equals operator
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.notEqual">
            <summary>
            A not equals operator
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.matches">
            <summary>
            A forward arrow
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.greaterOrEqual">
            <summary>
            greater than or equal
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.lessOrEqual">
            <summary>
            less or equal
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.greaterThan">
            <summary>
            greater than
            </summary>
        </member>
        <member name="T:AboditNLP.Punctuation.lessThan">
            <summary>
            less than
            </summary>
        </member>
        <member name="T:AboditNLP.SynSet">
            <summary>
            A SynSet is a set of Lexemes that have the same meaning
            </summary>
        </member>
        <member name="P:AboditNLP.SynSet.Name">
            <summary>
            The name of this synset (the WordNet SynSet name in most cases)
            </summary>
        </member>
        <member name="F:AboditNLP.SynSet.Empty">
            <summary>
            The singleton Empty SynSet
            </summary>
        </member>
        <member name="P:AboditNLP.SynSet.Interfaces">
            <summary>
            Interfaces that apply to the synset (and thus to any words that are in this synset)
            </summary>
        </member>
        <member name="M:AboditNLP.SynSet.AddInterface(System.Type)">
            <summary>
            Add an interface to an existing synset
            </summary>
        </member>
        <member name="M:AboditNLP.SynSet.AddInterfaces(System.Type[])">
            <summary>
            Add interfaces to this SynSet
            </summary>
        </member>
        <member name="M:AboditNLP.SynSet.AddInterfaces(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Add interfaces to this SynSet
            </summary>
        </member>
        <member name="M:AboditNLP.SynSet.InterfacesIncludingInherited">
            <summary>
            Get all of the interfaces (meanings) set on this SynSet (trasitively)
            </summary>
        </member>
        <member name="P:AboditNLP.SynSet.Lexemes">
            <summary>
            All of the Lexemes (word forms) that have this meaning
            </summary>
        </member>
        <member name="M:AboditNLP.SynSet.AddLexeme(AboditNLP.Lexeme)">
            <summary>
            Add a Lexeme (word form) to a SynSet
            </summary>
        </member>
        <member name="F:AboditNLP.SynSet.Graph">
            <summary>
            All the synset relationships
            </summary>
        </member>
        <member name="P:AboditNLP.SynSet.IsClean">
            <summary>
            Is this Synset 'clean', i.e. not NSFW and this suitable for inclusion in an autocomplete list
            </summary>
        </member>
        <member name="M:AboditNLP.SynSet.Add(System.String,Abodit.Graph.Relation,System.String)">
            <summary>
            Add an edge to the SynSet graph
            </summary>
            <param name="subjectSynset">The name of the subject synset</param>
            <param name="relation">The relationship</param>
            <param name="objectSynset">The name of the object synset</param>
            <returns>false if the edge cannot be added (e.g. self-reference)</returns>
        </member>
        <member name="M:AboditNLP.SynSet.Follow(Abodit.Graph.Relation)">
            <summary>
            Follow the edges of the graph down a specific relaton
            </summary>
        </member>
        <member name="P:AboditNLP.SynSet.Antonyms">
            <summary>
            Get any antonyms
            </summary>
        </member>
        <member name="P:AboditNLP.SynSet.VerbForms">
            <summary>
            Get the verb forms (if any)
            </summary>
        </member>
        <member name="P:AboditNLP.SynSet.NounForms">
            <summary>
            Get the noun forms (if any)
            </summary>
        </member>
        <member name="P:AboditNLP.SynSet.AdjectiveForms">
            <summary>
            Get the adjective forms (if any)
            </summary>
        </member>
        <member name="P:AboditNLP.SynSet.AdjectiveNegativeForms">
            <summary>
            Get the negative adjective forms (if any)
            </summary>
        </member>
        <member name="P:AboditNLP.SynSet.AdjectivePositiveForms">
            <summary>
            Get the positive adjective forms (if any)
            </summary>
        </member>
        <member name="M:AboditNLP.SynSet.Get(System.String)">
            <summary>
            Synset factory / identity map
            </summary>
        </member>
        <member name="M:AboditNLP.SynSet.Equals(AboditNLP.SynSet)">
            <summary>
            SynSet equality is determined using references as they are all identity mapped by name
            </summary>
        </member>
        <member name="M:AboditNLP.SynSet.ToString">
            <summary>
            The name of this SynSet
            </summary>
            <returns></returns>
        </member>
        <member name="T:AboditNLP.Verb.add">
            <summary>
            The verb add
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.subtract">
            <summary>
            The verb subtract
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.multiply">
            <summary>
            The verb multiply
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.divide">
            <summary>
            The verb divide
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.alert">
            <summary>
            The verb alert
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.be">
            <summary>
            The verb to be (am, is, are, ...) (see also 'amIsAre')
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.amIsAre">
            <summary>
            Singular or plural present tense form of verb 'be' (a shortcut for [Present]Verb.be)
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.amIsAreNot">
            <summary>
            Singular or plural form of verb 'being not'
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.exist">
            <summary>
            The verb exist
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.buy">
            <summary>
            The verb buy
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.beingNot">
            <summary>
            The verb not being
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.call">
            <summary>
            The verb call
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.can">
            <summary>
            The verb can
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.cancel">
            <summary>
            The verb cancel
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.change">
            <summary>
            The verb change
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.clear">
            <summary>
            The verb clear
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.copy">
            <summary>
            The verb copy
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.could">
            <summary>
            The verb could
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.delete">
            <summary>
            The verb delete
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.doDoes">
            <summary>
            The verb do (does, doing, ...)
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.doDoesNot">
            <summary>
            The verb do not (does not, ...)
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.dump">
            <summary>
            The verb dump
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.email">
            <summary>
            The verb email
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.feel">
            <summary>
            The verb feel
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.list">
            <summary>
            Create a list
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.lookup">
            <summary>
            Look up an item
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.make">
            <summary>
            The verb make
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.move">
            <summary>
            The verb move
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.MakeOrCreate">
            <summary>
            The verb make or create
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.meet">
            <summary>
            The verb meet
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.merge">
            <summary>
            The verb merge
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.monitor">
            <summary>
            The verb monitor
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.must">
            <summary>
            The verb must
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.musthave">
            <summary>
            The verb must have or will need
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.need">
            <summary>
            The verb need
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.pause">
            <summary>
            The verb pause
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.play">
            <summary>
            The verb play
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.put">
            <summary>
            The verb put
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.read">
            <summary>
            The verb read
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.reboot">
            <summary>
            The verb reboot
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.rate">
            <summary>
            The verb rate
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.remind">
            <summary>
            The verb remind
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.remember">
            <summary>
            The verb remember
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.remove">
            <summary>
            The verb remove
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.rename">
            <summary>
            The verb rename
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.return">
            <summary>
            The verb return
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.rewind">
            <summary>
            The verb rewind
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.say">
            <summary>
            The verb say
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.scan">
            <summary>
            The verb scan
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.send">
            <summary>
            The verb send
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.set">
            <summary>
            The verb set
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.should">
            <summary>
            The verb should
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.shouldNot">
            <summary>
            The verb phrase 'should not'
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.shuffle">
            <summary>
            The verb shuffle
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.shorten">
            <summary>
            The verb shorten
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.sort">
            <summary>
            The verb sort
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.shut">
            <summary>
            The verb shut
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.shutdown">
            <summary>
            The verb shutdown
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.skip">
            <summary>
            The verb skip
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.speak">
            <summary>
            The verb speak
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.speakWithTo">
            <summary>
            The very speak with or to
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.color">
            <summary>
            The verb color
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.name">
            <summary>
            The verb name
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.start">
            <summary>
            The verb start
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.end">
            <summary>
            The verb end
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.contain">
            <summary>
            The verb contains
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.stop">
            <summary>
            The verb stop
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.tag">
            <summary>
            The verb tag
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.unTag">
            <summary>
            The verb untag
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.TagUnTag">
            <summary>
            The category of verbs tag or untag
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.take">
            <summary>
            The verb take
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.talk">
            <summary>
            The verb talk
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.test">
            <summary>
            The verb test
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.TrackUnTrackType">
            <summary>
            The category of verbs for track or untrack
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.track">
            <summary>
            The verb track
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.untrack">
            <summary>
            The verb untrack
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.turn">
            <summary>
            The verb turn
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.tweet">
            <summary>
            The verb tweet
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.unsubscribe">
            <summary>
            The verb unsubscribe
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.wake">
            <summary>
            The verb wake
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.work">
            <summary>
            The verb work
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.watch">
            <summary>
            The verb watch
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.weigh">
            <summary>
            The verb weight
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.write">
            <summary>
            The verb white
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.draw6">
            <summary>
            The verb draw or its more specific forms: diagram. plot, chart
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.diagram1">
            <summary>
            The verb diagram or its more specific forms: plot, chart
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.graph2">
            <summary>
            The verb graph or chart
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.Tense.Present">
            <summary>
            The present tense of a verb (e.g. "am", "is", "are")
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.Tense.Past">
            <summary>
            The past tense of a verb (e.g. "was", "were", "had")
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.Tense.PresentSelf">
            <summary>
            The present self form of a verb (e.g. "I have")
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.Tense.PresentThirdPerson">
            <summary>
            The present third person form of a verb (e.g. "they have")
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.Tense.PresentPlural">
            <summary>
            The present plural form of a verb (e.g. "we have")
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.Tense.PresentParticiple">
            <summary>
            The present participle form of a verb (e.g. "having")
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.Tense.PastSingular">
            <summary>
            The past singular form of a verb (e.g. "he had")
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.Tense.PastPlural">
            <summary>
            The past plural form of a verb (e.g. "we had")
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.Tense.PastParticiple">
            <summary>
            The past participle form of a verb (e.g. "claimed")
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.Tense.Future">
            <summary>
            The future tense of a verb
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.Tense.Infinitive">
            <summary>
            The infinitive form of a verb
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.Tense.NounForm">
            <summary>
            The NounForm of a verb
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.Type.IndicativeType">
            <summary>
            Indicative verb for stating facts
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.Type.Subjunctive1Type">
            <summary>
            Subjunctive I is used to report indirect speech, i.e. what someone else said (and, by extension, what s/he thought, believed, etc.)
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.Type.Subjunctive2Type">
            <summary>
            Subjunctive II expresses hypothetical and "counterfactual" statements ("what if," "I wish," "I would," "I could" etc.). Normally, if someone speaks about "the subjunctive," they mean Subjunctive II.
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.Type.ImperativeType">
            <summary>
            imperative--for stating commands
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.Type.Transitive">
            <summary>
            Transitive verbs take an object
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.Type.Intransitive">
            <summary>
            Intransitive verbs don't take an object
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.Type.Exercise">
            <summary>
            Verbs related to exercising (a demo scenario)
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.Type.Observe">
            <summary>
            Verbs related to observing (a demo scenario)
            </summary>
        </member>
        <member name="T:AboditNLP.Verb.Type.Communicate">
            <summary>
            Verbs related to communicating (a demo scenario)
            </summary>
        </member>
        <member name="T:AboditNLP.IVerb">
            <summary>
            A Verb is a word that shows action or that indicates a condition or a state of being.
            </summary>
        </member>
        <member name="T:AboditNLP.Tokens.AmbiguousBase">
            <summary>
            Base class for ambiguous results
            </summary>
        </member>
        <member name="P:AboditNLP.Tokens.AmbiguousBase.Contents">
            <summary>
            The ambiguous items
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.AmbiguousBase.SetContents(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Set the contents of an ambiguous list
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:AboditNLP.Tokens.AmbiguousBase.ToString">
            <summary>
            Get a string representation of the ambiguous list
            </summary>
            <returns></returns>
        </member>
        <member name="T:AboditNLP.Tokens.AmbiguousResult`1">
            <summary>
            An ambiguous list
            </summary>
        </member>
        <member name="P:AboditNLP.Tokens.AmbiguousResult`1.IsAmbiguous">
            <summary>
            Is it really ambiguous (count > 1)
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.AmbiguousResult`1.GetEnumerator">
            <summary>
            Get the enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:AboditNLP.Tokens.AmbiguousResult`1.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Tokens.AmbiguousResult`1"/> class
            This constructor is used by the generic creation method
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.AmbiguousResult`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Tokens.AmbiguousResult`1"/> class
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.AmbiguousResult`1.CreateOrNullIfEmpty(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Create a new instance of the AmbiguousResult class or null if no items (ignores null items too)
            also ensures items are distinct to prevent duplicates propagating around
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.AmbiguousResult`1.CreateOrNullIfEmpty(`0[])">
            <summary>
            Create a new instance of the AmbiguousResult class or null if no items
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.AmbiguousResult`1.SetContents(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Set the contents to a list
            </summary>
        </member>
        <member name="T:AboditNLP.Tokens.Token">
            <summary>
            A parsed token, may have used one or more words from the source string
            </summary>
            <remarks>
            A token with no better class than this is an unknown token
            </remarks>
        </member>
        <member name="P:AboditNLP.Tokens.Token.Text">
            <summary>
            Concrete tokens (i.e. ones we create using factories have actual text values)
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.Token.#ctor">
            <summary>
            Constructor for when you have a parser rather than a set list of words
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.Token.op_Implicit(AboditNLP.Tokens.Token)~System.String">
            <summary>
            Implicit conversion to a string using the lower-cased version
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.Token.ToString">
            <summary>
            Returns a string representation of this object
            </summary>
        </member>
        <member name="T:AboditNLP.Tokens.TokenBloodPressure">
            <summary>
            Represents a blood pressure reading
            </summary>
        </member>
        <member name="P:AboditNLP.Tokens.TokenBloodPressure.Systolic">
            <summary>
            The systolic reading
            </summary>
        </member>
        <member name="P:AboditNLP.Tokens.TokenBloodPressure.Diastolic">
            <summary>
            The diastolic reading
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.TokenBloodPressure.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Tokens.TokenBloodPressure"/> class
            </summary>
            <param name="systolic"></param>
            <param name="diastolic"></param>
        </member>
        <member name="M:AboditNLP.Tokens.TokenBloodPressure.ToString">
            <summary>
            Returns a string represnting this object
            </summary>
        </member>
        <member name="T:AboditNLP.Tokens.TokenBloodPressureFactory">
            <summary>
            A factory for parsing blood pressure readings
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.TokenBloodPressureFactory.BloodPressure(Abodit.Expressions.TokenInt,AboditNLP.Punctuation.slash,Abodit.Expressions.TokenInt)">
            <summary>
            A production rule for blood pressures
            </summary>
        </member>
        <member name="T:AboditNLP.Tokens.ITokenEmailAddress">
            <summary>
            Interface for an email address token
            </summary>
        </member>
        <member name="P:AboditNLP.Tokens.ITokenEmailAddress.Email">
            <summary>
            A users email address
            </summary>
        </member>
        <member name="P:AboditNLP.Tokens.ITokenEmailAddress.Name">
            <summary>
            A users name
            </summary>
        </member>
        <member name="T:AboditNLP.Tokens.TokenEmailAddressFactory">
            <summary>
            A factory for creating email addresses
            </summary>
        </member>
        <member name="T:AboditNLP.Tokens.TokenEmailAddress">
            <summary>
            An email address
            </summary>
        </member>
        <member name="P:AboditNLP.Tokens.TokenEmailAddress.Text">
            <summary>
            Gets the original string
            </summary>
        </member>
        <member name="P:AboditNLP.Tokens.TokenEmailAddress.Email">
            <summary>
            The email address
            </summary>
        </member>
        <member name="P:AboditNLP.Tokens.TokenEmailAddress.Name">
            <summary>
            The users full name
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.TokenEmailAddress.#ctor(System.String,System.String)">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Tokens.TokenEmailAddress"/> class
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.TokenEmailAddress.ToString">
            <summary>
            Returns a string for this object
            </summary>
            <returns></returns>
        </member>
        <member name="P:AboditNLP.Tokens.TokenEmailAddress.Synset">
            <summary>
            Get the Synset (empty)
            </summary>
        </member>
        <member name="T:AboditNLP.Tokens.TokenHelper">
            <summary>
            Static methods that used to be on Token class
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.TokenHelper.GetMatch(System.Text.RegularExpressions.Regex,System.String,System.Int32)">
            <summary>
            Helper method to get the first match and check it - todo: Move this out to Utility.Regex 
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.TokenHelper.TokenizeFirstPartOf(AboditNLP.IDependencyScope,System.Collections.Generic.IEnumerable{AboditNLP.ITokenFactory},System.Int32,System.String,System.Boolean,AboditNLP.AllowedToken[])">
            <summary>
            Returns a list of possible token results that can be pulled from the front of the input string
            the caller needs to decide which is the most likely based on parsing the rest of the string etc.
            </summary>
            <remarks>
            This is now somewhat independent from the NLP engine except it relies on having been initialized by it.
            </remarks>
        </member>
        <member name="M:AboditNLP.Tokens.TokenHelper.MakeGeneric(System.Type,System.Type)">
            <summary>
            Create an Ambiguous result programatically
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.TokenHelper.Claim(System.String,System.String,System.Int32@)">
            <summary>
            Claim characters to match a word, returns as soon as it matches one of the words in the commaDelimitedString
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.TokenHelper.SkipWhiteSpace(System.String,System.Int32@)">
            <summary>
            Skip white space
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.TokenHelper.SkipWhiteSpaceOrOtherSeparators(System.String,System.Int32@)">
            <summary>
            Skip white space or other separator characters that people sometimes (incorrectly) use instead (e.g. 10-minutes)
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.TokenHelper.Progress(System.String,System.Int32)">
            <summary>
            Simple helper method to display progress through a string with start and end markers
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.TokenHelper.Progress(System.String,System.Int32,System.Int32)">
            <summary>
            Simple helper method to display progress through a string with start and end markers
            </summary>
        </member>
        <member name="T:AboditNLP.Tokens.TokenPhoneNumberFactory">
            <summary>
            A factory for producing phone numbers
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.TokenPhoneNumberFactory.Parse(AboditNLP.NLPOptions,System.Int32,System.String,AboditNLP.AllowedToken[])">
            <summary>
            Parses input to find tokens
            </summary>
        </member>
        <member name="T:AboditNLP.Tokens.TokenPhoneNumber">
            <summary>
            A phone number
            </summary>
        </member>
        <member name="P:AboditNLP.Tokens.TokenPhoneNumber.Text">
            <summary>
            Get the original string
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.TokenPhoneNumber.#ctor(System.String,System.String)">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Tokens.TokenPhoneNumber"/> class
            </summary>
        </member>
        <member name="P:AboditNLP.Tokens.TokenPhoneNumber.Value">
            <summary>
            Gets the phone number string
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.TokenPhoneNumber.ToString">
            <summary>
            Returns a string representation of this object
            </summary>
            <returns></returns>
        </member>
        <member name="T:AboditNLP.Tokens.TokenUrlOrDomainFactory">
            <summary>
            A factory for parsing TokenURL or Tokendomains
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.TokenUrlOrDomainFactory.Parse(AboditNLP.NLPOptions,System.Int32,System.String,AboditNLP.AllowedToken[])">
            <summary>
            Parse the input to get tokens
            </summary>
        </member>
        <member name="T:AboditNLP.Tokens.TokenUrlOrDomain">
            <summary>
            An URL or just a domain
            </summary>
        </member>
        <member name="P:AboditNLP.Tokens.TokenUrlOrDomain.Text">
            <summary>
            Gets the original string
            </summary>
        </member>
        <member name="P:AboditNLP.Tokens.TokenUrlOrDomain.Domain">
            <summary>
            The domain
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.TokenUrlOrDomain.#ctor(System.String,System.String)">
            <summary>
            Create a new instance of the <see cref="T:AboditNLP.Tokens.TokenUrlOrDomain"/> class
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.TokenUrlOrDomain.ToString">
            <summary>
            Returns a string representation of this object
            </summary>
            <returns></returns>
        </member>
        <member name="T:AboditNLP.Tokens.TokenUrl">
            <summary>
            A token representing an Url
            </summary>
        </member>
        <member name="P:AboditNLP.Tokens.TokenUrl.Path">
            <summary>
            The path for this Url within the domain
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.TokenUrl.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Tokens.TokenUrl"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.Tokens.TokenDomain">
            <summary>
            A token representing a domain
            </summary>
        </member>
        <member name="M:AboditNLP.Tokens.TokenDomain.#ctor(System.String,System.String)">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Tokens.TokenDomain"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.Response.NumberResponse">
            <summary>
            A numeric reponse to a question
            </summary>
            <remarks>
            Use this after asking a question that expects a numeric response
            </remarks>
        </member>
        <member name="P:AboditNLP.Response.NumberResponse.ActionOnResponse">
            <summary>
            The action to perform when the user enters a numeric response
            </summary>
        </member>
        <member name="P:AboditNLP.Response.NumberResponse.MinValue">
            <summary>
            The minimum value for which this response should be recognized
            </summary>
        </member>
        <member name="P:AboditNLP.Response.NumberResponse.MaxValue">
            <summary>
            The maximum value for which this response should be recognized
            </summary>
        </member>
        <member name="M:AboditNLP.Response.NumberResponse.#ctor(System.Action{AboditNLP.IListener,System.Int32},System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Response.NumberResponse"/> class
            </summary>
            <param name="responseAction"></param>
            <param name="minValue"></param>
            <param name="maxValue"></param>
        </member>
        <member name="T:AboditNLP.Response.NumberRule">
            <summary>
            A rule that takes a number and finds a number response to apply it to
            </summary>
        </member>
        <member name="T:AboditNLP.Response.QuestionResponse">
            <summary>
            An expected response to a question
            </summary>
        </member>
        <member name="T:AboditNLP.Response.YesNoResponse`1">
            <summary>
            A Yes/No Response can be placed in the history to handle the response when it comes
            </summary>
        </member>
        <member name="P:AboditNLP.Response.YesNoResponse`1.ActionOnYesResponse">
            <summary>
            The action to perform when the user response Yes
            </summary>
        </member>
        <member name="P:AboditNLP.Response.YesNoResponse`1.ActionOnNoResponse">
            <summary>
            The action to perform when the user responds No
            </summary>
        </member>
        <member name="M:AboditNLP.Response.YesNoResponse`1.#ctor(System.Action{`0},System.Action{`0})">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Response.YesNoResponse`1"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.Response.PhraseResponse`1">
            <summary>
            A Phrase Response can be placed in the history to handle a single response phrase
            </summary>
        </member>
        <member name="P:AboditNLP.Response.PhraseResponse`1.ActionOnResponse">
            <summary>
            The action to do when a phrase response is received
            </summary>
        </member>
        <member name="M:AboditNLP.Response.PhraseResponse`1.#ctor(System.Action{`0,System.String})">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Response.PhraseResponse`1"/> class
            </summary>
            <param name="responseAction"></param>
        </member>
        <member name="T:AboditNLP.Response.QuestionResponse`2">
            <summary>
            A response to a question is expected
            </summary>
        </member>
        <member name="F:AboditNLP.Response.QuestionResponse`2.ActionOnResponse">
            <summary>
            The action to perform when the response is received
            </summary>
        </member>
        <member name="F:AboditNLP.Response.QuestionResponse`2.Validate">
            <summary>
            A method to validate the response
            </summary>
        </member>
        <member name="M:AboditNLP.Response.QuestionResponse`2.#ctor(System.Action{`0,`1},System.Func{`1,System.Boolean})">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.Response.QuestionResponse`2"/> class
            </summary>
        </member>
        <member name="M:AboditNLP.Response.QuestionResponse`2.ToString">
            <summary>
            Returns a string that represents this object
            </summary>
        </member>
        <member name="T:AboditNLP.Rules.RuleFound">
            <summary>
            Abstract base class for rules found by scanning for methods
            </summary>
        </member>
        <member name="P:AboditNLP.Rules.RuleFound.ParameterDescription">
            <summary>
            A description of the parameters in this RuleFound
            </summary>
        </member>
        <member name="P:AboditNLP.Rules.RuleFound.Description">
            <summary>
            A description of this RuleFound with parameters
            </summary>
        </member>
        <member name="M:AboditNLP.Rules.RuleFound.ToString">
            <summary>
            Convert to a string
            </summary>
        </member>
        <member name="M:AboditNLP.Rules.RuleFound.ToStringMethodCall(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Convert to a string displaying the method that will be called and arguments
            </summary>
        </member>
        <member name="P:AboditNLP.Rules.RuleFound.ReturnType">
            <summary>
            The Type that this RuleFound returns when triggered
            </summary>
        </member>
        <member name="P:AboditNLP.Rules.RuleFound.Mapping">
            <summary>
            The mapping array specifies how to take the TokenTypes as they are found and apply them to the parameters of the method Info
            with the remainder being left null to account for optional parameters. Permute and Optional set this array.
            </summary>
        </member>
        <member name="P:AboditNLP.Rules.RuleFound.FirstParameter">
            <summary>
            FirstParameter is used to guide what tokens to look for (if we need the result of this rule, then we need to match its first parameter)
            </summary>
        </member>
        <member name="P:AboditNLP.Rules.RuleFound.Priority">
            <summary>
            The priority of this rule compared to another rule that might also be valid at the same point in the parse tree
            </summary>
        </member>
        <member name="P:AboditNLP.Rules.RuleFound.Probability">
            <summary>
            The probabiity of this rule compared to other rules that might be valid at the same point in the parse tree
            </summary>
        </member>
        <member name="M:AboditNLP.Rules.RuleFound.#ctor(System.Type,System.Reflection.MethodInfo,AboditNLP.Attributes.ParameterData[],System.Int32,System.Double)">
            <summary>
            Create a new instance of the RuleFound class
            </summary>
        </member>
        <member name="M:AboditNLP.Rules.RuleFound.#ctor(System.Type,System.Linq.Expressions.Expression{System.Func{System.Object[],System.Object}},AboditNLP.Attributes.ParameterData[],System.Int32,System.Double)">
            <summary>
            Create a new instance of the RuleFound class from an Expression
            </summary>
        </member>
        <member name="M:AboditNLP.Rules.RuleFound.HasPriorityOver(AboditNLP.Rules.RuleFound)">
            <summary>
            A rule has priority over another rule only if they are from the same class and Priorities imply that
            </summary>
        </member>
        <member name="M:AboditNLP.Rules.RuleFound.CompareTo(AboditNLP.Rules.RuleFound)">
            <summary>
            Compare to another instance of the RuleFound class
            </summary>
        </member>
        <member name="M:AboditNLP.Rules.RuleFound.Invoke(AboditNLP.IDependencyScope,System.Object[])">
            <summary>
            Invoke a rule passing the arguments found
            </summary>
        </member>
        <member name="M:AboditNLP.Rules.RuleFound.IsSameMethod(System.Reflection.MethodInfo)">
            <summary>
            Is ths the same method as the one specified?
            </summary>
        </member>
        <member name="M:AboditNLP.Rules.RuleFound.IsSameRule(AboditNLP.Rules.RuleFound)">
            <summary>
            Is this the same rule as another?
            </summary>
        </member>
        <member name="M:AboditNLP.Rules.RuleFound.Equals(AboditNLP.Rules.RuleFound)">
            <summary>
            IEquatable implementation
            </summary>
        </member>
        <member name="M:AboditNLP.Rules.ProductionRule.CreateFromExpression``2(System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Int32,AboditNLP.Attributes.Associativity,System.Double)">
            <summary>
            Create a Production Rule based on an Expression with one parameter
            </summary>
        </member>
        <member name="M:AboditNLP.Rules.ProductionRule.CreateFromExpression``3(System.Linq.Expressions.Expression{System.Func{``0,``1,``2}},System.Int32,AboditNLP.Attributes.Associativity,System.Double)">
            <summary>
            Create a Production Rule based on an Expression with two parameters
            </summary>
        </member>
        <member name="M:AboditNLP.Rules.ProductionRule.CreateFromConvertedParameters``1(System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression[])">
            <summary>
            Create a lambda expression for the rule using parameters that access an array of objects, converting each to the type needed for the call
            </summary>
        </member>
        <member name="T:AboditNLP.Rules.RuleInvoker">
            <summary>
            Abstract base class for invoking a rule's method (instance, static or Expression-based)
            </summary>
        </member>
        <member name="F:AboditNLP.Rules.RuleInvokerInstance.methodInfo">
            <summary>
            The method that is called when this rule fires
            </summary>
        </member>
        <member name="M:AboditNLP.Rules.RuleInvokerInstance.GetController(AboditNLP.IDependencyScope)">
            <summary>
            Get the appropriate controller for a rule, using extraObjects and IDependencyScope to resolve any
            necessary constructor parameters
            </summary>
        </member>
        <member name="F:AboditNLP.Rules.RuleInvokerStatic.methodInfo">
            <summary>
            The method that is called when this rule fires
            </summary>
        </member>
        <member name="F:AboditNLP.Rules.RuleNode.rules">
            <summary>
            The rules that sit on this node, i.e. at the end of a stream of tokens all of which have matched
            There should be just one - otherwise how will we know which one to execute?
            </summary>
        </member>
        <member name="F:AboditNLP.Rules.RuleNode.canProduce">
            <summary>
            What types can be returned by production rules below here
            </summary>
        </member>
        <member name="P:AboditNLP.Rules.RuleNode.CanProduce">
            <summary>
            What types can be returned by production rules below here
            </summary>
        </member>
        <member name="P:AboditNLP.Rules.RuleNode.Rules">
            <summary>
            The rules that sit on this node, i.e. at the end of a stream of tokens all of which have matched
            </summary>
        </member>
        <member name="M:AboditNLP.Rules.RuleNode.NextMatchingNodes(AboditNLP.TokenResult)">
            <summary>
            Where can we go next if we have a matching type?
            </summary>
        </member>
        <member name="T:AboditNLP.Rules.RuleNode`1">
            <summary>
            A RuleNode in the tree of rules, knows how to get to the next nodes and what rules are on it
            </summary>
        </member>
        <member name="F:AboditNLP.Rules.RuleNode`1.RootRule">
            <summary>
            The root of the rule tree
            </summary>
        </member>
        <member name="F:AboditNLP.Rules.RuleNode`1.ruleNodeReferences">
            <summary>
            Links on to new nodes for the next token to recognize
            </summary>
        </member>
        <member name="P:AboditNLP.Rules.RuleNode`1.Children">
            <summary>
            All the rule nodes that can be reached below here
            </summary>
        </member>
        <member name="M:AboditNLP.Rules.RuleNode`1.NextMatchingNodes(AboditNLP.TokenResult)">
            <summary>
            Where can we go next if we have a matching type?
            </summary>
        </member>
        <member name="M:AboditNLP.Rules.RuleNode`1.AddOrFollowReference(AboditNLP.Attributes.ParameterData,System.Type)">
            <summary>
            Add or follow a reference to a new node
            </summary>
        </member>
        <member name="M:AboditNLP.Rules.RuleNode`1.ValidTokenTypes">
            <summary>
            What Tokens are valid at this point in the parse graph? (And are they sensitive?)
            </summary>
        </member>
        <member name="M:AboditNLP.Rules.RuleNode`1.Add(AboditNLP.Rules.RuleFound)">
            <summary>
            Add a rule to the tree
            </summary>
            <returns>the RuleNode at the end of the chain - the one our rule was added to</returns>
        </member>
        <member name="M:AboditNLP.Rules.RuleNode`1.DumpAllRulesWithIndent">
            <summary>
            Dump all the rules in the rules base for debugging
            </summary>
            <returns></returns>
        </member>
        <member name="M:AboditNLP.Rules.RuleNode`1.DumpAllRulesWithIndent(System.Int32)">
            <summary>
            Dump all the rules in the rules base below a given node
            </summary>
        </member>
        <member name="M:AboditNLP.Rules.RuleNode`1.DumpAllRules">
            <summary>
            Dump all the rules in the rules base below a given node
            </summary>
        </member>
        <member name="T:AboditNLP.Rules.RuleNodeMain">
            <summary>
            Rule node for a normal sentence node
            </summary>
        </member>
        <member name="M:AboditNLP.Rules.RuleNodeMain.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:AboditNLP.Rules.RuleNodeProduction">
            <summary>
            Rule node for a production rule
            </summary>
        </member>
        <member name="F:AboditNLP.Rules.RuleNodeProduction.productionRules">
            <summary>
            A list of all production rules
            </summary>
        </member>
        <member name="F:AboditNLP.Rules.RuleNodeProduction.productionRulesByReturnType">
            <summary>
            A cache of production rules keyed on the type that they return after casting, e.g. IFoo
            </summary>
        </member>
        <member name="M:AboditNLP.Rules.RuleNodeProduction.ProductionRulesThatCanProduce(System.Type)">
            <summary>
            Get production rules that can produce a given type (after casting)
            </summary>
        </member>
        <member name="M:AboditNLP.Rules.RuleNodeProduction.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:AboditNLP.Rules.RuleNodeReference`1">
            <summary>
            A reference that can be traversed to get to another rule node if the conditions are met - i.e. satisfied the types on it
            </summary>
        </member>
        <member name="P:AboditNLP.Rules.RuleNodeReference`1.Type">
            <summary>
            The Type you need to match to follow this outbound edge
            </summary>
        </member>
        <member name="P:AboditNLP.Rules.RuleNodeReference`1.InterfaceConstraints">
            <summary>
            Additional interface constraints on the type, e.g. IPastTense
            </summary>
        </member>
        <member name="P:AboditNLP.Rules.RuleNodeReference`1.Sensitivity">
            <summary>
            Least restrictive sensitivity below here
            </summary>
        </member>
        <member name="M:AboditNLP.Rules.RuleNodeReference`1.CanMatch(AboditNLP.TokenResult)">
            <summary>
            We can match a type (checks both the base type and the constraints we have) 
            </summary>
        </member>
        <member name="M:AboditNLP.Rules.RuleNodeReference`1.ToString">
            <summary>
            ToString
            </summary>
        </member>
        <member name="T:AboditNLP.TokenList">
            <summary>
            A token list is the list of tokens found as we parse the input ...
            </summary>
        </member>
        <member name="P:AboditNLP.TokenList.Start">
            <summary>
            Start point in input
            </summary>
        </member>
        <member name="P:AboditNLP.TokenList.End">
            <summary>
            End point in input
            </summary>
        </member>
        <member name="M:AboditNLP.TokenList.Extend(System.Object,System.Int32,System.Int32)">
            <summary>
            Extend the current list as a new list by adding one token to the end
            </summary>
        </member>
        <member name="M:AboditNLP.TokenList.GetLast(System.Int32)">
            <summary>
            Get last n-steps in the token list
            </summary>
        </member>
        <member name="M:AboditNLP.TokenList.Complete(AboditNLP.Rules.RuleFound,System.Int32)">
            <summary>
            Get a clone that is completed and has a score
            </summary>
        </member>
        <member name="P:AboditNLP.TokenList.RuleFound">
            <summary>
            The rule found when we reached the end
            </summary>
        </member>
        <member name="M:AboditNLP.TokenList.ToString">
            <summary>
            String representation of a token list ...
            </summary>
            <returns></returns>
        </member>
        <member name="M:AboditNLP.TokenList.SequenceEqual(AboditNLP.TokenList)">
            <summary>
            Do two TokenLists match
            </summary>
        </member>
        <member name="T:AboditNLP.TokenResult">
            <summary>
            When you pass in a string to tokenize there may be one or more results, each says what kind of token
            it is returning and how many characters it wants to claim to generate that token
            </summary>
        </member>
        <member name="P:AboditNLP.TokenResult.Value">
            <summary>
            The object that we will pass as a parameter to the action method
            </summary>
        </member>
        <member name="P:AboditNLP.TokenResult.Input">
            <summary>
            The original, complete input string
            </summary>
            <remarks>
            Original uses this to return a span from Start to End.
            </remarks>
        </member>
        <member name="P:AboditNLP.TokenResult.Original">
            <summary>
            The original input string, from start to end
            </summary>
        </member>
        <member name="P:AboditNLP.TokenResult.Lowercased">
            <summary>
            Lower cased version of the token string
            </summary>
        </member>
        <member name="P:AboditNLP.TokenResult.Start">
            <summary>
            The start position in the input
            </summary>
        </member>
        <member name="P:AboditNLP.TokenResult.End">
            <summary>
            The end position in the input
            </summary>
        </member>
        <member name="P:AboditNLP.TokenResult.CharactersClaimed">
            <summary>
            Number of characters claimed
            </summary>
        </member>
        <member name="P:AboditNLP.TokenResult.Quality">
            <summary>
            Quality of the Token (higher if space after)
            </summary>
        </member>
        <member name="P:AboditNLP.TokenResult.Probability">
            <summary>
            Probability that this token is what it says it is. Lower if no space after. Lower if uncommon word.
            </summary>
        </member>
        <member name="P:AboditNLP.TokenResult.SensitivityUsed">
            <summary>
            What combination of edits and case insensitivity was used
            </summary>
        </member>
        <member name="M:AboditNLP.TokenResult.#ctor(System.Object,System.String,System.Int32,System.Int32,Abodit.Sensitivity,System.Double,System.Double)">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.TokenResult"/> class
            </summary>
        </member>
        <member name="M:AboditNLP.TokenResult.ToString">
            <summary>
            Returns a string for the token result
            </summary>
        </member>
        <member name="M:AboditNLP.TokenResult.Equals(AboditNLP.TokenResult)">
            <summary>
            Equals implementation
            </summary>
        </member>
        <member name="T:AboditNLP.AllowedToken">
            <summary>
            Allowed token type and any insensitive variations allowed
            </summary>
            <remarks>
            Immutable
            </remarks>
        </member>
        <member name="P:AboditNLP.AllowedToken.Type">
            <summary>
            The Type of the AllowedToken
            </summary>
        </member>
        <member name="P:AboditNLP.AllowedToken.Sensitivity">
            <summary>
            The sensitivity
            </summary>
        </member>
        <member name="M:AboditNLP.AllowedToken.#ctor(AboditNLP.Attributes.ParameterData)">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.AllowedToken"/> class
            </summary>
        </member>
        <member name="M:AboditNLP.AllowedToken.#ctor(System.Type,Abodit.Sensitivity)">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.AllowedToken"/> class
            </summary>
        </member>
        <member name="M:AboditNLP.AllowedToken.WithType(System.Type)">
            <summary>
            Change type, e.g. from IAmbiguous.. to plain T
            </summary>
        </member>
        <member name="M:AboditNLP.AllowedToken.WithSensitivity(Abodit.Sensitivity)">
            <summary>
            Change sensitivity
            </summary>
        </member>
        <member name="M:AboditNLP.AllowedToken.Equals(AboditNLP.AllowedToken)">
            <summary>
            Test for equality
            </summary>
        </member>
        <member name="M:AboditNLP.AllowedToken.Incorporates(AboditNLP.AllowedToken)">
            <summary>
            Is this AllowedToken a superset of the other?
            </summary>
        </member>
        <member name="T:AboditNLP.IAmbiguous`1">
            <summary>
            A rule can look for an ambiguous database hit by specifying IAmbiguous with a type parameter being the type you want
            </summary>
        </member>
        <member name="P:AboditNLP.IAmbiguous`1.IsAmbiguous">
            <summary>
            Is this ambiguous result really ambiguous (i.e. has more than one value)
            </summary>
        </member>
        <member name="T:AboditNLP.ProducesAttribute">
            <summary>
            An attribute that is applied to factories to say what kind of types they can produce.  If you say a factory
            can produce type X then it is assume that it can also produce any type derived from X.
            </summary>
        </member>
        <member name="P:AboditNLP.ProducesAttribute.Types">
            <summary>
            Get the Types that the class annotated with this produces attribute can produce
            </summary>
        </member>
        <member name="M:AboditNLP.ProducesAttribute.#ctor(System.Type[])">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.ProducesAttribute"/> class
            </summary>
        </member>
        <member name="T:AboditNLP.ProducesOnlyInterfaceTypesAttribute">
            <summary>
            An attribute that says "No hard Tokens" from this factory
            </summary>
        </member>
        <member name="T:AboditNLP.TokenQuantityOfNounWithUnits">
            <summary>
            A quantity of some noun
            </summary>
        </member>
        <member name="P:AboditNLP.TokenQuantityOfNounWithUnits.Noun">
            <summary>
            The name of the thing
            </summary>
        </member>
        <member name="P:AboditNLP.TokenQuantityOfNounWithUnits.Quantity">
            <summary>
            The quantity of the thing
            </summary>
        </member>
        <member name="M:AboditNLP.TokenQuantityOfNounWithUnits.#ctor(System.Double,System.String)">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.TokenQuantityOfNounWithUnits"/> class
            </summary>
        </member>
        <member name="P:AboditNLP.TokenQuantityOfNounWithUnits.Uri">
            <summary>
            Fers a Uri for this Token
            </summary>
        </member>
        <member name="T:AboditNLP.Ontology.Relation">
            <summary>
            A relation between two entities
            </summary>
        </member>
        <member name="T:AboditNLP.Ontology.IsA">
            <summary>
            An IsA relation
            </summary>
        </member>
        <member name="T:AboditNLP.Ontology.IsAProperty">
            <summary>
            An IsProperty relation
            </summary>
        </member>
        <member name="T:AboditNLP.Ontology.HasA">
            <summary>
            A HasA relation
            </summary>
        </member>
        <member name="T:AboditNLP.Ontology.IsATypeOf">
            <summary>
            An IsATypeOf relation
            </summary>
        </member>
        <member name="T:AboditNLP.Ontology.IsTheSameAs">
            <summary>
            An IsTheSameAs relation
            </summary>
        </member>
        <member name="T:AboditNLP.Ontology.Transitive">
            <summary>
            A transitive relation
            </summary>
        </member>
        <member name="T:AboditNLP.Ontology.Symmetric">
            <summary>
            A symmetric relation
            </summary>
        </member>
        <member name="T:AboditNLP.Ontology.Inverse">
            <summary>
            An inverse relation
            </summary>
        </member>
        <member name="T:AboditNLP.Ontology.Functional">
            <summary>
            A functional relation
            </summary>
        </member>
        <member name="T:AboditNLP.Ontology.IsPluralOf">
            <summary>
            An IsPluralOf relation
            </summary>
        </member>
        <member name="T:AboditNLP.Ontology.IsSingularOf">
            <summary>
            An IsSingularOf relation
            </summary>
        </member>
        <member name="T:AboditNLP.Ontology.IsPastTenseOf">
            <summary>
            An IsPastTenseOf relation
            </summary>
        </member>
        <member name="T:AboditNLP.Ontology.IsPresentTenseOf">
            <summary>
            An IsPresentTenseOf relation
            </summary>
        </member>
        <member name="T:AboditNLP.Ontology.OntologyRelations">
            <summary>
            A generator for ontological relations
            </summary>
        </member>
        <member name="M:AboditNLP.Ontology.OntologyRelations.CreateWords(AboditNLP.ILexemeStore)">
            <summary>
            Create the words
            </summary>
        </member>
        <member name="T:AboditNLP.TokenPhrase">
            <summary>
            A phrase, any number of words
            </summary>
        </member>
        <member name="P:AboditNLP.TokenPhrase.Text">
            <summary>
            Gets the original string (lazily created only when needed)
            </summary>
        </member>
        <member name="P:AboditNLP.TokenPhrase.Quoted">
            <summary>
            Was the original a quoted phrase or not (May come in handy in some cases)
            </summary>
        </member>
        <member name="M:AboditNLP.TokenPhrase.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.TokenPhrase"/> class
            </summary>
        </member>
        <member name="M:AboditNLP.TokenPhrase.#ctor(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Creates a new instance of the <see cref="T:AboditNLP.TokenPhrase"/> class
            </summary>
        </member>
        <member name="M:AboditNLP.TokenPhrase.ToString">
            <summary>
            Returns a string representation of this object
            </summary>
            <returns></returns>
        </member>
        <member name="M:AboditNLP.TokenPhrase.Generate(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Generates a TokenPhrase from the input
            </summary>
        </member>
        <member name="M:AboditNLP.TokenPhrase.IsEachWordCapitalized(System.String,System.Int32,System.Int32)">
            <summary>
            Does the input follow the pattern CAP LOWER LOWER SPACE CAP LOWER LOWER ...
            </summary>
        </member>
        <member name="T:AboditNLP.TokenPhraseCapitalized">
            <summary>
            A Capitalized TokenPhrase
            </summary>
        </member>
        <member name="T:AboditNLP.TokenPhraseQuoted">
            <summary>
            A Quoted TokenPhrase (overrides capitalized)
            </summary>
        </member>
        <member name="T:Geo.Place">
            <summary>
            A Place word or phrase. Currently created for Yahoo GeoNames
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenInt">
            <summary>
            An integer value of 6 or less digits
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenInt.ValueInt">
            <summary>
            The integer value
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenInt.ToString">
            <summary>
            Returns a string representing the object
            </summary>
            <returns></returns>
        </member>
        <member name="M:Abodit.Expressions.TokenInt.DoDescribe(System.Boolean)">
            <summary>
            Returns a string version of the object
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenInt.#ctor(System.Int32,System.String)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Expressions.TokenInt"/> class
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenLong">
            <summary>
            A token representing a long value
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenLong.ValueLong">
            <summary>
            The actual long value
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenLong.ToString">
            <summary>
            Returns a string representation for this object
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenLong.DoDescribe(System.Boolean)">
            <summary>
            Describe this value
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenLong.#ctor(System.Int64,System.String)">
            <summary>
            Creates a new instance of the <see cref="T:Abodit.Expressions.TokenLong"/> class
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenOrdinal">
            <summary>
            51st, fifty second, etc.
            </summary>
        </member>
        <member name="T:Abodit.Expressions.TokenRational">
            <summary>
            One sixth, 2/7 etc.
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenRational.Numerator">
            <summary>
            Get the numerator of the fraction
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenRational.Denominator">
            <summary>
            Get the denominator of the fraction
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenRational.Ordinal">
            <summary>
            Gets the ordinal form, if any
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenRational.Cardinal">
            <summary>
            Gets the cardinal form, if any
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenRational.Fraction">
            <summary>
            Gets the fractional form, if any
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenRational.FractionPlural">
            <summary>
            Gets the plural fractional form, if any
            </summary>
        </member>
        <member name="M:Abodit.Expressions.TokenRational.#ctor(System.Int64,System.Int64,System.String)">
            <summary>
            Create a new instance of a rational value token
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenRational.Synset">
            <summary>
            Get the Synset for this rational number
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenRational.Singular">
            <summary>
            The singular form, or null
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenRational.SingularPossessive">
            <summary>
            The singular possessive form, or null
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenRational.Plural">
            <summary>
            The plural form, or null
            </summary>
        </member>
        <member name="P:Abodit.Expressions.TokenRational.PluralPossessive">
            <summary>
            The plural posessive form, or null
            </summary>
        </member>
    </members>
</doc>
